Compiling Program: C:\DataFlex Projects\GNRELibrary\AppSrc\desenvolvimento.src
Memory Available: 2147483646
1>//  TestProject for Windows application
1>
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files (x86)\DataFlex 18.1\Pkg\dfallent.pkd)
74682>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files (x86)\DataFlex 18.1\Pkg\cCJStandardCommandBarSystem.pkg)
74682>>>// these are all the packages used in a standard MDI menubar/toolbar system
74682>>>
74682>>>Use cCJCommandBarSystem.pkg
74682>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files (x86)\DataFlex 18.1\Pkg\cCJStandardMenuItemClasses.pkg)
74682>>>>>Use Dfpanel.pkg
74682>>>>>Use cCJCommandBarSystem.pkg
74682>>>>>Use LanguageText.pkg
74682>>>>>
74682>>>>>
74682>>>>>Class cCJUndoMenuItem is a cCJMenuItem
74683>>>>>    
74683>>>>>    Procedure Construct_Object
74685>>>>>        Forward Send Construct_Object
74687>>>>>        Set psCaption   to C_$CaptionUndo
74688>>>>>        Set psToolTip to C_$ToolTipUndo
74689>>>>>        Set psDescription to C_$DescUndo
74690>>>>>        Set psImage to "ActionUndo.ico"
74691>>>>>        Set pbActiveUpdate to True
74692>>>>>        Set psCategory to C_$CategoryEdit
74693>>>>>        Set psShortcut to C_$Key_Ctrl_Z
74694>>>>>    End_Procedure
74695>>>>>
74695>>>>>    Procedure OnExecute Variant vCommandBarControl
74697>>>>>        Send Undo of (focus(Self))
74698>>>>>    End_Procedure
74699>>>>>    
74699>>>>>    Function IsEnabled Returns Boolean
74701>>>>>        Boolean bEnabled
74701>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
74702>>>>>        Function_Return bEnabled
74703>>>>>    End_Function
74704>>>>>         
74704>>>>>End_Class
74705>>>>>
74705>>>>>
74705>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
74706>>>>>    
74706>>>>>    Procedure Construct_Object
74708>>>>>        Forward Send Construct_Object
74710>>>>>        Set psCaption   to C_$CaptionDelete
74711>>>>>        Set psToolTip to C_$ToolTipDelete
74712>>>>>        Set psDescription to C_$DescDelete
74713>>>>>        Set psImage to "actionDelete.ico"
74714>>>>>        Set psShortcut to C_$Key_Delete
74715>>>>>        Set pbActiveUpdate to True
74716>>>>>        Set psCategory to C_$CategoryEdit
74717>>>>>    End_Procedure
74718>>>>>
74718>>>>>
74718>>>>>    Procedure OnExecute Variant vCommandBarControl
74720>>>>>        Send Delete of (focus(Self))
74721>>>>>    End_Procedure
74722>>>>>    
74722>>>>>    Function IsEnabled Returns Boolean
74724>>>>>        Boolean bEnabled
74724>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
74725>>>>>        Function_Return bEnabled
74726>>>>>    End_Function
74727>>>>>         
74727>>>>>End_Class
74728>>>>>
74728>>>>>
74728>>>>>Class cCJCutMenuItem is a cCJMenuItem
74729>>>>>    
74729>>>>>    Procedure Construct_Object
74731>>>>>        Forward Send Construct_Object
74733>>>>>        Set psCaption   to C_$CaptionCut
74734>>>>>        Set psToolTip to C_$TooltipCut
74735>>>>>        Set psDescription to C_$DescCut
74736>>>>>        Set psImage to "actionCut.ico"
74737>>>>>        Set psShortcut to C_$Key_Ctrl_X
74738>>>>>        Set pbActiveUpdate to True
74739>>>>>        Set psCategory to C_$CategoryEdit
74740>>>>>    End_Procedure
74741>>>>>
74741>>>>>
74741>>>>>    Procedure OnExecute Variant vCommandBarControl
74743>>>>>        Send Cut of (focus(Self))
74744>>>>>    End_Procedure
74745>>>>>    
74745>>>>>    Function IsEnabled Returns Boolean
74747>>>>>        Boolean bEnabled
74747>>>>>        Get CanCut of (Focus(Self)) to bEnabled
74748>>>>>        Function_Return bEnabled
74749>>>>>    End_Function
74750>>>>>         
74750>>>>>End_Class
74751>>>>>
74751>>>>>
74751>>>>>Class cCJCopyMenuItem is a cCJMenuItem
74752>>>>>    
74752>>>>>    Procedure Construct_Object
74754>>>>>        Forward Send Construct_Object
74756>>>>>        Set psCaption   to C_$CaptionCopy
74757>>>>>        Set psToolTip to C_$ToolTipCopy
74758>>>>>        Set psDescription to C_$DescCopy
74759>>>>>        Set psImage to "actionCopy.ico"
74760>>>>>        Set psShortcut to C_$Key_Ctrl_C
74761>>>>>        Set pbActiveUpdate to True
74762>>>>>        Set psCategory to C_$CategoryEdit
74763>>>>>    End_Procedure
74764>>>>>
74764>>>>>
74764>>>>>    Procedure OnExecute Variant vCommandBarControl
74766>>>>>        Send Copy of (focus(Self))
74767>>>>>    End_Procedure
74768>>>>>    
74768>>>>>    Function IsEnabled Returns Boolean
74770>>>>>        Boolean bEnabled
74770>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
74771>>>>>        Function_Return bEnabled
74772>>>>>    End_Function
74773>>>>>         
74773>>>>>End_Class
74774>>>>>
74774>>>>>
74774>>>>>Class cCJPasteMenuItem is a cCJMenuItem
74775>>>>>    
74775>>>>>    Procedure Construct_Object
74777>>>>>        Forward Send Construct_Object
74779>>>>>        Set psCaption   to C_$CaptionPaste
74780>>>>>        Set psToolTip to C_$ToolTipPaste
74781>>>>>        Set psDescription to C_$DescPaste
74782>>>>>        Set psImage to "actionPaste.ico"
74783>>>>>        Set pbActiveUpdate to True
74784>>>>>        Set psShortcut to C_$Key_Ctrl_V
74785>>>>>        Set psCategory to C_$CategoryEdit
74786>>>>>    End_Procedure
74787>>>>>
74787>>>>>
74787>>>>>    Procedure OnExecute Variant vCommandBarControl
74789>>>>>        Send Paste of (focus(Self))
74790>>>>>    End_Procedure
74791>>>>>    
74791>>>>>    Function IsEnabled Returns Boolean
74793>>>>>        Boolean bEnabled
74793>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
74794>>>>>        Function_Return bEnabled
74795>>>>>    End_Function
74796>>>>>         
74796>>>>>End_Class
74797>>>>>
74797>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
74798>>>>>    
74798>>>>>    Procedure Construct_Object
74800>>>>>        Forward Send Construct_Object
74802>>>>>        Set psCaption   to C_$CaptionSelectAll
74803>>>>>        Set psToolTip to C_$ToolTipSelectAll
74804>>>>>        Set psDescription to C_$DescSelectAll
74805>>>>>        Set pbActiveUpdate to True
74806>>>>>        Set psShortcut to C_$Key_Ctrl_A
74807>>>>>        Set psCategory to C_$CategoryEdit
74808>>>>>    End_Procedure
74809>>>>>
74809>>>>>
74809>>>>>    Procedure OnExecute Variant vCommandBarControl
74811>>>>>        Send Select_All of (focus(Self))
74812>>>>>    End_Procedure
74813>>>>>    
74813>>>>>    Function IsEnabled Returns Boolean
74815>>>>>        Boolean bEnabled
74815>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
74816>>>>>        Function_Return bEnabled
74817>>>>>    End_Function
74818>>>>>         
74818>>>>>End_Class
74819>>>>>
74819>>>>> 
74819>>>>>Class cCJExitMenuItem is a cCJMenuItem
74820>>>>>
74820>>>>>    Procedure Construct_Object
74822>>>>>        Forward Send Construct_Object
74824>>>>>        Set psCaption to C_$CaptionExit
74825>>>>>        Set psToolTip to C_$ToolTipExit
74826>>>>>        Set psDescription to C_$ToolTipExit
74827>>>>>        Set psShortcut to C_$Key_Alt_F4
74828>>>>>        Set psCategory to C_$CategoryFile
74829>>>>>    End_Procedure
74830>>>>>
74830>>>>>    Procedure OnExecute Variant vCommandBarControl
74832>>>>>        Send Exit_Application of Desktop
74833>>>>>    End_Procedure
74834>>>>>
74834>>>>>End_Class           
74835>>>>>
74835>>>>>Class cCJHelpMenuItem is a cCJMenuItem    
74836>>>>>
74836>>>>>    Procedure Construct_Object
74838>>>>>        Forward Send Construct_Object
74840>>>>>        Set psCaption to C_$CaptionHelp
74841>>>>>        Set psDescription to C_$ToolTipHelp
74842>>>>>        Set psToolTip to C_$DescHelp
74843>>>>>        Set psImage to "ActionHelp.ico"
74844>>>>>        Set psShortcut to "F1"
74845>>>>>        Set psCategory to C_$CategoryHelp
74846>>>>>    End_Procedure
74847>>>>>    
74847>>>>>    Procedure OnExecute Variant vCommandBarControl
74849>>>>>        Send Help of (Focus(Self))
74850>>>>>    End_Procedure
74851>>>>>
74851>>>>>End_Class
74852>>>>>
74852>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
74853>>>>>
74853>>>>>    Procedure Construct_Object
74855>>>>>        Forward Send Construct_Object
74857>>>>>        Set psCaption to C_$CaptionAddStatusbar
74858>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
74859>>>>>        Set psDescription to  C_$DescAddStatusbar
74860>>>>>        Set psCategory to C_$CategoryWindow
74861>>>>>    End_Procedure
74862>>>>>
74862>>>>>    Procedure OnExecute Variant vCommandBarControl
74864>>>>>        Handle hoCommandBars hoClientArea
74864>>>>>        Get CommandBarSystemObject to hoCommandBars
74865>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
74866>>>>>        If hoClientArea Begin
74868>>>>>            // the clientarea's parent panel has message
74868>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
74869>>>>>        End
74869>>>>>>
74869>>>>>    End_Procedure
74870>>>>>
74870>>>>>     Function IsChecked Returns Boolean
74872>>>>>        Boolean bOn
74872>>>>>        Handle hoCommandBars hoClientArea
74872>>>>>        Get CommandBarSystemObject to hoCommandBars
74873>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
74874>>>>>        If hoClientArea Begin
74876>>>>>            // the clientarea's parent panel has message
74876>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
74877>>>>>        End
74877>>>>>>
74877>>>>>        Function_Return bOn
74878>>>>>     End_Function
74879>>>>>End_Class
74880>>>>>
74880>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
74881>>>>>
74881>>>>>    Procedure Construct_Object
74883>>>>>        Forward Send Construct_Object
74885>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
74886>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
74887>>>>>        Set psDescription to C_$DescAutoArrangeIcons
74888>>>>>        Set psCategory to C_$CategoryWindow
74889>>>>>    End_Procedure
74890>>>>>
74890>>>>>    Procedure OnExecute Variant vCommandBarControl
74892>>>>>        Handle hoCommandBars hoClientArea
74892>>>>>        Get CommandBarSystemObject to hoCommandBars
74893>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
74894>>>>>        If hoClientArea Begin
74896>>>>>            // the clientarea's parent panel has message
74896>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
74897>>>>>        End
74897>>>>>>
74897>>>>>    End_Procedure
74898>>>>>    
74898>>>>>     Function IsChecked Returns Boolean
74900>>>>>        Boolean bOn
74900>>>>>        Handle hoCommandBars hoClientArea
74900>>>>>        Get CommandBarSystemObject to hoCommandBars
74901>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
74902>>>>>        If hoClientArea Begin
74904>>>>>            // the clientarea's parent panel has message
74904>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
74905>>>>>        End
74905>>>>>>
74905>>>>>        Function_Return bOn
74906>>>>>     End_Function
74907>>>>>End_Class
74908>>>>>
74908>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
74909>>>>>
74909>>>>>    Procedure Construct_Object
74911>>>>>        Forward Send Construct_Object
74913>>>>>        Set psCaption to C_$CaptionRestoreMenus
74914>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
74915>>>>>        Set psDescription to C_$DescRestoreMenus
74916>>>>>        Set psCategory to C_$CategoryWindow
74917>>>>>    End_Procedure
74918>>>>>
74918>>>>>    Procedure OnExecute Variant vCommandBarControl
74920>>>>>        Handle hoCommandBars
74920>>>>>        Get CommandBarSystemObject to hoCommandBars
74921>>>>>        Send RestoreLayout of hoCommandBars
74922>>>>>    End_Procedure
74923>>>>>    
74923>>>>>End_Class
74924>>>>>
74924>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
74925>>>>>
74925>>>>>    Procedure Construct_Object
74927>>>>>        Forward Send Construct_Object
74929>>>>>        Set psCaption to C_$CaptionCascade
74930>>>>>        Set psToolTip to C_$ToolTipCascade
74931>>>>>        Set psDescription to  C_$DescCascade
74932>>>>>        Set psImage to "ActionCascade.ico"
74933>>>>>        Set psCategory to C_$CategoryWindow
74934>>>>>    End_Procedure
74935>>>>>    
74935>>>>>    Procedure OnExecute Variant vCommandBarControl
74937>>>>>        Handle hoCommandBars hoClientArea
74937>>>>>        Get CommandBarSystemObject to hoCommandBars
74938>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
74939>>>>>        If hoClientArea Begin
74941>>>>>            Send Cascade_Windows of hoClientArea
74942>>>>>        End
74942>>>>>>
74942>>>>>    End_Procedure
74943>>>>>End_Class
74944>>>>>
74944>>>>>Class cCJTileHorizontally is a cCJMenuItem
74945>>>>>
74945>>>>>    Procedure Construct_Object
74947>>>>>        Forward Send Construct_Object
74949>>>>>        Set psCaption to C_$CaptionTileHorizontally 
74950>>>>>        Set psToolTip to C_$ToolTipTileHorizontally  
74951>>>>>        Set psDescription to  C_$DescTileHorizontally
74952>>>>>        Set psImage to "ActionTileHorizontally.ico"
74953>>>>>        Set psCategory to C_$CategoryWindow
74954>>>>>    End_Procedure
74955>>>>>
74955>>>>>    Procedure OnExecute Variant vCommandBarControl
74957>>>>>        Handle hoCommandBars hoClientArea
74957>>>>>        Get CommandBarSystemObject to hoCommandBars
74958>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
74959>>>>>        If hoClientArea Begin
74961>>>>>            Send Tile_Windows_Horizontal of hoClientArea
74962>>>>>        End
74962>>>>>>
74962>>>>>    End_Procedure
74963>>>>>End_Class
74964>>>>>
74964>>>>>Class cCJTileVertically is a cCJMenuItem
74965>>>>>
74965>>>>>    Procedure Construct_Object
74967>>>>>        Forward Send Construct_Object
74969>>>>>        Set psCaption to C_$CaptionTileVertically  
74970>>>>>        Set psToolTip to C_$ToolTipTileVertically
74971>>>>>        Set psDescription to  C_$DescTileVertically
74972>>>>>        Set psImage to "ActionTileVertically.ico"
74973>>>>>        Set psCategory to C_$CategoryWindow
74974>>>>>    End_Procedure
74975>>>>>
74975>>>>>    Procedure OnExecute Variant vCommandBarControl
74977>>>>>        Handle hoCommandBars hoClientArea
74977>>>>>        Get CommandBarSystemObject to hoCommandBars
74978>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
74979>>>>>        If hoClientArea Begin
74981>>>>>            Send Tile_Windows_Vertical of hoClientArea
74982>>>>>        End
74982>>>>>>
74982>>>>>    End_Procedure
74983>>>>>End_Class
74984>>>>>
74984>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
74985>>>>>
74985>>>>>    Procedure Construct_Object
74987>>>>>        Forward Send Construct_Object
74989>>>>>        Set psCaption to C_$CaptionMinimizeWindows 
74990>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
74991>>>>>        Set psDescription to  C_$DescMinimizeWindows
74992>>>>>        Set psCategory to C_$CategoryWindow
74993>>>>>    End_Procedure
74994>>>>>
74994>>>>>    Procedure OnExecute Variant vCommandBarControl
74996>>>>>        Handle hoCommandBars hoClientArea
74996>>>>>        Get CommandBarSystemObject to hoCommandBars
74997>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
74998>>>>>        If hoClientArea Begin
75000>>>>>            // the clientarea's parent panel has message
75000>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
75001>>>>>        End
75001>>>>>>
75001>>>>>    End_Procedure
75002>>>>>End_Class
75003>>>>>
75003>>>>>
75003>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
75004>>>>>
75004>>>>>    Procedure Construct_Object
75006>>>>>        Forward Send Construct_Object
75008>>>>>        Set psCaption to C_$CaptionRestoreWindows
75009>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
75010>>>>>        Set psDescription to  C_$DescRestoreWindows
75011>>>>>        Set psCategory to C_$CategoryWindow
75012>>>>>    End_Procedure
75013>>>>>
75013>>>>>    Procedure OnExecute Variant vCommandBarControl
75015>>>>>        Handle hoCommandBars hoClientArea
75015>>>>>        Get CommandBarSystemObject to hoCommandBars
75016>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75017>>>>>        If hoClientArea Begin
75019>>>>>            // the clientarea's parent panel has message
75019>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
75020>>>>>        End
75020>>>>>>
75020>>>>>    End_Procedure
75021>>>>>End_Class
75022>>>>>
75022>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
75023>>>>>
75023>>>>>    Procedure Construct_Object
75025>>>>>        Forward Send Construct_Object
75027>>>>>        Set psCaption to C_$CaptionArrangeIcons  
75028>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
75029>>>>>        Set psDescription to  C_$DescArrangeIcons
75030>>>>>        Set psCategory to C_$CategoryWindow
75031>>>>>    End_Procedure
75032>>>>>
75032>>>>>    Procedure OnExecute Variant vCommandBarControl
75034>>>>>        Handle hoCommandBars hoClientArea
75034>>>>>        Get CommandBarSystemObject to hoCommandBars
75035>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75036>>>>>        If hoClientArea Begin
75038>>>>>            Send Arrange_Icons of hoClientArea
75039>>>>>        End
75039>>>>>>
75039>>>>>    End_Procedure
75040>>>>>
75040>>>>>End_Class
75041>>>>>    
75041>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files (x86)\DataFlex 18.1\Pkg\cCJAboutMenuItem.pkg)
75041>>>>>Use cCJCommandBarSystem.pkg
75041>>>>>Use LanguageText.pkg
75041>>>>>
75041>>>>>// It is expected that if you use this class that you provide an about object that is
75041>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
75041>>>>>// because you may wish to create your own custom about package.
75041>>>>>
75041>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
75042>>>>>
75042>>>>>    Procedure Construct_Object
75044>>>>>        Forward Send Construct_Object
75046>>>>>        Set psCaption to C_$CaptionAbout
75047>>>>>        Set psDescription to C_$ToolTipAbout
75048>>>>>        Set psToolTip to C_$DescAbout
75049>>>>>        Set psImage to "ActionAbout.ico"
75050>>>>>        Set psCategory to C_$CategoryHelp
75051>>>>>    End_Procedure
75052>>>>>    
75052>>>>>    Procedure OnExecute Variant vCommandBarControl
75054>>>>>        Handle hoCommandBars hoClientArea
75054>>>>>        Get CommandBarSystemObject to hoCommandBars
75055>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75056>>>>>        If hoClientArea Begin
75058>>>>>            Send Activate_About of hoClientArea
75059>>>>>        End
75059>>>>>>
75059>>>>>    End_Procedure
75060>>>>>
75060>>>>>End_Class
75061>>>>>
75061>>>>>
75061>>>Use cCJDeoMenuItemClasses.pkg
75061>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files (x86)\DataFlex 18.1\Pkg\cCJMDIWindowsMenuItem.pkg)
75061>>>>>Use cCJCommandBarSystem.pkg
75061>>>>>
75061>>>>>Register_Function Client_ID Returns Integer
75061>>>>>
75061>>>>>// only used by cCJMDIWIndowsMenuItem
75061>>>>>Class cCJMDIWindowItem is a cCJMenuItem
75062>>>>>
75062>>>>>    Procedure Construct_Object
75064>>>>>        Forward Send Construct_Object
75066>>>>>        Property Handle phWindow 0 // object id of view
75067>>>>>        Set pbControlFlagNoMovable to True
75068>>>>>        Set pbActiveUpdate to True
75069>>>>>    End_Procedure
75070>>>>>    
75070>>>>>    Procedure OnExecute Variant vCommandBarControl
75072>>>>>        Handle hWindow
75072>>>>>        Get phWindow to hWindow
75073>>>>>        Send Activate_View of hWindow
75074>>>>>    End_Procedure
75075>>>>>    
75075>>>>>End_Class                
75076>>>>>
75076>>>>>
75076>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
75077>>>>>    
75077>>>>>    Procedure Construct_Object
75079>>>>>        Forward Send Construct_Object
75081>>>>>        Property Handle[] phArrayOfWindows
75082>>>>>        Set peControlType to xtpControlPopup
75083>>>>>        Set psCategory to C_$CategoryWindow
75084>>>>>    End_Procedure
75085>>>>>    
75085>>>>>     // This adds MDI windows to the existing menu items.
75085>>>>>     // This removes any existing windows menus and always adds a new set to the end
75085>>>>>
75085>>>>>     Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
75087>>>>>        Handle  hClientArea hView
75087>>>>>        String  sLabel
75087>>>>>        Integer i iWindows
75087>>>>>        Handle[] hArrayOfWindows
75088>>>>>        Variant vItem
75088>>>>>        
75088>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
75088>>>>>        // also assume that destroying an action removes all menu instances of that action
75088>>>>>        Get phArrayOfWindows to hArrayOfWindows
75089>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
75090>>>>>        For i from 0 to (iWindows-1)
75096>>>>>>
75096>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
75097>>>>>        Loop
75098>>>>>>
75098>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
75099>>>>>
75099>>>>>        // Add all views to this menu. Create the action and add the item
75099>>>>>        Move 0 to i
75100>>>>>        Get Client_Id to hClientArea // object id of client area
75101>>>>>        If (hClientArea > 0) Begin
75103>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
75104>>>>>            While (hView <> 0)
75108>>>>>                If (Active_State(hView)) Begin
75110>>>>>                    // create the action
75110>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
75111>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
75112>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
75113>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
75114>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
75116>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
75117>>>>>                    End
75117>>>>>>
75117>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
75118>>>>>                    If (i=0) Begin
75120>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
75121>>>>>                    End
75121>>>>>>
75121>>>>>                    // Create a menu item for this action
75121>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
75122>>>>>                    Increment i
75123>>>>>                End
75123>>>>>>
75123>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
75124>>>>>            Loop
75125>>>>>>
75125>>>>>        End
75125>>>>>>
75125>>>>>
75125>>>>>        Set phArrayOfWindows to hArrayOfWindows
75126>>>>>
75126>>>>>     End_Procedure
75127>>>>>     
75127>>>>>End_Class
75128>>>>>
75128>
75128>Object oHtmlHelp is a cHtmlHelp
75130>End_Object
75131>
75131>Object oApplication is a cApplication
75133>    Set pbPreserveEnvironment to False
75134>    Set peHelpType to htHtmlHelp
75135>    Set psCompany to "Harsy Sistemas, Prog. Inf. Ltda"
75136>    Set psProduct to "GNRE Library"
75137>End_Object
75138>
75138>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 18.1\Pkg\oEditContextMenu.pkg)
75138>>>Use cCJStandardMenuItemClasses.pkg
75138>>>
75138>>>Object oEditContextMenu is a cCJContextMenu
75140>>>    
75140>>>    Move Self to Default_Form_Floating_Menu_ID
75141>>>    
75141>>>    Object oUndoMenuItem is a cCJUndoMenuItem
75143>>>    End_Object
75144>>>    
75144>>>    Object oCutMenuItem is a cCJCutMenuItem
75146>>>        Set pbControlBeginGroup to True
75147>>>    End_Object
75148>>>    
75148>>>    Object oCopyMenuItem is a cCJCopyMenuItem
75150>>>    End_Object
75151>>>
75151>>>    Object oPasteMenuItem is a cCJPasteMenuItem
75153>>>    End_Object
75154>>>
75154>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
75156>>>    End_Object
75157>>>
75157>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
75159>>>        Set pbControlBeginGroup to True
75160>>>    End_Object
75161>>>
75161>>>End_Object
75162>>>
75162>Use oDEOEditContextMenu.pkg
Including file: oDEOEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 18.1\Pkg\oDEOEditContextMenu.pkg)
75162>>>Use Windows.pkg
75162>>>Use cCJStandardMenuItemClasses.pkg
75162>>>Use cCJDeoMenuItemClasses.pkg
75162>>>
75162>>>
75162>>>Object oDEOEditContextMenu is a cCJContextMenu
75164>>>    
75164>>>    Move Self to Default_dbFloating_Menu_ID
75165>>>    
75165>>>    Object oUndoMenuItem is a cCJUndoMenuItem
75167>>>    End_Object
75168>>>    
75168>>>    Object oCutMenuItem is a cCJCutMenuItem
75170>>>        Set pbControlBeginGroup to True
75171>>>    End_Object
75172>>>    
75172>>>    Object oCopyMenuItem is a cCJCopyMenuItem
75174>>>    End_Object
75175>>>
75175>>>    Object oPasteMenuItem is a cCJPasteMenuItem
75177>>>    End_Object
75178>>>
75178>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
75180>>>    End_Object
75181>>>
75181>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
75183>>>        Set pbControlBeginGroup to True
75184>>>    End_Object
75185>>>
75185>>>    Object oPromptMenuItem is a cCJPromptMenuItem
75187>>>        Set pbControlBeginGroup to True
75188>>>    End_Object
75189>>>
75189>>>    Object oFindNextMenu is a cCJFindNextMenuItem
75191>>>        Set pbControlBeginGroup to True
75192>>>    End_Object
75193>>>
75193>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
75195>>>    End_Object
75196>>>
75196>>>    Object oClearMenuItem is a cCJClearMenuItem
75198>>>        Set pbControlBeginGroup to True
75199>>>    End_Object
75200>>>
75200>>>    Object oClearAllMenu is a cCJClearAllMenuItem
75202>>>    End_Object
75203>>>
75203>>>    Object oSaveMenu is a cCJSaveMenuItem
75205>>>    End_Object
75206>>>    
75206>>>    Object oDeleteMenu is a cCJDeleteMenuItem
75208>>>    End_Object
75209>>>
75209>>>
75209>>>End_Object
75210>
75210>Object oMain is a Panel
75212>
75212>    Property Handle phoViewMenu 0
75214>    Property Handle phoReportMenu 0
75216>
75216>    Set Label to "Biblioteca GuiasGnre"
75217>    Set Location to 4 3
75218>    Set Size to 300 650
75219>    Set View_Mode to ViewMode_Zoom
75220>
75220>    Object oCommandBarSystem is a cCJCommandBarSystem
75222>        Set pbTimerUpdate to True
75223>
75223>        Procedure OnCreateCommandBars
75226>            Handle hoOptions
75226>            Get OptionsObject to hoOptions
75227>            Forward Send OnCreateCommandBars
75229>        End_Procedure
75230>   
75230>        Object oMenuBar is a cCJMenuBar
75232>            
75232>            Object oFileMenu is a cCJMenuItem
75234>                Set peControlType to xtpControlPopup          
75235>                Set psCaption   to "&Arquivo"
75236>                Set psDescription to "Localizar, gravar, excluir, limpar informa‡ao ou sair desta aplica‡ao"
75237>                Set psCategory to "Menus"
75238>    
75238>                Object oClearMenuItem is a cCJClearMenuItem
75240>                    Set pbAddToDesignerMenu to True
75241>                End_Object
75242>    
75242>                Object oClearAllMenu is a cCJClearAllMenuItem
75244>                    Set pbAddToDesignerMenu to True
75245>                End_Object
75246>    
75246>                Object oPromptMenuItem is a cCJPromptMenuItem
75248>                    Set pbAddToDesignerMenu to True
75249>                    Set pbControlBeginGroup to True
75250>                End_Object
75251>    
75251>                Object oFindMenuItem is a cCJFindMenuItem
75253>                    Set pbAddToDesignerMenu to True
75254>                    Set pbControlBeginGroup to True
75255>                End_Object
75256>    
75256>                Object oFindNextMenu is a cCJFindNextMenuItem
75258>                    Set pbAddToDesignerMenu to True
75259>                End_Object
75260>    
75260>                Object oFindPreviousMenu is a cCJFindPreviousMenuItem
75262>                    Set pbAddToDesignerMenu to True
75263>                End_Object
75264>    
75264>                Object oFindFirstMenu is a cCJFindFirstMenuItem
75266>                    Set pbAddToDesignerMenu to True
75267>                End_Object
75268>    
75268>                Object oFindLastMenu is a cCJFindLastMenuItem
75270>                    Set pbAddToDesignerMenu to True
75271>                End_Object
75272>    
75272>                Object oSaveMenuItem is a cCJSaveMenuItem
75274>                    Set pbAddToDesignerMenu to True
75275>                    Set pbControlBeginGroup to True
75276>                End_Object
75277>    
75277>                Object oDeleteMenuItem is a cCJDeleteMenuItem
75279>                    Set pbAddToDesignerMenu to True
75280>                End_Object
75281>    
75281>                Object oExitMenu is a cCJExitMenuItem
75283>                    Set pbControlBeginGroup to True
75284>                End_Object
75285>
75285>            End_Object
75286>            
75286>            Object oViewMenu is a cCJMenuItem
75288>                Set peControlType to xtpControlPopup
75289>                Set psCaption to "&Exemplos"
75290>                Set psToolTip to "Exemplos"
75291>                Set psDescription to "Exemplos dispon¡veis"
75292>
75292>                Object ooExemploMenuItem is a cCJMenuItem
75294>                    Set psCaption to "Exemplo da fun‡Æo GGGCriaAssinatura_Gratis"
75295>                    Set psTooltip to "Exemplo da fun‡Æo GGGCriaAssinatura_Gratis"
75296>                
75296>                    Procedure OnExecute Variant vCommandBarControl
75299>                        Handle hoClient
75299>                        Get Client_Id to hoClient
75300>                        Send Activate_oExemplo of hoClient
75301>                    End_Procedure
75302>                End_Object
75303>
75303>                Object oGeraGuiaMenuItem is a cCJMenuItem
75305>                    Set psCaption to "GeraGuia"
75306>                    Set psTooltip to "GeraGuia"
75307>                
75307>                    Procedure OnExecute Variant vCommandBarControl
75310>                        Handle hoClient
75310>                        Get Client_Id to hoClient
75311>                        Send Activate_oExemplo2 of hoClient
75312>                    End_Procedure
75313>                End_Object
75314>            End_Object
75315>            
75315>            Object oReportMenu is a cCJMenuItem
75317>                Set peControlType to xtpControlPopup          
75318>                Set psCaption to "&Relat¢rios"
75319>                Set psToolTip to "Relat¢rios"
75320>                Set psDescription to "Relat¢rios dispon¡veis"
75321>            End_Object
75322>            
75322>            Object oNavigateMenu is a cCJMenuItem
75324>                Set peControlType to xtpControlPopup      
75325>                Set psCaption to "&Navega‡ao"    
75326>                Set psTooltip to "Navega‡ao"    
75327>                Set psDescription to "Posicionar em diferentes  reas da aplica‡ao"
75328>                
75328>                Object oNextAreaMenu is a cCJNextAreaMenu
75330>                End_Object
75331>                
75331>                Object oPriorAreaMenu is a cCJPriorAreaMenu
75333>                End_Object
75334>                
75334>                Object oNextViewMenu is a cCJNextViewMenu
75336>                End_Object
75337>                
75337>                Object oPriorViewMenu is a cCJPriorViewMenu
75339>                End_Object
75340>                
75340>                Object oPromptMenu is a cCJPromptMenuItem
75342>                    Set pbControlBeginGroup to True
75343>                End_Object
75344>    
75344>                Object oZoomMenu is a cCJZoomMenuItem
75346>                End_Object
75347>    
75347>            End_Object
75348>    
75348>            Object oWindowMenu is a cCJMDIWindowsMenuItem
75350>                Set peControlType to xtpControlPopup      
75351>                Set psCaption to "&Janela"
75352>                Set psToolTip to "Janela"
75353>                Set psDescription to "Mostrar views atuais e setar outras op‡oes de apresenta‡ao"    
75354>                
75354>                // These are the static windows items. More will be created in onInitPopup 
75354>                Object oDisplayOptionsMenu is a cCJMenuItem
75356>                    Set peControlType to xtpControlPopup          
75357>                    Set psCaption to "Op‡oes de &apresenta‡ao"
75358>                    Set psToolTip to "Op‡oes de apresenta‡ao"
75359>                    Set psDescription to "Configurar modo de apresenta‡ao"
75360>    
75360>                    Object oStatusbarMenu is a cCJStatusbarMenuItem
75362>                    End_Object
75363>    
75363>                    Object oAutoArrangeIconsMenu is a cCJAutoArrangeIconsMenuItem
75365>                    End_Object
75366>    
75366>                    Object oRestoreMenusMenu is a cCJRestoreMenusMenuItem
75368>                        Set pbControlBeginGroup to True
75369>                    End_Object
75370>
75370>                End_Object
75371>    
75371>                Object oCascadeMenu is a cCJCascadeMenuItem
75373>                    Set pbControlBeginGroup to True
75374>                End_Object
75375>    
75375>                Object oHorizTile is a cCJTileHorizontally
75377>                End_Object
75378>    
75378>                Object oVertTile is a cCJTileVertically
75380>                End_Object
75381>    
75381>                Object oMinimizeMenuItem is a cCJMinimizeWindowsMenuItem
75383>                    Set pbControlBeginGroup to True
75384>                End_Object
75385>    
75385>                Object oRestoreMenuItem is a cCJRestoreWindowsMenuItem
75387>                End_Object
75388>    
75388>                Object oArrangeIconsMenuItem is a cCJAutoArrangeIconsMenuItem
75390>                    Set pbControlBeginGroup to True
75391>                End_Object
75392>    
75392>            End_Object
75393>            
75393>            Object oHelpMenu is a cCJMenuItem
75395>                Set peControlType to xtpControlPopup    
75396>                Set psCaption to "&Ajuda"
75397>                Set psDescription to "Acessar informa‡ao para aprendizado e uso desta aplica‡ao DataFlex"
75398>                Set psToolTip to "Ajuda"
75399>                
75399>                Object oHelpMenuItem is a cCJHelpMenuItem 
75401>                End_Object
75402>    
75402>                Object oAboutMenuItem is a cCJAboutMenuItem
75404>                End_Object
75405>           
75405>            End_Object
75406>    
75406>        End_Object
75407>    
75407>        Object oFindToolBar is a cCJToolbar
75409>            Set psTitle to "Barra de ferramentas de busca"
75410>    
75410>            Object oFindFirstTool is a cCJFindFirstMenuItem
75412>            End_Object
75413>    
75413>            Object oFindPreviousTool is a cCJFindPreviousMenuItem
75415>            End_Object
75416>    
75416>            Object oFindMenuTool is a cCJFindMenuItem
75418>            End_Object
75419>    
75419>            Object oFindNextTool is a cCJFindNextMenuItem
75421>            End_Object
75422>    
75422>            Object oFindLastTool is a cCJFindLastMenuItem
75424>            End_Object
75425>    
75425>            Object oPromptToolItem is a cCJPromptMenuItem
75427>                Set pbControlBeginGroup to True
75428>            End_Object
75429>    
75429>        End_Object
75430>            
75430>        Object oFileToolBar is a cCJToolbar
75432>            Set psTitle to "Barra de ferramentas de entrada de dados"
75433>    
75433>            Object oClearToolItem is a cCJClearMenuItem
75435>                Set peControlStyle to xtpButtonIconAndCaption
75436>            End_Object
75437>            
75437>            Object oClearAllToolItem2 is a cCJClearAllMenuItem
75439>                Set peControlStyle to xtpButtonIconAndCaption
75440>            End_Object
75441>                
75441>            Object oSaveToolItem is a cCJSaveMenuItem
75443>                Set peControlStyle to xtpButtonIconAndCaption
75444>                Set pbControlBeginGroup to True
75445>            End_Object
75446>    
75446>            Object oDeleteToolItem is a cCJDeleteMenuItem
75448>                Set peControlStyle to xtpButtonIconAndCaption
75449>            End_Object
75450>    
75450>        End_Object
75451>    
75451>        Object oEditToolBar is a cCJToolbar
75453>            Set psTitle to "Barra de ferramentas de edi‡ao"
75454>            
75454>            Object oCutToolbarItem is a cCJCutMenuItem
75456>            End_Object
75457>    
75457>            Object oCopyToolbarItem is a cCJCopyMenuItem
75459>            End_Object
75460>    
75460>            Object oPasteToolbarItem is a cCJPasteMenuItem
75462>            End_Object
75463>    
75463>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
75465>                Set pbControlBeginGroup to True
75466>            End_Object
75467>    
75467>        End_Object
75468>        
75468>        Object oStatusBar is a cCJStatusBar
75470>            
75470>            Object oStatusPane1 is a cCJStatusBarPane
75472>                Set piID to sbpIDIdlePane
75473>                Set pbStyleStretch to True
75474>            End_Object
75475>    
75475>            Object oStatusPane2 is a cCJStatusBarPane
75477>                Set phoViewPane to Self
75478>                Set pbStyleStretch to True
75479>            End_Object
75480>
75480>        End_Object
75481>
75481>        // for testing we define the view and report menus for auto activate
75481>        Delegate Set phoViewMenu to (oViewMenu)
75483>        Delegate Set phoReportMenu to (oReportMenu)
75485>    
75485>    End_Object
75486>   
75486>    Object oClientArea is a ClientArea
75488>
75488>        Use Dd_debug.dg // This Provides access to dd debugger by pressing ctrl+d within any view. Good for debugging
Including file: Dd_debug.dg    (C:\Program Files (x86)\DataFlex 18.1\Pkg\Dd_debug.dg)
75488>>>// dd_debug.dg - DDO debugger/inspector
75488>>>//
75488>>>// Copyright Data Access WorldWide 2003
75488>>>// John Tuohy
75488>>>//
75488>>>// By adding this to any Windows view or application (with a "use DD_Debug.dg") you can
75488>>>// inspect your DDOs and make sure they are doing what you think. To invoke this panel you
75488>>>// need to press ctrl/d (or send DebugDDs).
75488>>>//
75488>>>// As of 9.1, this also tests for sending reentrant messages to the DDO when the DDO is busy.
75488>>>// Normally, these messages are ignored - now you get an error message (so you can fix it).
75488>>>// Also, you can set a limit for number of filtered records so you can see if you are using
75488>>>// optimized and non-optimized indexes the way you think you are.
75488>>>//
75488>>>// NOTE: This package should NEVER appear in a deployed application. It is just for your
75488>>>//       own development and testing.
75488>>>
75488>>>
75488>>>
75488>>>Validate_Packages 18 0 1
75488>>>
75488>>>Define CR_LF for (Character(13)+Character(10))
75488>>>
75488>>>// This provides support for DDO Rentancy checking and for testing for
75488>>>// non-optimal finding.
75488>>>Use DD_OperationChecker.pkg
Including file: dd_OperationChecker.pkg    (C:\Program Files (x86)\DataFlex 18.1\Pkg\dd_OperationChecker.pkg)
75488>>>>>// dd_OperationChecker.pkg for VDF10.0
75488>>>>>//
75488>>>>>// Copyright Data Access WorldWide 2003
75488>>>>>// John Tuohy
75488>>>>>//
75488>>>>>//
75488>>>>>// One of the harder DDO errors to see is the issue of reentrancy. A number of the DDO operations are not
75488>>>>>// reentrant. When a message such as Request_Save, Request_find or Clear is sent to a DDO all DDOs are considered
75488>>>>>// to be "busy" until the operationis complete. While DDOs are busy you can not send messages to ANY other DDO in
75488>>>>>// ANY other part of your application. The file structure of DDOs and the the C structure of DDOs do not allow this.
75488>>>>>// If you do send a reentrant message while the DDOs are busy the reentrant message is ignored. Here lies the problem.
75488>>>>>// You are trying to perform some kind of DDO customization and some of these customized behaviors are ignored without
75488>>>>>// any kind of warning or error.
75488>>>>>//
75488>>>>>// The following DDO messages are non re-entrant. While any of these methods are being processed you cannot send any of these
75488>>>>>// messages to any DDOs.
75488>>>>>//
75488>>>>>//     Clear
75488>>>>>//     Clear_All
75488>>>>>//     Request_save
75488>>>>>//     Request_delete
75488>>>>>//     Request_assign
75488>>>>>//     Request_find
75488>>>>>//     Request_Superfind
75488>>>>>//     Find_by_recnum
75488>>>>>//
75488>>>>>//
75488>>>>>// This package provides diagnostic code that checks these messages and makes sure that are not trying to call them in a busy state.
75488>>>>>// Instead of the busy operation being ignored, an error will be reported. Once you see the error, you can fix it.
75488>>>>>//
75488>>>>>// In addition, there is a check built in here for non-optimal finding operations. You can set the value of giNonOptimalFindCount
75488>>>>>// to a non zero value and when a find operation filters that many recods, you will get an error.
75488>>>>>//
75488>>>>>// IMPORTANT: This is a debug package and should never be used in deployed applications. It should be used by the developer
75488>>>>>// to test their application. Once tested, the code should be removed.
75488>>>>>//
75488>>>>>// To Use
75488>>>>>// ------
75488>>>>>//
75488>>>>>// This is used as part of DD_Debug.dg. While this could be used stand-alone you really don't want to do this.
75488>>>>>//
75488>>>>>// NOTE: This can only be used with VDF9.1 or above. If you try to use this with older packages this will not compile!
75488>>>>>
75488>>>>>Validate_Packages 9 1 0
75488>>>>>Use Data_set.pkg
75488>>>>>
75488>>>>>// This variable determines of the rentrancy tests should be performed. dd_debug will use and set this
75488>>>>>Global_variable Integer gbTestRentrancy
75488>>>>>Move 1 to gbTestRentrancy
75489>>>>>
75489>>>>>// This determines how many failed finds is considered to be non-optimal. When 0, there is no check.
75489>>>>>Global_variable Integer giNonOptimalFindCount
75489>>>>>Move 0 to giNonOptimalFindCount
75490>>>>>
75490>>>>>Procedure CheckRentrancy for DataSet handle hoDD string sMessage
75492>>>>>    String sMess sVal
75492>>>>>    
75492>>>>>    If (gbTestRentrancy=0 or operation_mode=mode_waiting) Procedure_Return
75495>>>>>    
75495>>>>>    If (OPERATION_MODE=MODE_VALIDATING and Lowercase(sMessage)<>"request_save") Begin
75497>>>>>        // mode_validating is not really a non-reentrant DD function from the runtime's point of view. The DDs
75497>>>>>        // keep track of this mode. Therefore, we will let a re-entrant DD message pass through for all cases, except
75497>>>>>        // request_save because trying to perform a save while inside of a validate is most likely wrong.
75497>>>>>        Procedure_Return
75498>>>>>    End
75498>>>>>>
75498>>>>>    
75498>>>>>    Move ("DDO re-entrant operation attempted.\n\n"+;          "Message = " - sMessage - ".  Object =" - name(hoDD) -".\n"+ ;          "\nCurrent Operation_mode is " + string(operation_mode) +;          "\nCurrent Operation_origin is " + string(operation_origin) * name(operation_origin) ) to sMess
75499>>>>>    Error DFERR_PROGRAM sMess
75500>>>>>>
75500>>>>>end_procedure
75501>>>>>
75501>>>>>Procedure NonOptimalTest for DataSet  Handle hoDD string sMessage integer iOldDif integer iFile integer iIndex
75503>>>>>    string sMess
75503>>>>>    Integer iNewDif
75503>>>>>
75503>>>>>    Move (constrain_tests_count - Constrain_found_count) to iNewDif
75504>>>>>    If (iNewDif-iOldDif>giNonOptimalFindCount) Begin
75506>>>>>        Move ("Constrained Find may not be Optimized.\n\n"+;              "Message =" - sMessage - ".  Object = " - name(hoDD) -".\n"+ ;              "Test finds exceeds the limit of" * string(giNonOptimalFindCount) * "filtered records.\n" +;              "Number of records searched = " + string(iNewDif-iOldDif) + ".") to sMess
75507>>>>>        If (iFile>0) Begin
75509>>>>>            // if iFile is zero we don't don't which file is being found (i.e. Locate_next)
75509>>>>>            Move (sMess + "\nFile = " + string(iFile) + ". Index = "+ string(iIndex) + ".") to sMess
75510>>>>>        End
75510>>>>>>
75510>>>>>        Error DFERR_PROGRAM sMess
75511>>>>>>
75511>>>>>    end
75511>>>>>>
75511>>>>>end_procedure
75512>>>>>
75512>>>>>
75512>>>>>Procedure Clear for DataSet
75514>>>>>    Send CheckRentrancy self "clear"
75515>>>>>    forward send clear
75517>>>>>end_procedure
75518>>>>>
75518>>>>>Procedure Clear_All for DataSet
75520>>>>>    Send CheckRentrancy self "clear_all"
75521>>>>>    forward send clear_all
75523>>>>>end_procedure
75524>>>>>
75524>>>>>Procedure Request_Save for DataSet
75526>>>>>    Send CheckRentrancy self "request_save"
75527>>>>>    forward send request_save
75529>>>>>end_procedure
75530>>>>>
75530>>>>>Procedure Request_Delete for DataSet
75532>>>>>    Send CheckRentrancy self "request_delete"
75533>>>>>    forward send request_delete
75535>>>>>end_procedure
75536>>>>>
75536>>>>>Procedure Request_Assign for DataSet integer iFile
75538>>>>>    Send CheckRentrancy self "request_assign"
75539>>>>>    If (num_arguments=0) ;        forward send request_assign
75543>>>>>    else ;        forward send request_assign iFile
75546>>>>>end_procedure
75547>>>>>
75547>>>>>Procedure Find_By_Recnum for DataSet integer iFile integer iRecord
75549>>>>>    Send CheckRentrancy self "Find_by_recnum"
75550>>>>>    forward send Find_by_recnum iFile iRecord
75552>>>>>end_procedure
75553>>>>>
75553>>>>>Procedure Request_Find for DataSet integer iMode integer iFile integer iIndex
75555>>>>>    Integer iOldDif
75555>>>>>    Send CheckRentrancy self "request_find"
75556>>>>>    Move (constrain_tests_count - Constrain_found_count) to iOldDif
75557>>>>>    forward send request_find iMode iFile iIndex
75559>>>>>    If (giNonOptimalFindCount>0) Begin
75561>>>>>        Send NonOptimalTest self "request_find" iOldDif iFile iIndex
75562>>>>>    End
75562>>>>>>
75562>>>>>end_procedure
75563>>>>>
75563>>>>>Procedure Request_Read for DataSet integer iMode integer iFile integer iIndex
75565>>>>>    Integer iOldDif
75565>>>>>    Move (constrain_tests_count - Constrain_found_count) to iOldDif
75566>>>>>    forward send request_Read iMode iFile iIndex
75568>>>>>    If (giNonOptimalFindCount>0) Begin
75570>>>>>        Send NonOptimalTest  self "request_read" iOldDif iFile iIndex
75571>>>>>    End
75571>>>>>>
75571>>>>>end_procedure
75572>>>>>
75572>>>>>
75572>>>>>Procedure Request_Superfind for DataSet integer iMode integer iFile integer iField
75574>>>>>    Integer iOldDif
75574>>>>>    Send CheckRentrancy self "request_Superfind"
75575>>>>>    Move (constrain_tests_count - Constrain_found_count) to iOldDif
75576>>>>>    forward send Request_Superfind iMode iFile iField
75578>>>>>    If (giNonOptimalFindCount>0) Begin
75580>>>>>        Send NonOptimalTest  self "request_Superfind" iOldDif 0 0 // we don't have a file or an index
75581>>>>>    End
75581>>>>>>
75581>>>>>end_procedure
75582>>>>>
75582>>>
75582>>>Procedure EnumerateDDs for DataDictionary integer iMsg integer hId
75584>>>    Send iMsg of hID Self
75585>>>End_Procedure
75586>>>
75586>>>
75586>>>
75586>>>Use Windows.pkg
75586>>>Use dfCmbFrm.pkg
Including file: Dfcmbfrm.pkg    (C:\Program Files (x86)\DataFlex 18.1\Pkg\Dfcmbfrm.pkg)
75586>>>>>Use windows.pkg // this now lives here. (you don't need to ever use this). 
75586>>>Use dfTabDg.pkg
Including file: Dftabdg.pkg    (C:\Program Files (x86)\DataFlex 18.1\Pkg\Dftabdg.pkg)
75586>>>>>Use windows.pkg // this now lives here. (you don't need to ever use this). 
75586>>>Use DataDict.pkg
75586>>>Use cTextEdit.pkg
75586>>>
75586>>>Class cDDDebugResults is a cTextEdit
75587>>>    Procedure Construct_Object
75589>>>        Forward Send Construct_Object
75591>>>        
75591>>>        Set peAnchors to anAll
75592>>>        Set pbWrap to False
75593>>>        Set Read_Only_State to True
75594>>>        Set psTypeface to "Courier New"
75595>>>        Set FontPointHeight to 9
75596>>>        
75596>>>        Property String psEditValue ''
75597>>>    End_Procedure
75598>>>    
75598>>>    Procedure Delete_Data
75600>>>        Forward Send Delete_Data
75602>>>        
75602>>>        Set psEditValue to ''
75603>>>    End_Procedure
75604>>>    
75604>>>    Procedure Page Integer iPageObject
75606>>>        String sEditValue
75606>>>        
75606>>>        Forward Send Page iPageObject
75608>>>        If (iPageObject > 0) Begin
75610>>>            Get psEditValue to sEditValue
75611>>>            Set Value to sEditValue
75612>>>        End
75612>>>>
75612>>>    End_Procedure
75613>>>
75613>>>    Procedure Insert String sVal
75615>>>        Handle hWnd
75615>>>        String sEditValue
75615>>>        
75615>>>        Get Window_Handle to hWnd
75616>>>        If (hWnd <> 0) Begin
75618>>>            Send AppendText sVal
75619>>>        End
75619>>>>
75619>>>        Else Begin
75620>>>            Get psEditValue to sEditValue
75621>>>            Move (sEditValue + sVal) to sEditValue
75622>>>            Set psEditValue to sEditValue
75623>>>        End
75623>>>>
75623>>>    End_Procedure
75624>>>End_Class
75625>>>
75625>>>Object oDD_Debug is a ModalPanel
75627>>>
75627>>>    Property handle phoInvokingView    0
75629>>>    Property handle phoCurrentDD       0
75631>>>    Property handle phoFieldsEditId    0
75633>>>    Property Handle phoMiscEditId      0
75635>>>    Property Handle phoConstraintsEditId      0
75637>>>
75637>>>    Set Locate_mode to Center_on_screen
75638>>>    Set Border_Style to Border_Thick
75639>>>
75639>>>    On_key kCancel Send Close_Panel
75640>>>
75640>>>    Function IsRecnumTable integer iFile Returns boolean
75643>>>        Boolean bRecnumTable
75643>>>        Get_Attribute DF_FILE_RECNUM_TABLE of iFIle to bRecnumTable
75646>>>        Function_Return bRecnumTable
75647>>>    End_Function
75648>>>
75648>>>
75648>>>
75648>>>
75648>>>    Set Minimize_Icon to FALSE
75649>>>    Set Label to "Data Dictionary Inspector"
75650>>>    Set Location to 4 3
75651>>>    Set Size to 263 410
75652>>>
75652>>>
75652>>>
75652>>>
75652>>>    Object oDDCombo is a ComboForm
75654>>>
75654>>>        Set Label to "DD:"
75655>>>        Set Size to 13 103
75656>>>        Set Location to 6 19
75657>>>        Set Form_Border to 0
75658>>>        Set Label_Col_Offset to 2
75659>>>        Set Label_Justification_Mode to jMode_Right
75660>>>
75660>>>        set entry_state 0 to False
75661>>>        set combo_sort_state to false
75662>>>        Set peAnchors to anNone
75663>>>
75663>>>        Procedure AddDDs integer hDD
75666>>>            Integer iCnt
75666>>>            String sName
75666>>>            Get Combo_Item_Count to iCnt
75667>>>            Get Object_label of hDD to sName
75668>>>            Send Combo_Add_Item sName
75669>>>            Set Aux_Value of (combo_data_object(self)) iCnt to hDD
75670>>>            If (hDD=phoCurrentDD(self)) Set Value 0 to sName
75673>>>        End_procedure
75674>>>
75674>>>        Procedure Fill_List
75677>>>            Integer hVw
75677>>>            Get phoInvokingView to hVw
75678>>>            Send Combo_Delete_Data
75679>>>            Broadcast Send EnumerateDDs to hVw msg_AddDDs Self
75681>>>            //Set Value 0 to (Combo_value(self,0))
75681>>>            Send onChange
75682>>>        End_Procedure
75683>>>
75683>>>
75683>>>        Procedure onChange
75686>>>            Integer iItem hDD
75686>>>            Get combo_item_matching (value(self,0)) to iItem
75687>>>            if (iItem>=0) begin
75689>>>               Get Aux_Value of (combo_data_object(self)) iItem to hDD
75690>>>               Delegate Set phoCurrentDD to hDD
75692>>>               Delegate Send RefreshNewDD
75694>>>            end
75694>>>>
75694>>>        End_procedure
75695>>>
75695>>>    End_Object    // oDDCombo
75696>>>
75696>>>    Object oCurRec is a Form
75698>>>
75698>>>        Set Label to "Current Rec"
75699>>>        Set Size to 13 37
75700>>>        Set Location to 6 165
75701>>>        Set Label_Col_Offset to 2
75702>>>        Set Label_Justification_Mode to jMode_Right
75703>>>
75703>>>        Set numeric_mask 0 to 8 0
75704>>>        Set peAnchors to anNone
75705>>>
75705>>>        Procedure NewRec // note that this is never used.
75708>>>            Integer iRec iFile hDD
75708>>>            Get phoCurrentDD to hDD
75709>>>            if hDD Begin
75711>>>               get value 0 to iRec
75712>>>               Get Main_file of hDD to iFile
75713>>>               Set_Field_Value iFile 0 to iRec  // compatibility w/ recnum
75716>>>               send Find of hDD EQ 0
75717>>>               Send refreshAll
75718>>>            end
75718>>>>
75718>>>        End_procedure
75719>>>
75719>>>    End_Object    // oCurRec
75720>>>
75720>>>    Object oFindCurRec is a Button
75722>>>
75722>>>        Set Label to "Find"
75723>>>        Set Size to 13 20
75724>>>        Set Location to 6 205
75725>>>        Set peAnchors to anNone
75726>>>
75726>>>        Procedure OnClick
75729>>>            Integer iRec iFile hDD
75729>>>            Get phoCurrentDD to hDD
75730>>>            if hDD Begin
75732>>>               Get Main_file of hDD to iFile
75733>>>               If (IsRecnumTable(self,iFile)) begin
75735>>>                  Get value of oCurRec 0 to iRec
75736>>>                  Set_Field_Value iFile 0 to iRec // compatibility w/ recnum
75739>>>                  send Find of hDD EQ 0
75740>>>                  Send refreshAll
75741>>>               End
75741>>>>
75741>>>            end
75741>>>>
75741>>>        End_procedure
75742>>>
75742>>>    End_Object    // oFindCurRec
75743>>>
75743>>>    Object oDDRelatesTo is a ComboForm
75745>>>
75745>>>
75745>>>        Set Label to "Related To File:"
75746>>>        Set Size to 13 117
75747>>>        Set Location to 6 281
75748>>>        Set Form_Border to 0
75749>>>        Set Label_Col_Offset to 2
75750>>>        Set Label_Justification_Mode to jMode_Right
75751>>>
75751>>>        set entry_state 0 to False
75752>>>        set combo_sort_state to false
75753>>>        Set peAnchors to anNone
75754>>>
75754>>>        Procedure Fill_List
75757>>>            Integer hDD iCnt iLmt iFile hCDO iCFile
75757>>>            String sName
75757>>>            Send Combo_Delete_Data
75758>>>            Get phoCurrentDD to hDD
75759>>>            If hDD eq 0 Procedure_Return
75762>>>            Get Constrain_file of hDD to iCFile
75763>>>            Get Combo_data_object to hCDO
75764>>>            Move (server_file_count(hDD)-1) to iLmt
75765>>>            Send Combo_add_item "None"
75766>>>            Set Aux_Value of hCDO 0 to iFile
75767>>>            If iCFile eq 0 set Value 0 to "None"
75770>>>            For iCnt from 0 to iLmt
75776>>>>
75776>>>                Get Server_File of hDD iCnt to iFile
75777>>>                Get_Attribute DF_FILE_LOGICAL_NAME of iFile to sName
75780>>>                Send Combo_add_item sName
75781>>>                Set Aux_Value of hCDO (iCnt+1) to iFile
75782>>>                If iFile eq iCFile set Value 0 to sName
75785>>>            Loop
75786>>>>
75786>>>
75786>>>        End_Procedure
75787>>>
75787>>>
75787>>>        Procedure onChange
75790>>>            Integer iItem iFile hDD
75790>>>            Get phoCurrentDD to hDD
75791>>>            If (hDD=0) Procedure_Return
75794>>>            Get combo_item_matching (value(self,0)) to iItem
75795>>>            if (iItem>=0) begin
75797>>>               Get Aux_Value of (combo_data_object(self)) iItem to iFile
75798>>>               Set constrain_file of hDD to iFile
75799>>>               Send RebuildAllConstraints of hDD 
75800>>>//               Send rebuild_constraints of hDD
75800>>>               Delegate Send RefreshAll
75802>>>            end
75802>>>>
75802>>>        End_procedure
75803>>>
75803>>>    End_Object    // oDDRelatesTo
75804>>>
75804>>>    Object oShouldSave is a CheckBox
75806>>>
75806>>>        set enabled_state to False
75807>>>
75807>>>
75807>>>        Set Label to "Should Save"
75808>>>        Set Size to 10 55
75809>>>        Set Location to 22 5
75810>>>        Set peAnchors to anNone
75811>>>
75811>>>
75811>>>
75811>>>    End_Object    // oShouldSave
75812>>>
75812>>>    Object oChangedState is a CheckBox
75814>>>
75814>>>        set enabled_state to False
75815>>>
75815>>>
75815>>>        Set Label to "Changed State"
75816>>>        Set Size to 10 60
75817>>>        Set Location to 22 64
75818>>>        Set peAnchors to anNone
75819>>>
75819>>>
75819>>>
75819>>>    End_Object    // oChangedState
75820>>>
75820>>>    Object oAutoFill is a CheckBox
75822>>>        Set Label to "Auto-Fill"
75823>>>        Set Size to 10 41
75824>>>        Set Location to 22 128
75825>>>        Set peAnchors to anNone
75826>>>
75826>>>        Procedure Select_Toggling integer iItm integer bState
75829>>>            forward send select_toggling iItm bState
75831>>>            Set auto_fill_state of (phoCurrentDD(self)) to (checked_state(self))
75832>>>        End_Procedure
75833>>>
75833>>>    End_Object    // oAutoFill
75834>>>
75834>>>    Object oFillFromTop is a CheckBox
75836>>>        Set Label to "First-Rec Auto-fill"
75837>>>        Set Size to 10 71
75838>>>        Set Location to 22 172
75839>>>        Set peAnchors to anNone
75840>>>
75840>>>        Procedure Select_Toggling integer iItm integer bState
75843>>>            forward send select_toggling iItm bState
75845>>>            Set pbAutoFillFromFirst of (phoCurrentDD(self)) to (checked_state(self))
75846>>>        End_Procedure
75847>>>
75847>>>    End_Object    // oFillFromTop
75848>>>
75848>>>    Object oDDOrdering is a ComboForm
75850>>>        Set Label to "Ordering"
75851>>>        Set Size to 13 117
75852>>>        Set Location to 20 281
75853>>>        Set Form_Border to 0
75854>>>        Set Label_Col_Offset to 2
75855>>>        Set Label_Justification_Mode to jMode_Right
75856>>>
75856>>>        Set entry_state 0 to False
75857>>>        Set combo_sort_state to false
75858>>>        Set peAnchors to anNone
75859>>>
75859>>>        Procedure RefreshNewDD
75862>>>            Integer hDD iFile iSegs iNdxs i
75862>>>            Send Combo_Delete_Data
75863>>>            Get phoCurrentDD to hDD
75864>>>            If hDD Begin
75866>>>               Send Combo_Add_Item "Best.-1"
75867>>>               Send Combo_Add_Item "Index.0"
75868>>>               Get Main_file of hDD to iFile
75869>>>               Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iFile to iNdxs
75872>>>               For i from 1 to iNdxs
75878>>>>
75878>>>                  Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile i to iSegs
75881>>>                  If iSegs Send Combo_Add_Item ("Index."-string(i))
75884>>>               Loop
75885>>>>
75885>>>            End
75885>>>>
75885>>>        End_procedure
75886>>>
75886>>>        Procedure Set Ordering integer iOrdr
75889>>>           If iOrdr eq -1 Set Value 0 to "Best.-1"
75892>>>           else Set Value 0 to ("Index."-string(iOrdr))
75894>>>        end_procedure
75895>>>
75895>>>        Procedure OnChange
75898>>>            Integer hDD
75898>>>            String sVal
75898>>>            Get value 0 to sVal
75899>>>            get phoCurrentDD to hDD
75900>>>            If hDD set Ordering of hDD to (mid(sVal, 10, pos(".",sVal)+1))
75903>>>        End_procedure
75904>>>
75904>>>    End_Object    // oDDOrdering
75905>>>
75905>>>
75905>>>    Object oTD is a TabDialog
75907>>>        Set Size to 149 389
75908>>>        Set Location to 33 11
75909>>>        Set Rotate_Mode to RM_Rotate
75910>>>        Set peAnchors to anAll
75911>>>
75911>>>        Object oTP_Constraints is a TabPage
75913>>>            Set Label to "Constraints"
75914>>>            Set Tab_ToolTip_Value to "DD Constraints and Filters"
75915>>>            Delegate Set phoConstraintsEditId to Self
75917>>>            
75917>>>            Object oConstraintsEdit is a cDDDebugResults
75919>>>                Function FormatFileFieldName Integer iFile Integer iField Returns String
75922>>>                    String sFile sField sRet
75922>>>                    Boolean bOpen
75922>>>                    Get_Attribute DF_FILE_OPENED of iFile to bOpen
75925>>>                    If (bOpen) Begin
75927>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFile to sFile
75930>>>                        Get_Attribute DF_FIELD_NAME of iFile iField to sField
75933>>>                        Function_Return (sFile+"."+sField)    
75934>>>                    End
75934>>>>
75934>>>                    Else Begin
75935>>>                        Function_Return "file not open"
75936>>>                    End
75936>>>>
75936>>>                End_Function
75937>>>
75937>>>                 Procedure ShowDDOConstraints Handle hoDD
75940>>>                    Integer i j iMain iCurrentDDFile
75940>>>                    tConstraintDef[] Constraints
75940>>>                    tConstraintDef[] Constraints
75941>>>                    String sFilter 
75941>>>                    Handle hoDDOther
75941>>>                    
75941>>>                    Get Main_File of hoDD to iMain
75942>>>                    Get DDOConstraints of  hoDD to Constraints
75943>>>                    
75943>>>                    Send Insert "Current DDO Constraints"
75944>>>                    Send Insert CR_LF
75945>>>                    Send Insert ("  Number of Constraints = " + String(SizeOfArray(Constraints)))
75946>>>                    Send Insert CR_LF
75947>>>
75947>>>                    For i from 0 to (SizeOfArray(Constraints)-1)
75953>>>>
75953>>>                        If (iCurrentDDFile<>Constraints[i].iFile) Begin
75955>>>                            Send Insert CR_LF
75956>>>                            Move Constraints[i].iFile to iCurrentDDFile
75957>>>                            If (Constraints[i].iFile<>iMain) Begin
75959>>>                                Get Which_Data_Set of hoDD Constraints[i].iFile to hoDDOther
75960>>>                            End
75960>>>>
75960>>>                            Else Begin
75961>>>                                Move hoDD to hoDDOther
75962>>>                            End
75962>>>>
75962>>>                            Send Insert  ("Constraints from ")
75963>>>                            
75963>>>                            If (hoDDOther) Begin
75965>>>                                Send Insert  (Object_Label(hoDDOther))
75966>>>                            End
75966>>>>
75966>>>                            Else Begin
75967>>>                                // not sure this could ever happen
75967>>>                                Send Insert  ("unknown. No DDO for file "+String(Constraints[i].iFile))
75968>>>                            End
75968>>>>
75968>>>                            
75968>>>                            If (hoDD<>hoDDOther) Begin
75970>>>                                Send Insert " (inherited)"
75971>>>                            End
75971>>>>
75971>>>                            
75971>>>                            Send Insert CR_LF
75972>>>                        End
75972>>>>
75972>>>                        
75972>>>                        
75972>>>                        Send Insert ("  " +String(i+1) + " Type=")
75973>>>                        Case Begin
75973>>>                            Case (Constraints[i].eType=CONST_VALUE) Send Insert "CONST_VALUE"
75976>>>                            Case (Constraints[i].eType=CONST_CHILD) Send Insert "CONST_CHILD"
75980>>>                            Case (Constraints[i].eType=CONST_FIELD) Send Insert "CONST_FIELD"
75984>>>                            Case (Constraints[i].eType=CONST_EXP) Send Insert "CONST_EXP"
75988>>>                            Case (Constraints[i].eType=CONST_RELATES) Send Insert "CONST_RELATES"
75992>>>                        Case End
75992>>>                        
75992>>>                        If (Constraints[i].eType=CONST_VALUE or Constraints[i].eType=CONST_FIELD) Begin
75994>>>                            Send Insert " mode="
75995>>>                            Case Begin
75995>>>                                Case (Constraints[i].eMODE=CONST_LT) Send Insert "LT"
75998>>>                                Case (Constraints[i].eMODE=CONST_LE) Send Insert "LE"
76002>>>                                Case (Constraints[i].eMODE=CONST_EQ) Send Insert "EQ"
76006>>>                                Case (Constraints[i].eMODE=CONST_GE) Send Insert "GE"
76010>>>                                Case (Constraints[i].eMODE=CONST_GT) Send Insert "GT"
76014>>>                                Case (Constraints[i].eMODE=CONST_NE) Send Insert "NE"
76018>>>                                Case (Constraints[i].eMODE=CONST_Matches) Send Insert "matches"
76022>>>                                Case (Constraints[i].eMODE=CONST_Contains) Send Insert "contains"
76026>>>                                Case (Constraints[i].eMODE=CONST_MatchesJumpIn) Send Insert "matches_JumpIn"
76030>>>                            Case End
76030>>>                        End
76030>>>>
76030>>>                        If (Constraints[i].eType<>CONST_EXP) Begin
76032>>>                            Send Insert (" File.Field=" + String(Constraints[i].iFile))
76033>>>                            Send Insert ("."  + String(Constraints[i].iField))
76034>>>                            Send Insert (" (" + FormatFileFieldName(Self,Constraints[i].iFile,Constraints[i].iField)+")")
76035>>>                        End
76035>>>>
76035>>>                        If (Constraints[i].eType=CONST_CHILD or Constraints[i].eType=CONST_FIELD) Begin
76037>>>                            Send Insert (" Other File.Field="  + String(Constraints[i].iOtherFile))
76038>>>                            Send Insert ("."  + String(Constraints[i].iOtherField))
76039>>>                            Send Insert (" (" + FormatFileFieldName(Self,Constraints[i].iOtherFile,Constraints[i].iOtherField)+")")
76040>>>                        End
76040>>>>
76040>>>                        Else If (Constraints[i].eType=CONST_VALUE) Begin
76043>>>                            Send Insert  (" Value=" + String(Constraints[i].sValue))
76044>>>                        End
76044>>>>
76044>>>                        Send Insert CR_LF
76045>>>                    Loop
76046>>>>
76046>>>                    
76046>>>                    Send Insert CR_LF
76047>>>                    
76047>>>                    Send ShowIndices hoDD
76048>>>                    
76048>>>                    
76048>>>                 End_Procedure
76049>>>                 
76049>>>                Procedure ShowIndices Handle hoDD
76052>>>                
76052>>>                    Integer iLastIndex
76052>>>                    Integer iIndex i
76052>>>                    Integer iNumSegments
76052>>>                    Integer hTable
76052>>>                    tDDOConstraintFindMeta FindMeta
76052>>>                    tDDOConstraintFindMeta FindMeta
76052>>>                    Get Main_File of hoDD to hTable
76053>>>                    
76053>>>                    Send Insert CR_LF
76054>>>                    Send Insert "Indexes and Constraints"
76055>>>                    Send Insert CR_LF
76056>>>                
76056>>>                    Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
76059>>>                    For iIndex from 1 to iLastIndex
76065>>>>
76065>>>                        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
76068>>>                        If (iNumSegments > 0) Begin
76070>>>                            
76070>>>                            Get DDOConstraintFindMeta of hoDD (GE) iIndex to FindMeta 
76071>>>
76071>>>                            Send Insert ("    Index " + String(iIndex)+": ")
76072>>>                            If (FindMeta.iJumpInSegments>0 or FindMeta.bJumpOut or FindMeta.bPreRelate or FindMeta.bPostRelate) Begin
76074>>>                                Send Insert ( "Jumpin "+String(FindMeta.iJumpInSegments)+" of "+String(iNumSegments)+". " )
76075>>>                                Send Insert ( (If(FindMeta.bJumpOut,"JumpOut. ", "")) + (If(FindMeta.bPreRelate,"Pre-Relate. ", "")) + (If(FindMeta.bPostRelate,"Post-Relate. ", "")) )
76076>>>                            End
76076>>>>
76076>>>                            Else Begin
76077>>>                                Send Insert "No Constraints"
76078>>>                            End
76078>>>>
76078>>>                            Send Insert CR_LF
76079>>>                        End
76079>>>>
76079>>>                    Loop
76080>>>>
76080>>>                End_Procedure // ShowIndices
76081>>>
76081>>>                Procedure RefreshAll
76084>>>                    Handle hDD
76084>>>                    Get phoCurrentDD to hDD
76085>>>                    Set Dynamic_update_state to False
76086>>>                    Send Delete_Data
76087>>>                    If (hDD) Begin
76089>>>                        Send ShowDDOConstraints hDD
76090>>>                    End
76090>>>>
76090>>>                    Send Beginning_Of_Data
76091>>>                    Set Dynamic_update_state to True
76092>>>                End_Procedure
76093>>>
76093>>>
76093>>>
76093>>>                Set Size to 100 375
76094>>>                Set Location to 4 4
76095>>>
76095>>>
76095>>>
76095>>>            End_Object
76096>>>            
76096>>>            Object oSQLFilterCkBox is a CheckBox
76098>>>                Set Size to 10 50
76099>>>                Set Location to 122 4
76100>>>                Set Label to "Use SQL Filter"
76101>>>                Set peAnchors to anBottom
76102>>>            
76102>>>                Procedure Select_Toggling Integer iItm Integer bState
76105>>>                    Handle hoDDO
76105>>>                    Boolean bFilter
76105>>>                    Get phoCurrentDD to hoDDO
76106>>>                    Forward Send select_toggling iItm bState
76108>>>                    Get Checked_State to bFilter
76109>>>                    Set pbUseDDSQLFilters of hoDDO to bFilter
76110>>>                    Send ApplySQLFilterInfo
76111>>>                End_Procedure
76112>>>            
76112>>>            End_Object
76113>>>
76113>>>            Object oInherit is a CheckBox
76115>>>                Set Label to "Inherit Constraints"
76116>>>                Set Size to 10 69
76117>>>                Set Location to 107 4
76118>>>                Set peAnchors to anBottomLeft
76119>>>        
76119>>>                Procedure Select_Toggling Integer iItm Integer bState
76122>>>                    Integer hDD
76122>>>                    Get phoCurrentDD to hDD
76123>>>                    Forward Send select_toggling iItm bState
76125>>>                    Set pbInheritConstraints of hDD to (checked_state(Self))
76126>>>                    If (hDD>0) Begin
76128>>>                        Send RebuildAllConstraints of hDD 
76129>>>//                        Send rebuild_constraints to hDD
76129>>>                        Send RefreshAll
76130>>>                    End
76130>>>>
76130>>>                End_Procedure
76131>>>        
76131>>>            End_Object    // oInherit
76132>>>
76132>>>            Object oSQLFilter is a Form
76134>>>                Set Size to 13 316
76135>>>                Set Location to 119 63
76136>>>                Set peAnchors to anBottomLeftRight
76137>>>                Procedure OnChange
76140>>>                    Handle hoDDO
76140>>>                    String sValue
76140>>>                    Get phoCurrentDD to hoDDO
76141>>>                    Get Value to sValue
76142>>>                    Set psSQLFilter of hoDDO to sValue
76143>>>                End_Procedure
76144>>>            End_Object
76145>>>            
76145>>>            Procedure ApplySQLFilterInfo
76148>>>                Integer iValue
76148>>>                Boolean bFilter bAllowed
76148>>>                Handle hoDDO
76148>>>                String sFilter
76148>>>                
76148>>>                Get phoCurrentDD to hoDDO
76149>>>                Get SupportsSQLFilters of hoDDO to bAllowed
76150>>>                Set Enabled_state of oSQLFilterCkBox to bAllowed
76151>>>                Get pbUseDDSQLFilters of hoDDO to bFilter
76152>>>                Get psSQLFilter of hoDDO to sFilter
76153>>>                Set Checked_State of oSQLFilterCkBox to bFilter
76154>>>                Set Enabled_state of oSQLFilter to bFilter
76155>>>                Set Value of oSQLFilter to sFilter
76156>>>            End_Procedure
76157>>>
76157>>>            Procedure RefreshAll
76160>>>                Send RefreshAll of oConstraintsEdit
76161>>>                Send ApplySQLFilterInfo
76162>>>            End_Procedure
76163>>>        End_Object
76164>>>        Object oTP_Field_Values is a TabPage
76166>>>            Set Label to "Field Values"
76167>>>            Set Tab_ToolTip_Value to "DD Field Values"
76168>>>            Object oFieldsEdit is a cDDDebugResults
76170>>>                delegate set phoFieldsEditId to self
76172>>>
76172>>>                Set Size to 127 375
76173>>>                Set Location to 4 4
76174>>>
76174>>>                Procedure RefreshAll
76177>>>                    Integer hDD hRB iMax iItem iFile
76177>>>                    Integer iOldErrorReport hOldErr
76177>>>                    String sLine sFieldName sChanged sVld sFrnVld sVal
76177>>>
76177>>>                    get phoCurrentDD to hDD
76178>>>                    get Record_Buffer of hDD to hRB
76179>>>                    Get main_file of hDD to iFile
76180>>>                    Set Dynamic_update_state to false
76181>>>                    Send Delete_Data
76182>>>
76182>>>                    Get Error_Report_Mode of hDD to iOldErrorReport
76183>>>                    Set Error_Report_Mode of hDD to DD_ERROR_NO_REPORT
76184>>>                    Move Error_Object_id to hOldErr
76185>>>                    Move hDD to Error_Object_id
76186>>>
76186>>>                    // Write the Header
76186>>>                    Send Insert "Field                           Chg Vld FrnVld Value"
76187>>>                    Send Insert CR_LF
76188>>>                    Send Insert "-----------------------------------------------------------------------------------------------------------"
76189>>>                    Send Insert CR_LF
76190>>>
76190>>>                    // Write the bodies for the fields
76190>>>                    Get Item_Count of hRB to iMax
76191>>>                    Decrement iMax
76192>>>                    For iItem From 0 to iMax
76198>>>>
76198>>>                        Get_Attribute DF_FIELD_NAME of iFile iItem to sFieldName
76201>>>                        Move (Pad(sFieldName,32)) to sFieldName
76202>>>                        Move (string(Item_Changed_State(hRB, iItem))) to sChanged
76203>>>                        // this will test it as a standard validation
76203>>>                        Move hDD to Operation_Origin
76204>>>                        Move (If(Validate_Field(hDD,iItem),"N","Y")) to sVld
76205>>>                        // this will test it as a foreign validation
76205>>>                        Move 0 to Operation_Origin
76206>>>                        Move (If(Validate_Field(hDD,iItem),"N","Y")) to sFrnVld
76207>>>                        //              Print (Item_Entry_MSG(hRB, iItem))
76207>>>                        //              Print (Item_Exit_MSG(hRB, iItem))
76207>>>                        //              Print (Item_Validate_MSG(hRB, iItem))
76207>>>                        Move (Field_Current_Value(hDD, iItem)) to sVal
76208>>>                        Move (sFormat("%1 %2   %3   %4     %5", sFieldName, sChanged, sVld, sFrnVld, sVal)) to sLine
76209>>>                        Send Insert sLine
76210>>>                        Send Insert CR_LF
76211>>>                    Loop
76212>>>>
76212>>>                    Send Insert CR_LF
76213>>>                    Send Insert "Existing_Key_Value = "
76214>>>                    Send Insert (Existing_Key_Value(hDD))
76215>>>                    Send Insert CR_LF
76216>>>
76216>>>                    Send Beginning_of_Data
76217>>>                    Set Dynamic_update_state to true
76218>>>                    Set Error_Report_Mode of hDD to iOldErrorReport
76219>>>                    Move hOldErr to Error_Object_id
76220>>>                End_procedure
76221>>>
76221>>>
76221>>>            End_Object    // oFieldsEdit
76222>>>
76222>>>        End_Object    // oTP_Field_Values
76223>>>        
76223>>>
76223>>>        Object oTP_Misc is a TabPage
76225>>>            Set Label to "Misc"
76226>>>            Set Tab_ToolTip_Value to "Other DD static values"
76227>>>            Object oMiscEdit is a cDDDebugResults
76229>>>                delegate set phoMiscEditId to self
76231>>>
76231>>>                Procedure RefreshAll
76234>>>                    Integer hDD hRB iMax iItem iFile iFIl iObj iOldSt
76234>>>                    Integer iCnt hVw iBase iType iFAObj iOldErrorReport hOldErr iMaster
76234>>>                    String sDummy sView sName sDummy2 sFieldName sType sLine
76234>>>                    Handle hoMaster
76234>>>
76234>>>                    Get phoInvokingView to hVw
76235>>>                    Get Name of hVw to sView
76236>>>
76236>>>                    get phoCurrentDD to hDD
76237>>>                    get Record_Buffer    of hDD to hRB
76238>>>                    get Field_Attributes of hDD to iFAObj
76239>>>                    Get main_file of hDD to iFile
76240>>>                    Set Dynamic_update_state to False
76241>>>                    Send Delete_Data
76242>>>
76242>>>                    Send Insert "Current DDO = "
76243>>>                    Send Insert (String(hDD) * "-" * Object_Label(hDD))
76244>>>                    Send Insert CR_LF
76245>>>                    
76245>>>                    Send Insert "Main File = "
76246>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of iFile to sName
76249>>>                    Send Insert (String(iFile) * "-" * sName)
76250>>>                    Send Insert CR_LF
76251>>>                    
76251>>>                    
76251>>>                    
76251>>>                    Send Insert "Driver File = "
76252>>>                    Get_Attribute DF_FILE_DRIVER of iFile to sName
76255>>>                    Send Insert sName
76256>>>                    Send Insert CR_LF
76257>>>                    Send Insert CR_LF
76258>>>
76258>>>                    // see if this has a master table (i.e., if this DDO is an alias)
76258>>>                    Get MasterForAlias of hDD to iMaster
76259>>>                    If (iMaster<>0) Begin
76261>>>                        Get Data_Set of hDD iMaster to hoMaster
76262>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iMaster to sName
76265>>>                        Send Insert "Alias Table Information"
76266>>>                        Send Insert CR_LF
76267>>>                        Send Insert ("    Master Table: " + String(iMaster) * "-" * sName)
76268>>>                        Send Insert CR_LF
76269>>>                        // it is possible the master is not in this DDO structure. If so
76269>>>                        // this will be treated as a regular table.
76269>>>                        If (hoMaster) Begin
76271>>>                            Send Insert "    Master DDO = "
76272>>>                            Send Insert (String(hoMaster) * "-" * Object_Label(hoMaster))
76273>>>                        End
76273>>>>
76273>>>                        Else Begin
76274>>>                            Send Insert "    ** The master table is not part of the DDO structure"
76275>>>                            Send Insert CR_LF
76276>>>                            Send Insert "       therefore this DDO will be locked as a regular non-alias table."
76277>>>                        End
76277>>>>
76277>>>                        Send Insert CR_LF
76278>>>                        Send Insert CR_LF
76279>>>                    End
76279>>>>
76279>>>                    
76279>>>                    
76279>>>
76279>>>                    Send Insert "Current DDO Container = "
76280>>>                    Send Insert (String(hVw) * "-" * Object_Label(hVw) * "(" - sView - ")")
76281>>>                    Send Insert CR_LF
76282>>>                    Send Insert CR_LF
76283>>>
76283>>>                    //Send Insert "Keys_Fields = "
76283>>>                    //Send Insert (Key_Fields(hDD))
76283>>>                    //Send Insert CR_LF
76283>>>
76283>>>                    Send Insert "Protect_Key_State = "
76284>>>                    Send Insert (If(Protect_Key_State(hDD),"True","False"))
76285>>>                    Send Insert CR_LF
76286>>>
76286>>>                    Send Insert "Cascade_Delete_State = "
76287>>>                    Send Insert (If(Cascade_Delete_State(hDD),"True","False"))
76288>>>                    Send Insert CR_LF
76289>>>                    Send Insert CR_LF
76290>>>
76290>>>                    Send Insert "Required Server Files = "
76291>>>                    Send Insert (Server_File_Count(hDD))
76292>>>                    Send Insert CR_LF
76293>>>                    For iCnt from 0 to (Server_File_Count(hDD)-1)
76299>>>>
76299>>>                        Get Server_File of hDD iCnt to iFil
76300>>>                        Send Insert ("     " +string(iFil)+" - ")
76301>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFil to sDummy
76304>>>                        Send Insert sDummy
76305>>>                        Send Insert CR_LF
76306>>>                    Loop
76307>>>>
76307>>>                    Send Insert  CR_LF
76308>>>
76308>>>                    Send Insert "Required Client Files = "
76309>>>                    Send Insert (Client_File_Count(hDD))
76310>>>                    Send Insert CR_LF
76311>>>                    For iCnt from 0 to (Client_File_Count(hDD)-1)
76317>>>>
76317>>>                        Get Client_File of hDD iCnt to iFil
76318>>>                        Send Insert ("     " +string(iFil)+" - ")
76319>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFil to sDummy
76322>>>                        Send Insert sDummy
76323>>>                        Send Insert CR_LF
76324>>>                    Loop
76325>>>>
76325>>>                    Send Insert  CR_LF
76326>>>
76326>>>                    Send Insert "Required Other Files = "
76327>>>                    Send Insert (System_File_Count(hDD))
76328>>>                    Send Insert CR_LF
76329>>>                    For iCnt from 0 to (System_File_Count(hDD)-1)
76335>>>>
76335>>>                        Get System_File_Number of hDD iCnt to iFil
76336>>>                        Send Insert ("     " +string(iFil)+" - ")
76337>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFil to sDummy
76340>>>                        Send Insert sDummy
76341>>>                        Get System_File_Lock_Mode of hDD iCnt to iFil
76342>>>                        Case Begin
76342>>>                            case (iFil=DD_Lock_on_All)             Move " - Lock on all" to sDummy
76345>>>                            case (iFil=DD_Lock_on_Delete)          Move " - Lock on Delete" to sDummy
76349>>>                            case (iFil=DD_Lock_on_new_Save_delete) Move " - Lock on new save/delete" to sDummy
76353>>>                            case (iFil=DD_Lock_on_Save)            Move " - Lock on save" to sDummy
76357>>>                            case (iFil=DD_Lock_on_new_Save)        Move " - Lock on new save" to sDummy
76361>>>                            case else                              Move " - No Lock" to sDummy
76363>>>                        case end
76363>>>                        Send Insert sDummy
76364>>>                        Send Insert CR_LF
76365>>>                    Loop
76366>>>>
76366>>>                    Send Insert  CR_LF
76367>>>
76367>>>                    Send Insert "Attached DDO Server DDO = "
76368>>>                    Send Insert (Data_set_server_Count(hDD))
76369>>>                    Send Insert CR_LF
76370>>>                    For iCnt from 0 to (Data_set_server_Count(hDD)-1)
76376>>>>
76376>>>                        Get Data_Set_Server of hDD iCnt to iObj
76377>>>                        Get Main_file of iObj to iFil
76378>>>                        Move (replace(sView+".",Name(iObj),"")) to sName
76379>>>                        Send Insert ("     " +string(iObj)+" - "+sname)
76380>>>                        Send Insert ("     " +string(iFil)+" - ")
76381>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFil to sDummy
76384>>>                        Send Insert sDummy
76385>>>                        Send Insert CR_LF
76386>>>                    Loop
76387>>>>
76387>>>                    Send Insert  CR_LF
76388>>>
76388>>>                    Send Insert "Attached DDO CLient DDOs = "
76389>>>                    Send Insert  (Data_set_Client_Count(hDD))
76390>>>                    Send Insert  CR_LF
76391>>>                    For iCnt from 0 to (Data_set_Client_Count(hDD)-1)
76397>>>>
76397>>>                        Get Data_Set_Client of hDD iCnt to iObj
76398>>>                        Get Main_file of iObj to iFil
76399>>>                        Move (replace(sView+".",Name(iObj),"")) to sName
76400>>>                        Send Insert ("     " +string(iObj)+" - "+sname)
76401>>>                        Send Insert ("     " +string(iFil)+" - ")
76402>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFil to sDummy
76405>>>                        Send Insert sDummy
76406>>>                        Send Insert CR_LF
76407>>>                    Loop
76408>>>>
76408>>>                    Send Insert CR_LF
76409>>>
76409>>>                    Send Insert  "Valid Save Structure = "
76410>>>                    Send Insert  (if(Validate_Save_Structure(hDD,1),"No","Yes"))
76411>>>                    Send Insert  CR_LF
76412>>>
76412>>>                    Get Cascade_delete_State of hDD to ioldst
76413>>>                    Set Cascade_delete_State of hDD to TRUE
76414>>>                    Send Insert  "Valid Cascade Delete Structure = "
76415>>>                    Send Insert  (if(Validate_Delete_Structure(hDD,1),"No","Yes"))
76416>>>                    Send Insert  CR_LF
76417>>>
76417>>>                    Set Cascade_delete_State of hDD to False
76418>>>                    Send Insert  "Valid No Cascade Delete Structure = "
76419>>>                    Send Insert  (if(Validate_Delete_Structure(hDD,1),"No","Yes"))
76420>>>                    Send Insert  CR_LF
76421>>>                    Set Cascade_delete_State of hDD to ioldst
76422>>>
76422>>>                    Send Insert  CR_LF
76423>>>                    Send Insert  "Attached DEOs = "
76424>>>                    Send Insert  (Data_set_user_Interface_Count(hDD))
76425>>>                    Send Insert  CR_LF
76426>>>                    For iCnt from 0 to (Data_set_User_Interface_Count(hDD)-1)
76432>>>>
76432>>>                        Get Data_Set_User_Interface of hDD iCnt to iObj
76433>>>                        Move (replace(sView+".",Object_Label(iObj),"")) to sName
76434>>>                        Send Insert ("     " +string(iObj)+" - "+sname)
76435>>>                        If Not (Extended_deo_State(iObj)) Send Insert  ("  (**Not XDEO)")
76438>>>                        else If (Data_File(iObj,0)<>iFile) Send Insert  ("    (foreign)")
76442>>>
76442>>>                        Send Insert  CR_LF
76443>>>                    Loop
76444>>>>
76444>>>                    Send Insert  CR_LF
76445>>>
76445>>>                    // Write the bodies for the fields
76445>>>                    // Write the Header
76445>>>                    Send Insert "              Extended Field Attributes"
76446>>>                    Send Insert CR_LF
76447>>>                    Send Insert "Field                            Type             Valid Values"
76448>>>                    Send Insert CR_LF
76449>>>                    Send Insert "-----------------------------------------------------------------------------------------------------------"
76450>>>                    Send Insert CR_LF
76451>>>
76451>>>                    Get Error_Report_Mode of hDD to iOldErrorReport
76452>>>                    Set Error_Report_Mode of hDD to DD_ERROR_NO_REPORT
76453>>>                    Move Error_Object_id to hOldErr
76454>>>                    Move hDD to Error_Object_id
76455>>>                    Get Item_Count of hRB to iMax
76456>>>                    Decrement iMax
76457>>>                    For iItem From 0 to iMax
76463>>>>
76463>>>                        Move (iItem * FA_COUNT) to iBase
76464>>>                        Get_Attribute DF_FIELD_NAME of iFile iItem to sFieldName
76467>>>                        Move (pad(sFieldName,32)) to sFieldName
76468>>>                        Get Field_Validation_Type of hDD iItem to iType
76469>>>                        Case Begin
76469>>>                            Case (iType=FA_VALIDATION_TYPE_RANGE)
76471>>>                                Move "Range" to sDummy
76472>>>                                Move ("Min="+Value(iFAObj,iBase+FA_MIN_VALUE) * ;                                    "Max="+Value(iFAObj,iBase+FA_MAX_VALUE)) ;                                        to sDummy2
76473>>>                                Case Break
76474>>>                            Case (iType=FA_VALIDATION_TYPE_CHECK)
76477>>>                                Move "Check" to sDummy
76478>>>                                Move ("Values =" * Value(iFAObj,iBase+FA_CHECK_VALUE)) to sDummy2
76479>>>                                Case Break
76480>>>                            Case (iType=FA_VALIDATION_TYPE_CHECKBOX)
76483>>>                                Move "CheckBox" to sDummy
76484>>>                                Move ("True="+ Value(iFAObj,iBase+FA_CHECKBOX_TRUE) * ;                                    "False="+ Value(iFAObj,iBase+FA_CHECKBOX_FALSE)) ;                                        to sDummy2
76485>>>                                Case Break
76486>>>                            Case (iType=FA_VALIDATION_TYPE_TABLE)
76489>>>                                Move "Table" to sDummy
76490>>>                                Move ("Id="+ Value(iFAObj,iBase+FA_TABLE_OBJECT) * ;                                      Name( Value(iFAObj,iBase+FA_TABLE_OBJECT) )) ;                                        to sDummy2
76491>>>                                Case Break
76492>>>                            Case Else
76492>>>                                Move "None" to sDummy
76493>>>                                Move "" to sDummy2
76494>>>                        Case end
76494>>>                        Move (Pad(sDummy,14)) to sDummy
76495>>>                        Move (SFormat("%1 %2 %3 %4", sFieldName, sType, sDummy, sDummy2)) to sLine
76496>>>                        Send Insert sLine
76497>>>                        Send Insert  CR_LF
76498>>>                    Loop
76499>>>>
76499>>>
76499>>>                    Send Beginning_Of_Data
76500>>>                    Set Dynamic_update_state to True
76501>>>                    Set Error_Report_Mode of hDD to iOldErrorReport
76502>>>                    Move hOldErr to Error_Object_id
76503>>>                end_procedure
76504>>>
76504>>>
76504>>>
76504>>>                Set Size to 127 375
76505>>>                Set Location to 4 4
76506>>>
76506>>>
76506>>>
76506>>>            End_Object    // oMiscEdit
76507>>>
76507>>>        End_Object    // oTP_Misc
76508>>>
76508>>>    End_Object    // oTD
76509>>>
76509>>>    Object oFindCounts is a Group
76511>>>        Set Size to 40 390
76512>>>        Set Location to 182 10
76513>>>        Set Label to "Constraint Find Counts"
76514>>>        Set peAnchors to anBottomLeft
76515>>>        Object oTestsCount is a Form
76517>>>
76517>>>            Set enabled_state to false
76518>>>
76518>>>            Set Label to "Tests_Count"
76519>>>            Set Size to 13 37
76520>>>            Set Location to 10 47
76521>>>            Set Label_Col_Offset to 2
76522>>>            Set Label_Justification_Mode to jMode_Right
76523>>>
76523>>>            Set Numeric_mask 0 to 8 0
76524>>>
76524>>>        End_Object    // oTestsCount
76525>>>
76525>>>        Object oFoundCount is a Form
76527>>>
76527>>>            Set enabled_state to false
76528>>>
76528>>>            Set Label to "Found_Count"
76529>>>            Set Size to 13 37
76530>>>            Set Location to 10 137
76531>>>            Set Label_Col_Offset to 2
76532>>>            Set Label_Justification_Mode to jMode_Right
76533>>>
76533>>>            Set Numeric_mask 0 to 8 0
76534>>>
76534>>>        End_Object    // oFoundCount
76535>>>
76535>>>        Object oDifference is a Form
76537>>>
76537>>>            Set enabled_state to false
76538>>>
76538>>>            Set Label to "Difference"
76539>>>            Set Size to 13 37
76540>>>            Set Location to 10 213
76541>>>            Set Label_Col_Offset to 2
76542>>>            Set Label_Justification_Mode to jMode_Right
76543>>>
76543>>>            Set Numeric_mask 0 to 8 0
76544>>>
76544>>>        End_Object    // oDifference
76545>>>
76545>>>        Object oClearCounts is a Button
76547>>>
76547>>>
76547>>>
76547>>>            Set Label to "Clear Count"
76548>>>            Set Size to 13 50
76549>>>            Set Location to 10 260
76550>>>
76550>>>            Procedure OnClick
76553>>>                Send ClearCounts
76554>>>            End_procedure
76555>>>
76555>>>
76555>>>        End_Object    // oClearCounts
76556>>>
76556>>>        Object oNonOptimalWarnings is a CheckBox
76558>>>            Set Label to "Report errors if more than"
76559>>>            Set Size to 10 93
76560>>>            Set Location to 24 6
76561>>>
76561>>>            Procedure OnChange
76564>>>                Delegate Send SetNonOptimalWarnings
76566>>>            End_Procedure // OnChange
76567>>>
76567>>>        End_Object    // oNonOptimalWarnings
76568>>>
76568>>>        Object oNonOptFinds is a Form
76570>>>
76570>>>            Set Numeric_mask 0 to 6 0
76571>>>
76571>>>            Set Size to 13 25
76572>>>            Set Location to 24 104
76573>>>
76573>>>
76573>>>            Set Value 0 to 50
76574>>>
76574>>>            Procedure OnChange
76577>>>                Delegate Send SetNonOptimalWarnings
76579>>>            End_Procedure // OnChange
76580>>>
76580>>>        End_Object    // oNonOptFinds
76581>>>
76581>>>        Object oNonOptTb is a Textbox
76583>>>            Set Label to "records are filtered."
76584>>>            Set Location to 25 132
76585>>>            Set Size to 10 61
76586>>>        End_Object    // oNonOptTb
76587>>>
76587>>>
76587>>>        Procedure ClearCounts
76590>>>            Move 0 to Constrain_tests_count
76591>>>            Move 0 to Constrain_found_Count
76592>>>            Send RefreshCounts
76593>>>        End_procedure
76594>>>
76594>>>        procedure RefreshCounts
76597>>>            Set Value of oTestsCount to constrain_tests_count
76598>>>            Set Value of oFoundCount to constrain_Found_count
76599>>>            Set Value of oDifference to (constrain_tests_count - Constrain_found_count)
76600>>>        end_procedure
76601>>>
76601>>>
76601>>>    End_Object    // oFindCounts
76602>>>
76602>>>    Object oFindGp is a Group
76604>>>
76604>>>
76604>>>
76604>>>        Set Size to 30 185
76605>>>        Set Location to 225 10
76606>>>        Set Label to "Find Record"
76607>>>        Set peAnchors to anBottomLeft
76608>>>        Object oFindBgn is a Button
76610>>>            Set Size to 14 18
76611>>>            Set Location to 10 9
76612>>>            Set peImageAlign to Button_ImageList_Align_Center
76613>>>            Set psImage to "bgn.bmp"
76614>>>
76614>>>            Procedure OnClick
76617>>>                Delegate Send FindRec FIRST_RECORD
76619>>>            End_procedure
76620>>>
76620>>>
76620>>>        End_Object    // oFindBgn
76621>>>
76621>>>        Object oFindPrev is a Button
76623>>>            Set Size to 14 18
76624>>>            Set Location to 10 31
76625>>>            Set peImageAlign to Button_ImageList_Align_Center
76626>>>            Set psImage to "Prev.bmp"
76627>>>
76627>>>            Procedure OnClick
76630>>>                Delegate Send FindRec LT
76632>>>            End_procedure
76633>>>
76633>>>
76633>>>        End_Object    // oFindPrev
76634>>>
76634>>>        Object oFindNext is a Button
76636>>>
76636>>>            Set Size to 14 18
76637>>>            Set Location to 10 53
76638>>>            Set peImageAlign to Button_ImageList_Align_Center
76639>>>            Set psImage to "next.bmp"
76640>>>
76640>>>            Procedure OnClick
76643>>>                Delegate Send FindRec Gt
76645>>>            End_procedure
76646>>>
76646>>>
76646>>>        End_Object    // oFindNext
76647>>>
76647>>>        Object oFindEnd is a Button
76649>>>
76649>>>            Set Size to 14 18
76650>>>            Set Location to 10 75
76651>>>            Set peImageAlign to Button_ImageList_Align_Center
76652>>>            Set psImage to "end.bmp"
76653>>>
76653>>>            Procedure OnClick
76656>>>                Delegate Send FindRec LAST_RECORD
76658>>>            End_procedure
76659>>>
76659>>>
76659>>>        End_Object    // oFindEnd
76660>>>
76660>>>        Object oFindIndex is a ComboForm
76662>>>
76662>>>
76662>>>
76662>>>            Set Size to 13 85
76663>>>            Set Location to 11 97
76664>>>            Set Form_Border to 0
76665>>>            Set Label_Col_Offset to 2
76666>>>            Set Label_Justification_Mode to jMode_Right
76667>>>
76667>>>            Procedure Fill_list
76670>>>                Integer hDD iFile iSegs iNdxs i
76670>>>                Send Combo_Delete_Data
76671>>>                Get phoCurrentDD to hDD
76672>>>                If hDD Begin
76674>>>                    Send Combo_Add_Item "Index.0"
76675>>>                    Get Main_file of hDD to iFile
76676>>>                    Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iFile to iNdxs
76679>>>                    For i from 1 to iNdxs
76685>>>>
76685>>>                        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile i to iSegs
76688>>>                        If iSegs Send Combo_Add_Item ("Index."-string(i))
76691>>>                    Loop
76692>>>>
76692>>>                End
76692>>>>
76692>>>                Set Value 0 to (combo_value(self,0))
76693>>>            End_procedure
76694>>>
76694>>>            Function Ordering returns integer
76697>>>                String sVal
76697>>>                Get Value 0 to sVal
76698>>>                Function_return (integer(mid(sVal, 10, pos(".",sVal)+1)))
76699>>>            end_function
76700>>>
76700>>>        End_Object    // oFindIndex
76701>>>
76701>>>
76701>>>        Procedure FindRec integer iMode
76704>>>            Integer hDD iNdx
76704>>>            Get Ordering of oFindIndex to iNdx
76705>>>            Get phoCurrentDD to hDD
76706>>>            If hDD Begin
76708>>>                Send Find of hDD iMode iNdx
76709>>>                Send RefreshAll
76710>>>            End
76710>>>>
76710>>>        End_procedure
76711>>>
76711>>>         Procedure RefreshNewDD
76714>>>             Send Fill_List of oFindIndex
76715>>>         End_procedure
76716>>>
76716>>>    End_Object    // oFindGp
76717>>>
76717>>>    Object oCheckRentrancy is a CheckBox
76719>>>        Set Label to "Report DD Rentrancy Errors"
76720>>>        Set Size to 10 105
76721>>>        Set Location to 224 294
76722>>>        Set peAnchors to anBottomLeft
76723>>>
76723>>>        Procedure OnChange
76726>>>            Get Checked_State To gbTestRentrancy
76727>>>        End_Procedure // OnChange
76728>>>
76728>>>    End_Object    // oCheckRentrancy
76729>>>
76729>>>    Object oClearAll_bn is a Button
76731>>>
76731>>>
76731>>>
76731>>>        Set Label to "Clear& All"
76732>>>        Set Location to 241 242
76733>>>        Set peAnchors to anBottomLeft
76734>>>
76734>>>        Procedure OnClick
76737>>>            Integer hDD
76737>>>            get phoCurrentDD to hDD
76738>>>            if hDD Send clear_all to hdd
76741>>>            Send RefreshALL
76742>>>        end_procedure
76743>>>
76743>>>    End_Object    // oClearAll_bn
76744>>>
76744>>>    Object oClear_bn is a Button
76746>>>
76746>>>
76746>>>
76746>>>        Set Label to "&Clear"
76747>>>        Set Location to 241 295
76748>>>        Set peAnchors to anBottomLeft
76749>>>
76749>>>        Procedure OnClick
76752>>>            Integer hDD
76752>>>            get phoCurrentDD to hDD
76753>>>            if hDD Send clear to hdd
76756>>>            Send RefreshALL
76757>>>        end_procedure
76758>>>
76758>>>
76758>>>    End_Object    // oClear_bn
76759>>>
76759>>>    Object oClose_bn is a Button
76761>>>
76761>>>
76761>>>
76761>>>        Set Label to "&Close"
76762>>>        Set Location to 241 350
76763>>>        Set peAnchors to anBottomLeft
76764>>>
76764>>>        Procedure OnClick
76767>>>            Send Close_Panel
76768>>>        end_procedure
76769>>>
76769>>>
76769>>>    End_Object    // oClose_bn
76770>>>
76770>>>    Procedure RefreshAll
76773>>>        Integer hDD
76773>>>        Boolean bIsRecnumTable
76773>>>        get phoCurrentDD to hDD
76774>>>        Get IsRecnumTable (main_file(hDD)) to bIsRecnumTable
76775>>>        Set Value          of oCurRec 0 to (If(bIsRecnumTable, current_record(hDD), 0))
76776>>>        Set checked_state  of oChangedState to (Changed_State(hDD))
76777>>>        set checked_state  of oShouldSave   to (Should_save(hDD))
76778>>>        Send RefreshAll    of (phoFieldsEditId(self))
76779>>>        Send RefreshCounts of oFindCounts
76780>>>    End_procedure
76781>>>
76781>>>    Procedure SetNonOptimalWarnings
76784>>>        Integer iValue
76784>>>        Boolean bChecked
76784>>>        Get Checked_State of oNonOptimalWarnings to bChecked
76785>>>        Get Value of oNonOptFinds to iValue
76786>>>        Move (if(bChecked,iValue,0)) to giNonOptimalFindCount
76787>>>        Set Enabled_state of oNonOptFinds to bChecked
76788>>>    End_procedure
76789>>>
76789>>>    Procedure RefreshNewDD
76792>>>        Integer hDD
76792>>>        get phoCurrentDD to hDD
76793>>>        Send Fill_list of oDDRelatesTo
76794>>>        set checked_state of oAutoFill to (Auto_Fill_State(hDD)<>0)
76795>>>        set checked_state of oInherit  to (pbInheritConstraints(hDD))
76796>>>        set checked_state of oFillFromTop to (pbAutoFillFromFirst(hDD))
76797>>>        Send RefreshAll   to (phoMiscEditId(self))
76798>>>        Send RefreshAll   to (phoConstraintsEditId(Self))
76799>>>        Send RefreshAll
76800>>>
76800>>>        Send RefreshNewDD of oDDOrdering
76801>>>        Send RefreshNewDD of oFindGP
76802>>>        Set  Ordering     of oDDOrdering to (ordering(hDD))
76803>>>    End_procedure
76804>>>
76804>>>
76804>>>    Procedure refresh
76807>>>        Send Fill_list of oDDCombo
76808>>>        Send SetNonOptimalWarnings
76809>>>        set checked_state of oCheckRentrancy to gbTestRentrancy
76810>>>    end_procedure
76811>>>
76811>>>    Procedure ShowDDs Integer hoDD
76814>>>        Integer hoVw
76814>>>        Get parent of hoDD  to hoVw
76815>>>        Set phoCurrentDD    to hoDD
76816>>>        Set phoInvokingView to hoVw
76817>>>        Send Refresh
76818>>>        Send Popup
76819>>>    End_Procedure
76820>>>
76820>>>
76820>>>
76820>>>End_Object    // oDD_Debug
76821>>>
76821>>>
76821>>>
76821>>>Procedure DebugDDs FOR cObject
76823>>>   Integer hDD
76823>>>   get Server to hDD
76824>>>   if hDD Send ShowDDs of oDD_Debug hDD
76827>>>End_Procedure
76828>>>
76828>>>On_key key_Ctrl+Key_D Send DebugDDs
76829>>>
76829>
76829>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Program Files (x86)\DataFlex 18.1\Pkg\StdAbout.pkg)
76829>>>//************************************************************************
76829>>>// Confidential Trade Secret.
76829>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
76829>>>// as an unpublished work.  All rights reserved.
76829>>>// DataFlex is a registered trademark of Data Access Corporation.
76829>>>//
76829>>>//************************************************************************
76829>>>//************************************************************************
76829>>>//
76829>>>// $File name  : StdAbout.pkg
76829>>>// $File title : Standard about object package for VDF
76829>>>// Notice      :
76829>>>// $Author(s)  : John Tuohy
76829>>>//
76829>>>// $Rev History
76829>>>//
76829>>>// JT 06/27/97   File created
76829>>>//************************************************************************
76829>>>
76829>>>// This provides a quick and simple way to create an about package for a program.
76829>>>// You need to create a message inside you client area called Activate_About.
76829>>>// Within this message you should send the message DoAbout passing needed
76829>>>// string information.
76829>>>//
76829>>>//       Procedure Activate_About
76829>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
76829>>>//       End_Procedure
76829>>>//    where: sTitle =     Name of application. If none provided, uses caption
76829>>>//                        bar title
76829>>>//           sVersion   = Version Line. If none provided, will be blank
76829>>>//           sCopyRight = Copyright Line. If none provided, will be blank
76829>>>//           sAuthor    = Author name, blank if none provided
76829>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
76829>>>//                        is used.
76829>>>// It is expected that you will place this in your own object package. For
76829>>>// example an order about package may look like this:
76829>>>//
76829>>>//   // OrderAbout.pkg
76829>>>//   Use StdAbout.pkg
76829>>>//   Procedure Activate_About
76829>>>//      String sTitle sCopyright sVersion sAuthor
76829>>>//      Move "My Order Entry System" to sTitle
76829>>>//      Move "Version 2.1" to sVersion
76829>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
76829>>>//      Move "John Smith"  to sAuthor
76829>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
76829>>>//   end_procedure
76829>>>//   // end of file.
76829>>>
76829>>>Use DfAbout.pkg
Including file: Dfabout.pkg    (C:\Program Files (x86)\DataFlex 18.1\Pkg\Dfabout.pkg)
76829>>>>>//************************************************************************
76829>>>>>// Confidential Trade Secret.
76829>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
76829>>>>>// as an unpublished work.  All rights reserved.
76829>>>>>// DataFlex Is A registered trademark Of Data Access Corporation.
76829>>>>>//
76829>>>>>//************************************************************************
76829>>>>>//************************************************************************
76829>>>>>//
76829>>>>>// $File name  : DfAbout.pkg
76829>>>>>// $File title : About class support
76829>>>>>// Notice      :
76829>>>>>// $Author(s)  : Vincent Oorsprong, Ken Ross
76829>>>>>//
76829>>>>>// $Rev History
76829>>>>>//
76829>>>>>// VOO 02/22/2012 Replaced obsolete code, improved Network_User_Name by asking
76829>>>>>//                Windows for the size first. 
76829>>>>>// VOO 07/25/2003 Removed OnResize procedure for sysinfo dialog. Replaced logic
76829>>>>>//                with anchor technique. Removed unnessary property in the
76829>>>>>//                sysinfo dialog. Changed the size Of the about & sysinfo dialog
76829>>>>>//                object To better look in Windows XP. Repositioned the close
76829>>>>>//                button in the sysinfo dialog To line up with the display area
76829>>>>>//                Replaced obsolete code and techniques. Removed dead code.
76829>>>>>// JJT 10/23/2001 removed all ghoworkspace support. Uses app object or nothing
76829>>>>>// SWB 07/19/01   Added support Of the Application object in preference to
76829>>>>>//                the global Workspace object, if it is present
76829>>>>>// JJT 11/05/98   Added version information
76829>>>>>// VOO 29/10/98   Replaced the GetFreeSystemResources for the Win32 variant
76829>>>>>// JJT 7/31/97    Registered Enumerate Workspace so dfabout can exist without
76829>>>>>//                workspace package.
76829>>>>>// JJT 6/27/97    Turned the sysinfo objects into classes so the AboutDialog
76829>>>>>//                class can create this object.
76829>>>>>//                Cleaned up the interface (used correct classes and messages)
76829>>>>>//                Added workspace reporting support To sys-info.
76829>>>>>//                Turned off wrapping in the sys-info editor.
76829>>>>>// KR  ??/??/96   File created
76829>>>>>//************************************************************************
76829>>>>>Use LanguageText.pkg
76829>>>>>Use Windows.pkg
76829>>>>>Use DFbitmap.pkg
76829>>>>>Use GlobalFunctionsProcedures.pkg
76829>>>>>Use cTextEdit.pkg
76829>>>>>
76829>>>>>Use cli.pkg
Including file: cli.pkg    (C:\Program Files (x86)\DataFlex 18.1\Pkg\cli.pkg)
76829>>>>>>>//*****************************************************************************
76829>>>>>>>//*** CLI.PKG                                                               ***
76829>>>>>>>//***                                                                       ***
76829>>>>>>>//*** Author: Ben Weijers                                                   ***
76829>>>>>>>//***         Data Access Nederland                                         ***
76829>>>>>>>//***         10 September 1998                                             ***
76829>>>>>>>//***                                                                       ***
76829>>>>>>>//*** Purpose:                                                              ***
76829>>>>>>>//***   CLI specific functionality. There are several connectivity kits     ***
76829>>>>>>>//***   based on  SQL/92 CLI. Those are:                                    ***
76829>>>>>>>//***    - ODBC_DRV  The Data Access CK for ODBC                            ***
76829>>>>>>>//***    - DB2_DRV   The Data Access CK for DB2                             ***
76829>>>>>>>//***    - MSSQLDRV  The Data Access CK for Microsoft SQL Server            ***
76829>>>>>>>//***                                                                       ***
76829>>>>>>>//***   This package defines the common functionality for all CLI based     ***
76829>>>>>>>//***   drivers.                                                            ***
76829>>>>>>>//***                                                                       ***
76829>>>>>>>//***   Updated:  May 23rd 2008 (Current CK build: 5.0.0.53 )               ***
76829>>>>>>>//***             Added NULLABLE and DEFAULT attributes for DATETIME type   ***
76829>>>>>>>//***   Updated:  Apr  6th 2009 (Current CK build: 5.0.0.61 )               ***
76829>>>>>>>//***             Added DF_DRIVER_MATCH_CLIENT_SERVER_VERSION attribute     ***
76829>>>>>>>//***                   DF_DRIVER_SQLSERVER_CLIENT_VERSION    attribute     ***
76829>>>>>>>//***   Updated:  Mar 30th 2012 (Current CK build: 5.1.0.93 )               ***
76829>>>>>>>//***             Added SQLSERVER2012CLIENT return value for                ***
76829>>>>>>>//***             DF_DRIVER_SQLSERVER_CLIENT_VERSION attribute              ***
76829>>>>>>>//***   Updated:  June 4th 2012 (Current CK build: 5.1.0.96)                ***
76829>>>>>>>//***             Moved SQL Server client constants from cli.pkg to         ***
76829>>>>>>>//***             mssqldrv.pkg                                              ***
76829>>>>>>>//***   Updated:  april 23, 2013 (Current CK build: 6.0.0.4)                ***
76829>>>>>>>//***             Added type mappings attributes                            ***
76829>>>>>>>//***   Updated:  october 11, 2013 (Current CK build: 6.0.0.18)             ***
76829>>>>>>>//***             Added DF_FILE_SQL_FILTER_EQ attribute                     ***
76829>>>>>>>//*****************************************************************************
76829>>>>>>>
76829>>>>>>>//*** We are not using ifndef below because that is not supported in Character Mode
76829>>>>>>>//*** Driver attributes
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>//------------------------------------------------------------
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>//-------------------------------------
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>//*** Replacement for logical column number that indicates all columns
76829>>>>>>>
76829>>>>>>>//*** Possible DF_FILE_GENERATE_RECORD_ID_METHOD values
76829>>>>>>>
76829>>>>>>>//*** Possible DF_FIELD_READ_ONLY values
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>//*** Possible DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA values
76829>>>>>>>// #Replace MAP_DF_TO_SQL_TYPE_CK5        1       
76829>>>>>>>// #Replace MAP_DF_TO_SQL_TYPE_CK6        2   
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>// Moved to Mssqldrv.pkg
76829>>>>>>>//*** Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
76829>>>>>>>//#REPLACE SQLSERVERUNKNOWNCLIENT  0
76829>>>>>>>//#REPLACE SQLSERVER2000CLIENT     8          //   "SQL Server"
76829>>>>>>>//#REPLACE SQLSERVER2005CLIENT     9          //   "SQL Native Client"
76829>>>>>>>//#REPLACE SQLSERVER2008CLIENT    10          //   "SQL Server Native Client 10.0"
76829>>>>>>>//#Replace SQLSERVER2012CLIENT    11          //   "SQL Server Native Client 11.0"
76829>>>>>>>
76829>>>>>>>//*** Possible SQL Column type values
76829>>>>>>>Define SQL_UNKNOWN_TYPE   For    0
76829>>>>>>>Define SQL_CHAR           For    1
76829>>>>>>>Define SQL_NUMERIC        For    2
76829>>>>>>>Define SQL_DECIMAL        For    3
76829>>>>>>>Define SQL_INTEGER        For    4
76829>>>>>>>Define SQL_SMALLINT       For    5
76829>>>>>>>Define SQL_FLOAT          For    6
76829>>>>>>>Define SQL_REAL           For    7
76829>>>>>>>Define SQL_DOUBLE         For    8
76829>>>>>>>Define SQL_DATETIME       For    9
76829>>>>>>>Define SQL_VARCHAR        For   12
76829>>>>>>>Define SQL_TYPE_DATE      For   91
76829>>>>>>>Define SQL_TYPE_TIME      For   92
76829>>>>>>>Define SQL_TYPE_TIMESTAMP for   93
76829>>>>>>>// Moved to mssqldrv.pkg
76829>>>>>>>//Define SQL_TYPE_TIMESTAMP2 for   (-200) //SQL server datetime2 type */
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>Define SQL_DATE           For    9
76829>>>>>>>Define SQL_INTERVAL       For   10
76829>>>>>>>Define SQL_TIME           For   10
76829>>>>>>>Define SQL_TIMESTAMP      For   11
76829>>>>>>>Define SQL_LONGVARCHAR    For  (-1)
76829>>>>>>>Define SQL_BINARY         For  (-2)
76829>>>>>>>Define SQL_VARBINARY      For  (-3)
76829>>>>>>>Define SQL_LONGVARBINARY  For  (-4)
76829>>>>>>>Define SQL_BIGINT         For  (-5)
76829>>>>>>>Define SQL_TINYINT        For  (-6)
76829>>>>>>>Define SQL_BIT            For  (-7)
76829>>>>>>>Define SQL_WCHAR          For  (-8)
76829>>>>>>>Define SQL_WVARCHAR       For  (-9)
76829>>>>>>>Define SQL_WLONGVARCHAR   For (-10)
76829>>>>>>>Define SQL_GUID           For (-11)
76829>>>>>>>
76829>>>>>>>//*** Driver level attributes
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>//*** Error number constants
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>//*** Call driver function identifiers
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>//*** Init data source types
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>//*** Dummy strings used in the commands
76829>>>>>>>    String  CLI$StrDummy 255
76829>>>>>>>    Integer CLI$IntDummy
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>//*****************************************************************************
76829>>>>>>>//*** CLI_SetConstraint <FileNum> <NewState>                                ***
76829>>>>>>>//***                                                                       ***
76829>>>>>>>//***   Setup a constraint for a file.                                      ***
76829>>>>>>>//*****************************************************************************
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>//*****************************************************************************
76829>>>>>>>//*** CLI_Set_Driver_Atrtribute / CLI_Get_Driver_Attribute                  ***
76829>>>>>>>//***                                                                       ***
76829>>>>>>>//*** Set or get an attribute at driver level. These attributes, when set,  ***
76829>>>>>>>//*** will be set for the remainder of the session or until set again. To   ***
76829>>>>>>>//*** permanently set driver level attributes change the driver             ***
76829>>>>>>>//*** configuration file.                                                   ***
76829>>>>>>>//*****************************************************************************
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>
76829>>>>>>>//*****************************************************************************
76829>>>>>>>//*** Class  : cCLIHandler                                                  ***
76829>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
76829>>>>>>>//***          call several CLI releated methods.                           ***
76829>>>>>>>//*****************************************************************************
76829>>>>>>>
76829>>>>>>>Class cCLIHandler Is An Array
76830>>>>>>>
76830>>>>>>>    Procedure Construct_Object Integer iImage
76832>>>>>>>        Forward Send Construct_object iImage
76834>>>>>>>
76834>>>>>>>        Property String  psDriverID       Public ""
76835>>>>>>>    End_Procedure // Construct_Object
76836>>>>>>>
76836>>>>>>>
76836>>>>>>>
76836>>>>>>>    //***
76836>>>>>>>    //*** Fucntion: CKRevsion
76836>>>>>>>    //*** Purpose : The revsion of a CLI Connectivity Kit
76836>>>>>>>    //***
76836>>>>>>>
76836>>>>>>>    Function CKRevision Returns String
76838>>>>>>>        Local String  sDriverID
76838>>>>>>>        Local String  sRevision
76838>>>>>>>        Local String  sVoid
76838>>>>>>>        Local Integer iRetval
76838>>>>>>>
76838>>>>>>>        Get psDriverID To sDriverID
76839>>>>>>>        If (sDRiverID <> "") Begin
76841>>>>>>>            Move (Repeat(" ", 255)) To sRevision
76842>>>>>>>            Call_Driver 0 sDRiverID Function CLI_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
76847>>>>>>>        End
76847>>>>>>>>
76847>>>>>>>
76847>>>>>>>        Function_Return sRevision
76848>>>>>>>    End_Function // CKRevision
76849>>>>>>>
76849>>>>>>>
76849>>>>>>>
76849>>>>>>>    //***
76849>>>>>>>    //*** Function: ExtractPartFromRevision
76849>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
76849>>>>>>>    //***
76849>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
76849>>>>>>>    //***
76849>>>>>>>
76849>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
76851>>>>>>>        Local Integer iPartRev
76851>>>>>>>        Local Integer iCurrentPart
76851>>>>>>>        Local Integer iSeparatorPos
76851>>>>>>>
76851>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
76854>>>>>>>
76854>>>>>>>        Move 0 To iCurrentPart
76855>>>>>>>        Repeat
76855>>>>>>>>
76855>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
76856>>>>>>>            If (iSeparatorPos > 0) Begin
76858>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
76859>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
76860>>>>>>>                Increment iCurrentPart
76861>>>>>>>            End
76861>>>>>>>>
76861>>>>>>>            Else If (sRevision <> "") Begin
76864>>>>>>>                Move sRevision To iPartRev
76865>>>>>>>                Move "" To sRevision
76866>>>>>>>                Increment iCurrentPart
76867>>>>>>>            End
76867>>>>>>>>
76867>>>>>>>            Else ;                Move -1 To iPartRev
76869>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
76871>>>>>>>
76871>>>>>>>        Function_Return iPartRev
76872>>>>>>>    End_Function // EcxtractPartFromRevision
76873>>>>>>>
76873>>>>>>>
76873>>>>>>>
76873>>>>>>>    //***
76873>>>>>>>    //*** Function: CKMajorRevision
76873>>>>>>>    //*** Purpose : Returns the major revision of the CK
76873>>>>>>>    //***
76873>>>>>>>
76873>>>>>>>    Function CKMajorRevision Returns Integer
76875>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
76876>>>>>>>    End_Function // CKMajorRevision
76877>>>>>>>
76877>>>>>>>
76877>>>>>>>
76877>>>>>>>    //***
76877>>>>>>>    //*** Function: CKMinorRevision
76877>>>>>>>    //*** Purpose : Returns the minor revision of the CK
76877>>>>>>>    //***
76877>>>>>>>
76877>>>>>>>    Function CKMinorRevision Returns Integer
76879>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
76880>>>>>>>    End_Function // CKMinorRevision
76881>>>>>>>
76881>>>>>>>
76881>>>>>>>
76881>>>>>>>    //***
76881>>>>>>>    //*** Function: CKReleaseRevision
76881>>>>>>>    //*** Purpose : Returns the release revision of the CK
76881>>>>>>>    //***
76881>>>>>>>
76881>>>>>>>    Function CKReleaseRevision Returns Integer
76883>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
76884>>>>>>>    End_Function // CKReleaseRevision
76885>>>>>>>
76885>>>>>>>
76885>>>>>>>
76885>>>>>>>    //***
76885>>>>>>>    //*** Function: CKBuildRevision
76885>>>>>>>    //*** Purpose : Returns the major revision of the CK
76885>>>>>>>    //***
76885>>>>>>>
76885>>>>>>>    Function CKBuildRevision Returns Integer
76887>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
76888>>>>>>>    End_Function // CKBuildRevision
76889>>>>>>>
76889>>>>>>>
76889>>>>>>>
76889>>>>>>>    //***
76889>>>>>>>    //*** Function: IsMinimalRevision
76889>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
76889>>>>>>>    //***
76889>>>>>>>
76889>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
76891>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
76894>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
76897>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
76900>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
76903>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
76906>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
76910>>>>>>>            End
76910>>>>>>>>
76910>>>>>>>        End
76910>>>>>>>>
76910>>>>>>>
76910>>>>>>>        Function_Return (FALSE)
76911>>>>>>>    End_Function // IsMinimalRevision
76912>>>>>>>
76912>>>>>>>
76912>>>>>>>
76912>>>>>>>    //***
76912>>>>>>>    //*** Function: RegistrationName
76912>>>>>>>    //*** Purpose : Returns the Connectiivty Kit registration name.
76912>>>>>>>    //***
76912>>>>>>>
76912>>>>>>>    Function RegistrationName Returns String
76914>>>>>>>        Local String  sRegistration
76914>>>>>>>        Local String  sDRiverId
76914>>>>>>>        Local String  sVoid
76914>>>>>>>        Local Integer iRetval
76914>>>>>>>
76914>>>>>>>        Get psDriverID To sDriverID
76915>>>>>>>        If (sDRiverID <> "") Begin
76917>>>>>>>            Move (Repeat(" ", 255)) To sRegistration
76918>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETREGNAME Callback 0 Passing sRegistration sVoid 0 Result iRetval
76923>>>>>>>        End
76923>>>>>>>>
76923>>>>>>>
76923>>>>>>>        Function_Return sRegistration
76924>>>>>>>    End_Function // RegistrationName
76925>>>>>>>
76925>>>>>>>
76925>>>>>>>
76925>>>>>>>    //***
76925>>>>>>>    //*** Function: SerialNumber
76925>>>>>>>    //*** Purpose : Returns the Connectiivty Kit serial number.
76925>>>>>>>    //***
76925>>>>>>>
76925>>>>>>>    Function SerialNumber Returns Integer
76927>>>>>>>        Local String  sDRiverId
76927>>>>>>>        Local String  sVoid
76927>>>>>>>        Local Integer iRetval
76927>>>>>>>
76927>>>>>>>        Get psDriverID To sDriverID
76928>>>>>>>        If (sDRiverID <> "") Begin
76930>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETSERIALNUM Callback 0 Passing sVoid sVoid 0 Result iRetval
76935>>>>>>>        End
76935>>>>>>>>
76935>>>>>>>
76935>>>>>>>        Function_Return iRetval
76936>>>>>>>    End_Function // SerialNumber
76937>>>>>>>
76937>>>>>>>
76937>>>>>>>
76937>>>>>>>    //***
76937>>>>>>>    //*** Function: MaxUsers
76937>>>>>>>    //*** Purpose : Returns the Connectiivty Kit maximum number of users.
76937>>>>>>>    //***
76937>>>>>>>
76937>>>>>>>    Function MaxUsers Returns Integer
76939>>>>>>>        Local String  sDRiverId
76939>>>>>>>        Local String  sVoid
76939>>>>>>>        Local Integer iRetval
76939>>>>>>>
76939>>>>>>>        Get psDriverID To sDriverID
76940>>>>>>>        If (sDRiverID <> "") Begin
76942>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETMAXUSERS Callback 0 Passing sVoid sVoid 0 Result iRetval
76947>>>>>>>        End
76947>>>>>>>>
76947>>>>>>>
76947>>>>>>>        Function_Return iRetval
76948>>>>>>>    End_Function // MaxUsers
76949>>>>>>>
76949>>>>>>>
76949>>>>>>>
76949>>>>>>>    //***
76949>>>>>>>    //*** Procedure: DumpStatus
76949>>>>>>>    //*** Purpose  : Dump the current status of the drver in the passed disk file.
76949>>>>>>>    //***
76949>>>>>>>
76949>>>>>>>    Procedure DumpStatus String sFileName
76951>>>>>>>        Local String  sVoid
76951>>>>>>>        Local String  sDriverID
76951>>>>>>>        Local Integer iVoid
76951>>>>>>>
76951>>>>>>>        Get psDriverID To sDriverID
76952>>>>>>>        If (sDriverID <> "") ;            Call_driver 0 sDriverID Function CLI_DUMPSTATUS Callback 0 Passing sFileName sVoid iVoid Result iVoid
76959>>>>>>>    End_Procedure // DumpStatus
76960>>>>>>>
76960>>>>>>>
76960>>>>>>>
76960>>>>>>>    //***
76960>>>>>>>    //*** Procedure: ReadConfiguration
76960>>>>>>>    //*** Purpose  : Reset all driver level configurable attributes to the
76960>>>>>>>    //***            default value and then reread the configuration.
76960>>>>>>>    //***
76960>>>>>>>
76960>>>>>>>    Procedure ReadConfiguration
76962>>>>>>>        Local String  sVoid
76962>>>>>>>        Local String  sDriverID
76962>>>>>>>        Local Integer iVoid
76962>>>>>>>
76962>>>>>>>        Get psDriverID To sDriverID
76963>>>>>>>        If (sDriverID <> "") ;            Call_driver 0 sDriverID Function CLI_READCONFIGURATION Callback 0 Passing sVoid sVoid iVoid Result iVoid
76970>>>>>>>    End_Procedure // ReadConfiguration
76971>>>>>>>
76971>>>>>>>
76971>>>>>>>
76971>>>>>>>    //***
76971>>>>>>>    //*** Function: TextToRIMValue
76971>>>>>>>    //*** Purpose : Convert a text to the corresponding
76971>>>>>>>    //***           Generate_Record_ID_Method attribute value
76971>>>>>>>    //***
76971>>>>>>>
76971>>>>>>>    Function TextToRIMValue String sText Returns Integer
76973>>>>>>>        If (sText = "None") ;            Function_return RIM_NONE
76976>>>>>>>        Else If (sText = "Identity Column") ;            Function_return RIM_IDENTITY_COLUMN
76980>>>>>>>        Else If (sText = "Dispenser Table") ;            Function_return RIM_DISPENSER_TABLE
76984>>>>>>>        Else If (sText = "External") ;            Function_return RIM_EXTERNAL
76988>>>>>>>    End_Function // TextToRIMValue
76989>>>>>>>
76989>>>>>>>
76989>>>>>>>
76989>>>>>>>    //***
76989>>>>>>>    //*** Function: RIMValueTotext
76989>>>>>>>    //*** Purpose : Convert a Generate_Record_ID_Method attribute value to the
76989>>>>>>>    //***           corresponding text.
76989>>>>>>>    //***
76989>>>>>>>
76989>>>>>>>    Function RIMValueToText Integer iAttrValue Returns String
76991>>>>>>>        If (iAttrValue = RIM_NONE) ;            Function_return "None"
76994>>>>>>>        Else If (iAttrValue = RIM_IDENTITY_COLUMN) ;            Function_return "Identity Column"
76998>>>>>>>        Else If (iAttrValue = RIM_DISPENSER_TABLE) ;            Function_return "Dispenser Table"
77002>>>>>>>        Else If (iAttrValue = RIM_EXTERNAL) ;            Function_return "External"
77006>>>>>>>    End_Function // RIMValueToText
77007>>>>>>>
77007>>>>>>>
77007>>>>>>>
77007>>>>>>>    //***
77007>>>>>>>    //*** Function: TextToROValue
77007>>>>>>>    //*** Purpose : Convert a text to the corresponding
77007>>>>>>>    //***           Generate_Record_ID_Method attribute value
77007>>>>>>>    //***
77007>>>>>>>
77007>>>>>>>    Function TextToROValue String sText Returns Integer
77009>>>>>>>        If (sText = "No") ;            Function_return RO_NO
77012>>>>>>>        Else If (sText = "Ignore Change") ;            Function_return RO_IGNORECHANGE
77016>>>>>>>        Else If (sText = "Accept Change") ;            Function_return RO_ACCEPTCHANGE
77020>>>>>>>        Else If (sText = "Error On Change") ;            Function_return RO_ERRORONCHANGE
77024>>>>>>>    End_Function // TextToRIMValue
77025>>>>>>>
77025>>>>>>>
77025>>>>>>>
77025>>>>>>>    //***
77025>>>>>>>    //*** Function: ROValueTotext
77025>>>>>>>    //*** Purpose : Convert a Generate_Record_ID_Method attribute value to the
77025>>>>>>>    //***           corresponding text.
77025>>>>>>>    //***
77025>>>>>>>
77025>>>>>>>    Function ROValueToText Integer iAttrValue Returns String
77027>>>>>>>        If (iAttrValue = RO_NO) ;            Function_return "No"
77030>>>>>>>        Else If (iAttrValue = RO_IGNORECHANGE) ;            Function_return "Ignore Change"
77034>>>>>>>        Else If (iAttrValue = RO_ACCEPTCHANGE) ;            Function_return "Accept Change"
77038>>>>>>>        Else If (iAttrValue = RO_ERRORONCHANGE) ;            Function_return "Error On Change"
77042>>>>>>>    End_Function // RIMValueToText
77043>>>>>>>
77043>>>>>>>
77043>>>>>>>
77043>>>>>>>    //***
77043>>>>>>>    //*** Function: LastDriverError
77043>>>>>>>    //*** Purpose : Return the text f the last error geneated by the driver.
77043>>>>>>>    //***
77043>>>>>>>
77043>>>>>>>    Function LastDriverError Returns String
77045>>>>>>>        Local String  sDriverID
77045>>>>>>>        Local String  sLastError
77045>>>>>>>        Local String  sLastErrorLength
77045>>>>>>>        Local Integer iLastErrorLength
77045>>>>>>>        Local Integer iVoid
77045>>>>>>>
77045>>>>>>>        //*** Initialize
77045>>>>>>>        Move "" To sLastError
77046>>>>>>>
77046>>>>>>>        Get psDriverID To sDriverID
77047>>>>>>>        If (sDriverID <> "") Begin
77049>>>>>>>            //*** Get the text of the last error
77049>>>>>>>            Move (Repeat(Character(" "), 14)) To sLastErrorlength
77050>>>>>>>            Call_driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastErrorLength iVoid DRVR_LASTERRORTEXTLENGTH Result iVoid
77055>>>>>>>            Move (Left(sLastErrorLength, Pos(Character(0), sLastErrorLength) - 1)) To iLastErrorLength
77056>>>>>>>
77056>>>>>>>            If (iLastErrorLength > 0) Begin
77058>>>>>>>                Move (Repeat(Character(" "), iLastErrorLength + 1)) To sLastError
77059>>>>>>>                Call_driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastError iVoid DRVR_LASTERRORTEXT Result iVoid
77064>>>>>>>                Move (Left(sLastError, Pos(Character(0), sLastError) - 1)) To sLastError
77065>>>>>>>            End
77065>>>>>>>>
77065>>>>>>>        End
77065>>>>>>>>
77065>>>>>>>
77065>>>>>>>        Function_Return sLastError
77066>>>>>>>    End_Function // LastDriverError
77067>>>>>>>
77067>>>>>>>
77067>>>>>>>
77067>>>>>>>    //***
77067>>>>>>>    //*** Function: EnumerateTables
77067>>>>>>>    //*** Purpose : Enumerate the tables in a database
77067>>>>>>>    //***
77067>>>>>>>
77067>>>>>>>    Function EnumerateTables String sLogin Returns Integer
77069>>>>>>>        Local String  sDriver
77069>>>>>>>        Local String  sVoid
77069>>>>>>>        Local Integer iNumTables
77069>>>>>>>        Local Integer iVoid
77069>>>>>>>
77069>>>>>>>        Get psDriverID To sDriver
77070>>>>>>>        If (sDriver <> "") ;            Call_driver 0 sDriver Function CLI_ENUMERATE_TABLES Callback 0 Passing sLogin sVoid iVoid Result iNumTables
77077>>>>>>>
77077>>>>>>>        Function_Return iNumTables
77078>>>>>>>    End_Function // EnumerateTables
77079>>>>>>>
77079>>>>>>>
77079>>>>>>>
77079>>>>>>>    //***
77079>>>>>>>    //*** Function: TableName
77079>>>>>>>    //*** Purpose : Returns the name of the table enumerated at the given position
77079>>>>>>>    //***
77079>>>>>>>
77079>>>>>>>    Function TableName Integer iIndex Returns String
77081>>>>>>>        Local String  sDriver
77081>>>>>>>        Local String  sTableName
77081>>>>>>>        Local String  sVoid
77081>>>>>>>        Local Integer iVoid
77081>>>>>>>
77081>>>>>>>        Get psDriverID To sDriver
77082>>>>>>>        If (sDriver <> "") Begin
77084>>>>>>>            Move (Repeat(" ", 255)) To sTableName
77085>>>>>>>            Call_driver 0 sDriver Function CLI_TABLENAME Callback 0 Passing sTableName sVoid iIndex Result iVoid
77090>>>>>>>        End
77090>>>>>>>>
77090>>>>>>>
77090>>>>>>>        Function_Return sTableName
77091>>>>>>>    End_Function // TableName
77092>>>>>>>
77092>>>>>>>
77092>>>>>>>
77092>>>>>>>    //***
77092>>>>>>>    //*** Function: SchemaName
77092>>>>>>>    //*** Purpose : Returns the name of the schema of the table enumerated at the given position
77092>>>>>>>    //***
77092>>>>>>>
77092>>>>>>>    Function SchemaName Integer iIndex Returns String
77094>>>>>>>        Local String  sDriver
77094>>>>>>>        Local String  sSchemaName
77094>>>>>>>        Local String  sVoid
77094>>>>>>>        Local Integer iVoid
77094>>>>>>>
77094>>>>>>>        Get psDriverID To sDriver
77095>>>>>>>        If (sDriver <> "") Begin
77097>>>>>>>            Move (Repeat(" ", 255)) To sSchemaName
77098>>>>>>>            Call_driver 0 sDriver Function CLI_TABLESCHEMA Callback 0 Passing sSchemaName sVoid iIndex Result iVoid
77103>>>>>>>        End
77103>>>>>>>>
77103>>>>>>>
77103>>>>>>>        Function_Return sSchemaName
77104>>>>>>>    End_Function // SchemaName
77105>>>>>>>
77105>>>>>>>
77105>>>>>>>
77105>>>>>>>    //***
77105>>>>>>>    //*** Function: TableType
77105>>>>>>>    //*** Purpose : Returns the type of the table enumerated at the given position.
77105>>>>>>>    //***           Types can be "TABLE", "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY",
77105>>>>>>>    //***           "LOCAL TEMPORARY", "ALIAS", "SYNONYM"
77105>>>>>>>    //***
77105>>>>>>>
77105>>>>>>>    Function TableType Integer iIndex Returns String
77107>>>>>>>        Local String  sDriver
77107>>>>>>>        Local String  sTableType
77107>>>>>>>        Local String  sVoid
77107>>>>>>>        Local Integer iVoid
77107>>>>>>>
77107>>>>>>>        Get psDriverID To sDriver
77108>>>>>>>        If (sDriver <> "") Begin
77110>>>>>>>            Move (Repeat(" ", 25)) To sTableType
77111>>>>>>>            Call_driver 0 sDriver Function CLI_TABLETYPE Callback 0 Passing sTableType sVoid iIndex Result iVoid
77116>>>>>>>        End
77116>>>>>>>>
77116>>>>>>>
77116>>>>>>>        Function_Return sTableType
77117>>>>>>>    End_Function // TableType
77118>>>>>>>
77118>>>>>>>
77118>>>>>>>
77118>>>>>>>    //***
77118>>>>>>>    //*** Function: TableComment
77118>>>>>>>    //*** Purpose : Returns the comment of the table enumerated at the given position
77118>>>>>>>    //***
77118>>>>>>>
77118>>>>>>>    Function TableComment Integer iIndex Returns String
77120>>>>>>>        Local String  sDriver
77120>>>>>>>        Local String  sTableComment
77120>>>>>>>        Local String  sVoid
77120>>>>>>>        Local Integer iVoid
77120>>>>>>>
77120>>>>>>>        Get psDriverID To sDriver
77121>>>>>>>        If (sDriver <> "") Begin
77123>>>>>>>            Move (Repeat(" ", 255)) To sTableComment
77124>>>>>>>            Call_driver 0 sDriver Function CLI_TABLECOMMENT Callback 0 Passing sTableComment sVoid iIndex Result iVoid
77129>>>>>>>        End
77129>>>>>>>>
77129>>>>>>>
77129>>>>>>>        Function_Return sTableComment
77130>>>>>>>    End_Function // TableComment
77131>>>>>>>
77131>>>>>>>
77131>>>>>>>
77131>>>>>>>    //***
77131>>>>>>>    //*** Function: EnumerateColumns
77131>>>>>>>    //*** Purpose : Enumerate the columns in a table
77131>>>>>>>    //***
77131>>>>>>>
77131>>>>>>>    Function EnumerateColumns String sLogin String sTableName Returns Integer
77133>>>>>>>        Local String  sDriver
77133>>>>>>>        Local Integer iNumColumns
77133>>>>>>>        Local Integer iVoid
77133>>>>>>>
77133>>>>>>>        Get psDriverID To sDriver
77134>>>>>>>        If (sDriver <> "") ;            Call_driver 0 sDriver Function CLI_ENUMERATE_COLUMNS Callback 0 Passing sLogin sTablename iVoid Result iNumColumns
77141>>>>>>>
77141>>>>>>>        Function_Return iNumColumns
77142>>>>>>>    End_Function // EnumerateColumns
77143>>>>>>>
77143>>>>>>>
77143>>>>>>>
77143>>>>>>>    //***
77143>>>>>>>    //*** Function: ColumnName
77143>>>>>>>    //*** Purpose : Returns the name of the column enumerated at the given position
77143>>>>>>>    //***
77143>>>>>>>
77143>>>>>>>    Function ColumnName Integer iIndex Returns String
77145>>>>>>>        Local String  sDriver
77145>>>>>>>        Local String  sColumnName
77145>>>>>>>        Local String  sVoid
77145>>>>>>>        Local Integer iVoid
77145>>>>>>>
77145>>>>>>>        Get psDriverID To sDriver
77146>>>>>>>        If (sDriver <> "") Begin
77148>>>>>>>            Move (Repeat(" ", 255)) To sColumnName
77149>>>>>>>            Call_driver 0 sDriver Function CLI_COLUMNNAME Callback 0 Passing sColumnName sVoid iIndex Result iVoid
77154>>>>>>>        End
77154>>>>>>>>
77154>>>>>>>
77154>>>>>>>        Function_Return sColumnName
77155>>>>>>>    End_Function // ColumnName
77156>>>>>>>
77156>>>>>>>
77156>>>>>>>
77156>>>>>>>    //***
77156>>>>>>>    //*** Function: CLIDFDateToSQLDate
77156>>>>>>>    //*** Purpose : Convert a DataFlex date to a SQL date using the dummy zero date value.
77156>>>>>>>    //***
77156>>>>>>>
77156>>>>>>>    Function CLIDFDateToSQLDate String sDRiver Date dDFDate Returns String
77158>>>>>>>        Local String sSQLDate
77158>>>>>>>        Local Integer iOrgDateFmt
77158>>>>>>>        Local Integer iOrgDateSep
77158>>>>>>>
77158>>>>>>>        //*** Change date format to military, SQL dates are military dates
77158>>>>>>>        Get_Attribute DF_DATE_FORMAT To iOrgDateFmt
77161>>>>>>>        Get_Attribute DF_DATE_SEPARATOR To iOrgDateSep
77164>>>>>>>        Set_Attribute DF_DATE_FORMAT To DF_DATE_MILITARY
77167>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To (Ascii('-'))
77170>>>>>>>
77170>>>>>>>        //*** We only need to convert if the date is 0
77170>>>>>>>        If (Integer(dDFDate = 0)) ;            CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE To sSQLDate
77179>>>>>>>        Else ;            Move dDFDate To sSQLDate
77181>>>>>>>
77181>>>>>>>        //*** Change date format back to original
77181>>>>>>>        Set_Attribute DF_DATE_FORMAT To iOrgDateFmt
77184>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To iOrgDateSep
77187>>>>>>>
77187>>>>>>>        Function_Return sSQLDate
77188>>>>>>>    End_Function // CLIDFDateToSQLDate
77189>>>>>>>
77189>>>>>>>
77189>>>>>>>
77189>>>>>>>    //***
77189>>>>>>>    //*** Function: CLISQLDateToDFDate
77189>>>>>>>    //*** Purpose : Convert a SQL date to a DataFlex date using the dummy zero date value.
77189>>>>>>>    //***
77189>>>>>>>
77189>>>>>>>    Function CLISQLDateToDFDate String sDRiver String sSQLDate Returns Date
77191>>>>>>>        Local Date dDFDate
77191>>>>>>>        Local String sDummyDateValue
77191>>>>>>>        Local Integer iOrgDateFmt
77191>>>>>>>        Local Integer iOrgDateSep
77191>>>>>>>
77191>>>>>>>        //*** Change date format to military, SQL dates are military dates
77191>>>>>>>        Get_Attribute DF_DATE_FORMAT To iOrgDateFmt
77194>>>>>>>        Get_Attribute DF_DATE_SEPARATOR To iOrgDateSep
77197>>>>>>>        Set_Attribute DF_DATE_FORMAT To DF_DATE_MILITARY
77200>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To (Ascii('-'))
77203>>>>>>>
77203>>>>>>>        //*** We only need to convert if the date is the dummy zero date value
77203>>>>>>>        CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE To sDummyDateValue
77210>>>>>>>        If (sDummyDateValue = sSQLDate) ;            Move 0 To dDFDate
77213>>>>>>>        Else ;            Move sSQLDate To dDFDate
77215>>>>>>>
77215>>>>>>>        //*** Change date format back to original
77215>>>>>>>        Set_Attribute DF_DATE_FORMAT To iOrgDateFmt
77218>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To iOrgDateSep
77221>>>>>>>
77221>>>>>>>        Function_Return dDFDate
77222>>>>>>>    End_Function // CLISQLDateToDFDate
77223>>>>>>>
77223>>>>>>>
77223>>>>>>>
77223>>>>>>>    //***
77223>>>>>>>    //*** Function: RedirectConnection
77223>>>>>>>    //*** Purpose : Redirect an exisitng connection. The existing connection
77223>>>>>>>    //***           will point to another database but all tables will stay
77223>>>>>>>    //***           open!
77223>>>>>>>    //***
77223>>>>>>>
77223>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
77225>>>>>>>        Local String  sDriver
77225>>>>>>>        Local String  sVoid
77225>>>>>>>        Local Integer iResult
77225>>>>>>>        Local Integer iVoid
77225>>>>>>>
77225>>>>>>>        Get psDriverID To sDriver
77226>>>>>>>        If (sDriver <> "") Begin
77228>>>>>>>            Call_driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sOldConnection sNewConnection iVoid Result iResult
77233>>>>>>>        End
77233>>>>>>>>
77233>>>>>>>        Function_Return iResult
77234>>>>>>>    End_Function // RedirectConnect
77235>>>>>>>
77235>>>>>>>
77235>>>>>>>
77235>>>>>>>    //***
77235>>>>>>>    //*** Function: CreateConnectionID
77235>>>>>>>    //*** Purpose : Create a DataFlex side connection id that can be used later on.
77235>>>>>>>    //***
77235>>>>>>>
77235>>>>>>>    Function CreateConnectionID String sID String sConnStr Integer iOpt Returns Integer
77237>>>>>>>        Local String  sDriver
77237>>>>>>>        Local Integer iResult
77237>>>>>>>        Local Integer iOptions
77237>>>>>>>
77237>>>>>>>        Get psDriverID to sDriver
77238>>>>>>>        If (Num_Arguments = 2) ;            Move 0 to iOptions
77241>>>>>>>        Else ;            Move iOpt to iOptions
77243>>>>>>>        If (sDriver <> "") Begin
77245>>>>>>>            Call_Driver 0 sDriver Function CLI_CREATECONNECTIONID Callback 0 Passing sID sConnStr iOptions Result iResult
77250>>>>>>>        End
77250>>>>>>>>
77250>>>>>>>        Function_Return iResult
77251>>>>>>>    End_Function // CreateConnectionID
77252>>>>>>>
77252>>>>>>>
77252>>>>>>>
77252>>>>>>>    //***
77252>>>>>>>    //*** Function: DeleteConnectionID
77252>>>>>>>    //*** Purpose : Delete a DataFlex side connection id.
77252>>>>>>>    //***
77252>>>>>>>
77252>>>>>>>    Function DeleteConnectionID String sID Integer iIndex Returns Integer
77254>>>>>>>        Local String  sDriver
77254>>>>>>>        Local Integer iResult
77254>>>>>>>        Local String sVoid
77254>>>>>>>
77254>>>>>>>        Get psDriverID To sDriver
77255>>>>>>>        If (sDriver <> "") Begin
77257>>>>>>>            Call_Driver 0 sDriver Function CLI_DELETECONNECTIONID Callback 0 Passing sID sVoid iIndex Result iResult
77262>>>>>>>        End
77262>>>>>>>>
77262>>>>>>>        Function_Return iResult
77263>>>>>>>    End_Function // DeleteConnectionID
77264>>>>>>>
77264>>>>>>>End_Class // cCLIHandler
77265>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 18.1\Pkg\DFBTRDRV.PKG)
77265>>>>>>>//****************************************************************************
77265>>>>>>>//
77265>>>>>>>// $File name  : DFBTRDRV.PKG
77265>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
77265>>>>>>>// Notice      : This package contains constants and commands, used to call
77265>>>>>>>//               specific functions in the DFBTRDRV.
77265>>>>>>>// $Author(s)  : Eddy Kleinjan
77265>>>>>>>//
77265>>>>>>>// $System     : DataFlex Connectivity Kit for Pervasive.SQL
77265>>>>>>>// Created     : 01-07-97 @ 12:00:00
77265>>>>>>>//
77265>>>>>>>// Changed     : 04-04-2001.
77265>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.145
77265>>>>>>>//
77265>>>>>>>// Changed     : June 6, 2001
77265>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.148
77265>>>>>>>//
77265>>>>>>>//               Added DFBTR_DDF_OWNER command.
77265>>>>>>>//
77265>>>>>>>// Changed     : June 12, 2001
77265>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.149
77265>>>>>>>//
77265>>>>>>>//               Added DF_FIELD_IS_NULL and DF_FIELD_NULL_ALLOWED attributes
77265>>>>>>>//
77265>>>>>>>// Changed     : August 4, 2004
77265>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.1
77265>>>>>>>//
77265>>>>>>>//               Added cDfbtrdrvHandler class.
77265>>>>>>>//               New functions in this class:
77265>>>>>>>//                  Function CKRevision Returns String
77265>>>>>>>//                  Function CkUsesUri Returns Integer
77265>>>>>>>//                  Function PSQLRequesterVersionInfo Integer iFileNum Returns String
77265>>>>>>>//                  Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
77265>>>>>>>//                  Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
77265>>>>>>>//
77265>>>>>>>// Changed     : September 30, 2005
77265>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.14
77265>>>>>>>//
77265>>>>>>>//               Bugfix: Prevent compiler errors when no (df)error.pkg is used
77265>>>>>>>//****************************************************************************
77265>>>>>>>Use Ui
77265>>>>>>>//
77265>>>>>>>// Driver Indentification
77265>>>>>>>//
77265>>>>>>>
77265>>>>>>>//*** Driver attributes
77265>>>>>>>//
77265>>>>>>>// Call_Driver functions ID's
77265>>>>>>>//
77265>>>>>>>//
77265>>>>>>>// DFBTRFN_CONVERT_FILE options
77265>>>>>>>//
77265>>>>>>>
77265>>>>>>>//
77265>>>>>>>// DFBTRFN_SET_OWNER options
77265>>>>>>>//
77265>>>>>>>
77265>>>>>>>//
77265>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
77265>>>>>>>//
77265>>>>>>>
77265>>>>>>>
77265>>>>>>>//
77265>>>>>>>// Command to create all vars which may be needed
77265>>>>>>>// in other commands.
77265>>>>>>>//
77265>>>>>>>
77265>>>>>>>
77265>>>>>>>
77265>>>>>>>//
77265>>>>>>>// Command to set the owner of a Btrieve file.
77265>>>>>>>// File must have been opened.
77265>>>>>>>// Filenumber needs to be passed.
77265>>>>>>>// To clear set the owner to "".
77265>>>>>>>// Examples:
77265>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
77265>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
77265>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
77265>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
77265>>>>>>>// To clear:
77265>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
77265>>>>>>>//
77265>>>>>>>
77265>>>>>>>
77265>>>>>>>
77265>>>>>>>//
77265>>>>>>>// Command to parse DFBTR_SET_OWNVER
77265>>>>>>>// options.
77265>>>>>>>//
77265>>>>>>>
77265>>>>>>>
77265>>>>>>>
77265>>>>>>>//
77265>>>>>>>// Command to parse for Callback
77265>>>>>>>//
77265>>>>>>>
77265>>>>>>>
77265>>>>>>>
77265>>>>>>>//
77265>>>>>>>// Command to clear the owner of a Btrieve file.
77265>>>>>>>// File must have been opened.
77265>>>>>>>// Filenumber needs to be passed.
77265>>>>>>>// Examples:
77265>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
77265>>>>>>>//
77265>>>>>>>
77265>>>>>>>
77265>>>>>>>
77265>>>>>>>//
77265>>>>>>>// Command to add a owner name to the internal list of ownernames
77265>>>>>>>// which will be tries when opening files.
77265>>>>>>>//
77265>>>>>>>
77265>>>>>>>
77265>>>>>>>
77265>>>>>>>//
77265>>>>>>>// Command to remove all owners from the internal list of ownernames
77265>>>>>>>//
77265>>>>>>>
77265>>>>>>>
77265>>>>>>>//
77265>>>>>>>// Command to set the owner name to be used when opening the DDF files.
77265>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
77265>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
77265>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
77265>>>>>>>//
77265>>>>>>>
77265>>>>>>>//
77265>>>>>>>// Command to change the transaction type.
77265>>>>>>>// Valid types are:
77265>>>>>>>//     DFBTRTT_NONE
77265>>>>>>>//     DFBTRTT_EXCLUSIVE
77265>>>>>>>//     DFBTRTT_CONCURRENT
77265>>>>>>>//
77265>>>>>>>//
77265>>>>>>>
77265>>>>>>>
77265>>>>>>>
77265>>>>>>>//
77265>>>>>>>// Command to get the current transaction type.
77265>>>>>>>//
77265>>>>>>>
77265>>>>>>>//
77265>>>>>>>// Command to set explicit_locking
77265>>>>>>>//
77265>>>>>>>
77265>>>>>>>//
77265>>>>>>>// Command to get explicit locking
77265>>>>>>>//
77265>>>>>>>
77265>>>>>>>//
77265>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
77265>>>>>>>//
77265>>>>>>>
77265>>>>>>>//
77265>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
77265>>>>>>>//
77265>>>>>>>
77265>>>>>>>//*****************************************************************************
77265>>>>>>>//*** Class  : cDfbtrdrvHandler                                                  ***
77265>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
77265>>>>>>>//***          call several Dfbtrdrv releated methods.                           ***
77265>>>>>>>//*****************************************************************************
77265>>>>>>>
77265>>>>>>>Class cDFBtrDrvHandler Is An Array
77266>>>>>>>
77266>>>>>>>    Procedure Construct_Object Integer iImage
77268>>>>>>>        Forward Send Construct_object iImage
77270>>>>>>>
77270>>>>>>>        Property String  psDriverID       Public "DFBTRDRV"
77271>>>>>>>    End_Procedure // Construct_Object
77272>>>>>>>
77272>>>>>>>
77272>>>>>>>
77272>>>>>>>    //***
77272>>>>>>>    //*** Function: CKRevsion
77272>>>>>>>    //*** Purpose : The revsion of a Dfbtrdrv Connectivity Kit
77272>>>>>>>    //***
77272>>>>>>>
77272>>>>>>>    Function CKRevision Returns String
77274>>>>>>>        Local String  sDriverID
77274>>>>>>>        Local String  sRevision
77274>>>>>>>        Local String  sVoid
77274>>>>>>>        Local Integer iRetval
77274>>>>>>>
77274>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
77274>>>>>>>        // This error would otherwise be raised when we have an older
77274>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
77274>>>>>>>        Send Ignore_error To Error_object_Id 20491
77275>>>>>>>        Get psDriverID To sDriverID
77276>>>>>>>        Move (Repeat(" ", 255)) To sRevision
77277>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
77282>>>>>>>        Send Trap_Error To Error_object_Id 20491
77283>>>>>>>        If (Trim(sRevision) = "") Begin
77285>>>>>>>            // Unable to get the revision. return all zeroes.
77285>>>>>>>            Move "0.0.0.0" To sRevision
77286>>>>>>>        End
77286>>>>>>>>
77286>>>>>>>        Function_Return sRevision
77287>>>>>>>    End_Function // CKRevision
77288>>>>>>>
77288>>>>>>>    Function CkUsesUri Returns Integer
77290>>>>>>>        Local String  sDriverID
77290>>>>>>>        Local String  sVoid1
77290>>>>>>>        Local String  sVoid2
77290>>>>>>>        Local Integer iRetval
77290>>>>>>>
77290>>>>>>>        Get psDriverID To sDriverID
77291>>>>>>>
77291>>>>>>>        Move 0 To iRetval
77292>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
77292>>>>>>>        // This error would otherwise be raised when we have an older
77292>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
77292>>>>>>>        Send Ignore_error To Error_object_Id 20491
77293>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
77298>>>>>>>        Send Trap_Error To Error_object_Id 20491
77299>>>>>>>
77299>>>>>>>        Function_Return iRetval
77300>>>>>>>    End_Function // CKUsesUri
77301>>>>>>>
77301>>>>>>>
77301>>>>>>>
77301>>>>>>>    //***
77301>>>>>>>    //*** Function: ExtractPartFromRevsion
77301>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
77301>>>>>>>    //***
77301>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
77301>>>>>>>    //***
77301>>>>>>>
77301>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
77303>>>>>>>        Local Integer iPartRev
77303>>>>>>>        Local Integer iCurrentPart
77303>>>>>>>        Local Integer iSeparatorPos
77303>>>>>>>
77303>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
77306>>>>>>>
77306>>>>>>>        Move 0 To iCurrentPart
77307>>>>>>>        Repeat
77307>>>>>>>>
77307>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
77308>>>>>>>            If (iSeparatorPos > 0) Begin
77310>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
77311>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
77312>>>>>>>                Increment iCurrentPart
77313>>>>>>>            End
77313>>>>>>>>
77313>>>>>>>            Else If (sRevision <> "") Begin
77316>>>>>>>                Move sRevision To iPartRev
77317>>>>>>>                Move "" To sRevision
77318>>>>>>>                Increment iCurrentPart
77319>>>>>>>            End
77319>>>>>>>>
77319>>>>>>>            Else ;                Move -1 To iPartRev
77321>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
77323>>>>>>>
77323>>>>>>>        Function_Return iPartRev
77324>>>>>>>    End_Function // EcxtractPartFromRevision
77325>>>>>>>
77325>>>>>>>
77325>>>>>>>
77325>>>>>>>    //***
77325>>>>>>>    //*** Function: CKMajorRevision
77325>>>>>>>    //*** Purpose : Returns the major revision of the CK
77325>>>>>>>    //***
77325>>>>>>>
77325>>>>>>>    Function CKMajorRevision Returns Integer
77327>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
77328>>>>>>>    End_Function // CKMajorRevision
77329>>>>>>>
77329>>>>>>>
77329>>>>>>>
77329>>>>>>>    //***
77329>>>>>>>    //*** Function: CKMinorRevision
77329>>>>>>>    //*** Purpose : Returns the minor revision of the CK
77329>>>>>>>    //***
77329>>>>>>>
77329>>>>>>>    Function CKMinorRevision Returns Integer
77331>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
77332>>>>>>>    End_Function // CKMinorRevision
77333>>>>>>>
77333>>>>>>>
77333>>>>>>>
77333>>>>>>>    //***
77333>>>>>>>    //*** Function: CKReleaseRevision
77333>>>>>>>    //*** Purpose : Returns the release revision of the CK
77333>>>>>>>    //***
77333>>>>>>>
77333>>>>>>>    Function CKReleaseRevision Returns Integer
77335>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
77336>>>>>>>    End_Function // CKReleaseRevision
77337>>>>>>>
77337>>>>>>>
77337>>>>>>>
77337>>>>>>>    //***
77337>>>>>>>    //*** Function: CKBuildRevision
77337>>>>>>>    //*** Purpose : Returns the major revision of the CK
77337>>>>>>>    //***
77337>>>>>>>
77337>>>>>>>    Function CKBuildRevision Returns Integer
77339>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
77340>>>>>>>    End_Function // CKBuildRevision
77341>>>>>>>
77341>>>>>>>
77341>>>>>>>
77341>>>>>>>    //***
77341>>>>>>>    //*** Function: IsMinimalRevision
77341>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
77341>>>>>>>    //***
77341>>>>>>>
77341>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
77343>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
77346>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
77349>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
77352>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
77355>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
77358>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
77362>>>>>>>            End
77362>>>>>>>>
77362>>>>>>>        End
77362>>>>>>>>
77362>>>>>>>
77362>>>>>>>        Function_Return (FALSE)
77363>>>>>>>    End_Function // IsMinimalRevision
77364>>>>>>>
77364>>>>>>>    //   Functions to query the Pervasive.SQL version:
77364>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
77364>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
77364>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
77364>>>>>>>    //
77364>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
77364>>>>>>>    //   in the following format:
77364>>>>>>>    //       <version>.<revision>.<type>
77364>>>>>>>    //   possible values for <type>:
77364>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
77364>>>>>>>    //         server using Workgroup authentication mode
77364>>>>>>>    //       C for client cache engine
77364>>>>>>>    //       D for DOS workstation
77364>>>>>>>    //       N for client Requester
77364>>>>>>>    //       S for NetWare server
77364>>>>>>>    //       T for 32-bit Windows server engine
77364>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
77364>>>>>>>    //
77364>>>>>>>    //   example:
77364>>>>>>>    //       8.50.T
77364>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
77364>>>>>>>    //   32-bits Windows server.
77364>>>>>>>    //
77364>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
77364>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
77364>>>>>>>    //
77364>>>>>>>    //   If the version information is not available or can not be obtained
77364>>>>>>>    //   the functions will return "0.0.0"
77364>>>>>>>
77364>>>>>>>
77364>>>>>>>    //***
77364>>>>>>>    //*** Function: PSQLRequesterVersionInfo
77364>>>>>>>    //*** Purpose : Returns the version information of the
77364>>>>>>>    //***           Pervasive.SQL Client requester.
77364>>>>>>>
77364>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
77366>>>>>>>
77366>>>>>>>        Local String  sDriverID
77366>>>>>>>        Local String  sVersion
77366>>>>>>>        Local String  sVoid
77366>>>>>>>        Local Integer iRetval
77366>>>>>>>
77366>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
77366>>>>>>>        // This error would otherwise be raised when we have an older
77366>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
77366>>>>>>>        Send Ignore_error To Error_object_Id 20491
77367>>>>>>>        Get psDriverID To sDriverID
77368>>>>>>>        Move (Repeat(" ", 255)) To sVersion
77369>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
77374>>>>>>>        Send Trap_Error To Error_object_Id 20491
77375>>>>>>>        If (Trim(sVersion) = "") Begin
77377>>>>>>>            // Unable to get the revision. return all zeroes.
77377>>>>>>>            Move "0.0.0" To sVersion
77378>>>>>>>        End
77378>>>>>>>>
77378>>>>>>>        Function_Return sVersion
77379>>>>>>>    End_Function //  PSQLRequesterVersion
77380>>>>>>>
77380>>>>>>>    //***
77380>>>>>>>    //*** Function: PSQLLocalEngineVersionInfo
77380>>>>>>>    //*** Purpose : Returns the version information of the
77380>>>>>>>    //***           Pervasive.SQL Local Engine
77380>>>>>>>
77380>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
77382>>>>>>>
77382>>>>>>>        Local String  sDriverID
77382>>>>>>>        Local String  sVersion
77382>>>>>>>        Local String  sVoid
77382>>>>>>>        Local Integer iRetval
77382>>>>>>>
77382>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
77382>>>>>>>        // This error would otherwise be raised when we have an older
77382>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
77382>>>>>>>        Send Ignore_error To Error_object_Id 20491
77383>>>>>>>        Get psDriverID To sDriverID
77384>>>>>>>        Move (Repeat(" ", 255)) To sVersion
77385>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
77390>>>>>>>        Send Trap_Error To Error_object_Id 20491
77391>>>>>>>        If (Trim(sVersion) = "") Begin
77393>>>>>>>            // Unable to get the revision. return all zeroes.
77393>>>>>>>            Move "0.0.0" To sVersion
77394>>>>>>>        End
77394>>>>>>>>
77394>>>>>>>        Function_Return sVersion
77395>>>>>>>    End_Function //  PSQLLocalEngineVersion
77396>>>>>>>
77396>>>>>>>    //***
77396>>>>>>>    //*** Function: PSQLServerEngineVersionInfo
77396>>>>>>>    //*** Purpose : Returns the version information of the
77396>>>>>>>    //***           Pervasive.SQL Server Engine
77396>>>>>>>
77396>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
77398>>>>>>>
77398>>>>>>>        Local String  sDriverID
77398>>>>>>>        Local String  sVersion
77398>>>>>>>        Local String  sVoid
77398>>>>>>>        Local Integer iRetval
77398>>>>>>>
77398>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
77398>>>>>>>        // This error would otherwise be raised when we have an older
77398>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
77398>>>>>>>        Send Ignore_error To Error_object_Id 20491
77399>>>>>>>        Get psDriverID To sDriverID
77400>>>>>>>        Move (Repeat(" ", 255)) To sVersion
77401>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
77406>>>>>>>        Send Trap_Error To Error_object_Id 20491
77407>>>>>>>        If (Trim(sVersion) = "") Begin
77409>>>>>>>            // Unable to get the revision. return all zeroes.
77409>>>>>>>            Move "0.0.0" To sVersion
77410>>>>>>>        End
77410>>>>>>>>
77410>>>>>>>        Function_Return sVersion
77411>>>>>>>    End_Function //  PSQLServerEngineVersion
77412>>>>>>>
77412>>>>>>>End_Class // cDfbtrdrvHandler
77413>>>>>>>
77413>>>>>
77413>>>>>
77413>>>>>External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
77414>>>>>
77414>>>>>Register_Function phoWorkspace Returns Handle
77414>>>>>Register_Function Help_filename Returns String
77414>>>>>Register_Function GetHelpFile Returns String
77414>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
77414>>>>>
77414>>>>>//****************************************************************************
77414>>>>>// $Module type: FUNCTION
77414>>>>>// $Module name: Network_User_Name
77414>>>>>// $Author     : AK/VOO/KCR
77414>>>>>// Created     : 09-24-96 @ 19:17
77414>>>>>//
77414>>>>>// Description
77414>>>>>//    This function reads the current username Of windows and returns that
77414>>>>>//    name or an text unknown user
77414>>>>>//
77414>>>>>// $Rev History
77414>>>>>//  02/22/2012  Ask Windows how long the size of the name should be
77414>>>>>//  07/25/2003  Replaced obsolete code
77414>>>>>//  09/24/1996  Module header created
77414>>>>>//****************************************************************************
77414>>>>>Function Network_User_Name for cDesktop Returns String
77416>>>>>    String sName
77416>>>>>    Integer iRetval iLength
77416>>>>>
77416>>>>>    Move 0 to iLength
77417>>>>>    Move (WNetGetUser (0, 0, AddressOf (iLength))) to iRetval
77418>>>>>    ZeroString iLength to sName
77419>>>>>    Move (WNetGetUser (0, AddressOf (sName), AddressOf (iLength))) to iRetval
77420>>>>>
77420>>>>>    If (iRetval = NO_ERROR) Begin
77422>>>>>        Function_Return (CString (sName))
77423>>>>>    End
77423>>>>>>
77423>>>>>    
77423>>>>>    Function_Return "User Unknown"
77424>>>>>End_Function
77425>>>>>
77425>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
77425>>>>>Type MEMORYSTATUS
77425>>>>>   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
77425>>>>>   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
77425>>>>>   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
77425>>>>>   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
77425>>>>>   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
77425>>>>>   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
77425>>>>>   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
77425>>>>>   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
77425>>>>>End_Type // MEMORYSTATUS
77425>>>>>
77425>>>>>External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
77426>>>>>
77426>>>>>Struct tWinMemoryStatusEx
77426>>>>>    UInteger dwLength                
77426>>>>>    UInteger dwMemoryLoad          
77426>>>>>    UBigInt ullTotalPhys           
77426>>>>>    UBigInt ullAvailPhys           
77426>>>>>    UBigInt ullTotalPageFile       
77426>>>>>    UBigInt ullAvailPageFile       
77426>>>>>    UBigInt ullTotalVirtual        
77426>>>>>    UBigInt ullAvailVirtual        
77426>>>>>    UBigInt ullAvailExtendedVirtual
77426>>>>>End_Struct
77426>>>>>
77426>>>>>External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
77427>>>>>
77427>>>>>Class SysinfoDisplay is a cTextEdit
77428>>>>>    Procedure Construct_Object
77430>>>>>        Forward Send Construct_Object
77432>>>>>
77432>>>>>        Set Location To 6 6
77433>>>>>        Set Size To 110 255
77434>>>>>        Set Read_Only_State To True
77435>>>>>        Set pbWrap to False
77436>>>>>    End_Procedure
77437>>>>>
77437>>>>>    //****************************************************************************
77437>>>>>    // $Module type: PROCEDURE
77437>>>>>    // $Module name: Show_Current_Directory
77437>>>>>    // $Author     : VOO
77437>>>>>    // Created     : 06-10-96 @ 15:24
77437>>>>>    //
77437>>>>>    // Description
77437>>>>>    //    This method will show the name Of the current directory in the system
77437>>>>>    //    information box
77437>>>>>    //
77437>>>>>    // $Rev History
77437>>>>>    //    06-10-96  Module header created
77437>>>>>    //****************************************************************************
77437>>>>>    Procedure Show_Current_Directory
77439>>>>>        String sDir
77439>>>>>
77439>>>>>        Get_Current_Directory To sDir
77440>>>>>
77440>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
77441>>>>>    End_Procedure
77442>>>>>
77442>>>>>    Procedure Show_Windows_Directory
77444>>>>>        String sWindir
77444>>>>>
77444>>>>>        Get_Windows_Directory To sWindir
77445>>>>>
77445>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
77446>>>>>    End_Procedure
77447>>>>>
77447>>>>>    Procedure Show_Current_User
77449>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
77450>>>>>    End_Procedure
77451>>>>>
77451>>>>>    Procedure Show_Number_Format
77453>>>>>        Integer iFormat
77453>>>>>        String sFormatText
77453>>>>>
77453>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
77456>>>>>        Move (Character (iFormat)) To sFormatText
77457>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
77458>>>>>
77458>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
77461>>>>>        Move (Character (iFormat)) to sFormatText
77462>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
77463>>>>>    End_Procedure
77464>>>>>
77464>>>>>    Procedure Show_Filelist_Name
77466>>>>>        String sFilename
77466>>>>>
77466>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
77469>>>>>
77469>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
77470>>>>>    End_Procedure
77471>>>>>
77471>>>>>    Procedure Show_Lock_Delay
77473>>>>>        Integer iLockdelay
77473>>>>>
77473>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
77476>>>>>
77476>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
77477>>>>>    End_Procedure
77478>>>>>
77478>>>>>    Procedure Show_Lock_Timeout
77480>>>>>        Integer iLockTimeout
77480>>>>>
77480>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
77483>>>>>
77483>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
77484>>>>>    End_Procedure
77485>>>>>
77485>>>>>    Procedure Show_Screen_Size
77487>>>>>        Integer iYscreensize iXscreensize
77487>>>>>
77487>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
77488>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
77489>>>>>
77489>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
77490>>>>>    End_Procedure
77491>>>>>
77491>>>>>    Procedure Show_Page_Size
77493>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
77494>>>>>    End_procedure
77495>>>>>
77495>>>>>    Procedure Show_Date
77497>>>>>        Date dToday
77497>>>>>
77497>>>>>        Sysdate dToday
77498>>>>>
77498>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
77499>>>>>    End_procedure
77500>>>>>
77500>>>>>    Procedure Show_Date_Format
77502>>>>>        Integer iDateFormat
77502>>>>>        String sDateFormat
77502>>>>>
77502>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
77505>>>>>        Case Begin
77505>>>>>            Case (iDateFormat = DF_DATE_USA)
77507>>>>>                Move C_$USA To sDateFormat
77508>>>>>                Case Break
77509>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
77512>>>>>                Move C_$European To sDateFormat
77513>>>>>                Case Break
77514>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
77517>>>>>                Move C_$Military To sDateFormat
77518>>>>>                Case Break
77519>>>>>            Case Else
77519>>>>>                Move C_$UnknownDateType To sDateFormat
77520>>>>>                Case Break
77521>>>>>        Case End
77521>>>>>
77521>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
77522>>>>>    End_Procedure
77523>>>>>
77523>>>>>    Procedure Show_Systemresources
77525>>>>>        tWinMemoryStatusEx MemoryStatusInfo
77525>>>>>        tWinMemoryStatusEx MemoryStatusInfo
77525>>>>>        Integer iRetval
77525>>>>>
77525>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
77526>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
77527>>>>>        If (iRetval = 0) Begin
77529>>>>>            Move (ShowLastError ()) to iRetval
77530>>>>>        End
77530>>>>>>
77530>>>>>
77530>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, MemoryStatusInfo.ullTotalPhys))
77531>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, MemoryStatusInfo.dwMemoryLoad))
77532>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
77533>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
77534>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
77535>>>>>    End_Procedure
77536>>>>>
77536>>>>>    Procedure Show_Registration
77538>>>>>        String sRegName
77538>>>>>        Integer iSN iMaxUsers
77538>>>>>
77538>>>>>        Registration sRegName iSN
77539>>>>>>
77539>>>>>        
77539>>>>>        Get_Licensed_Max_Users to iMaxUsers
77540>>>>>
77540>>>>>        Send AppendTextLn ""
77541>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
77542>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
77543>>>>>        Send AppendTextLn (SFormat (C_$MaxNumUsers, iMaxUsers))
77544>>>>>    End_Procedure
77545>>>>>
77545>>>>>    //****************************************************************************
77545>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
77545>>>>>    // To the workspace object passing the an object and message To send back
77545>>>>>    // To this object. It is expected that the workspace object will send this
77545>>>>>    // message for every line Of information it wants displayed (passing the
77545>>>>>    // information To be displayed
77545>>>>>    //****************************************************************************
77545>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
77545>>>>>
77545>>>>>    Procedure Show_ServicePack
77547>>>>>        String sKey sVersionDescription sVersion 
77547>>>>>        Handle hoRegistry
77547>>>>>        Boolean bExists bOpened
77547>>>>>        
77547>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
77548>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
77549>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
77550>>>>>
77550>>>>>        Move C_DFVersionRegistryRoot to sKey
77551>>>>>        Get KeyExists of hoRegistry sKey to bExists
77552>>>>>        If (bExists) Begin
77554>>>>>            Get OpenKey of hoRegistry sKey to bOpened
77555>>>>>            If (bOpened) Begin
77557>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
77558>>>>>                If (bExists) Begin
77560>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersionDescription
77561>>>>>                End
77561>>>>>>
77561>>>>>                
77561>>>>>                Get ValueExists of hoRegistry "CurrentVersion" to bExists
77562>>>>>                If (bExists) Begin
77564>>>>>                    Get ReadString of hoRegistry "CurrentVersion" to sVersion
77565>>>>>                End                
77565>>>>>>
77565>>>>>                Send CloseKey of hoRegistry
77566>>>>>            End
77566>>>>>>
77566>>>>>        End
77566>>>>>>
77566>>>>>        Send Destroy of hoRegistry
77567>>>>>
77567>>>>>        If (sVersionDescription <> "") Begin
77569>>>>>           Send AppendTextLn (sVersionDescription * "-" * sVersion)
77570>>>>>           Send AppendTextLn ""
77571>>>>>        End
77571>>>>>>
77571>>>>>    End_Procedure
77572>>>>>
77572>>>>>    Procedure Show_WorkspaceInformation
77574>>>>>        Integer hoWorkspace
77574>>>>>
77574>>>>>        If (ghoApplication <> 0) Begin
77576>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
77577>>>>>            If (hoWorkspace <> 0) Begin
77579>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self (Refproc (AppendTextLn))
77580>>>>>            End
77580>>>>>>
77580>>>>>        End
77580>>>>>>
77580>>>>>    End_Procedure
77581>>>>>
77581>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
77583>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
77584>>>>>    End_Function
77585>>>>>
77585>>>>>    Procedure Show_Versions
77587>>>>>        Integer iVersion iRevision iBuild
77587>>>>>
77587>>>>>        Version_information iVersion iRevision iBuild
77589>>>>>
77589>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(Self,iVersion,iRevision,iBuild) ))
77590>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(Self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
77591>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(Self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
77592>>>>>    End_Procedure
77593>>>>>    
77593>>>>>    Function CKRevisionNumber String sDriverID Returns String
77595>>>>>        Handle hoCLIHandler
77595>>>>>        Handle hoDFBtrDrvHandler
77595>>>>>        String sCKRevision
77595>>>>>
77595>>>>>
77595>>>>>        If (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV") Begin
77597>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLIHandler
77598>>>>>            Set psDriverID of hoCLIHandler to sDriverID
77599>>>>>            Move (CKRevision(hoCLIHandler)) to sCKRevision
77600>>>>>            Send Destroy of hoCLIHandler
77601>>>>>        End
77601>>>>>>
77601>>>>>        Else Begin
77602>>>>>            If (sDriverID = "DFBTRDRV") Begin
77604>>>>>                Get Create (RefClass(cDFBtrDrvHandler)) to hoDFBtrDrvHandler
77605>>>>>                Set psDriverID of hoDFBtrDrvHandler to sDriverID
77606>>>>>                Move (CKRevision(hoDFBtrDrvHandler)) to sCKRevision
77607>>>>>                Send Destroy of hoDFBtrDrvHandler
77608>>>>>            End
77608>>>>>>
77608>>>>>        End
77608>>>>>>
77608>>>>>        
77608>>>>>        Function_Return sCKRevision
77609>>>>>    End_Function
77610>>>>>    
77610>>>>>    
77610>>>>>    Function IsDataAccessCK String sDriverID Returns Boolean
77612>>>>>        
77612>>>>>        If (sDriverID = "DATAFLEX") Begin
77614>>>>>            Function_Return False
77615>>>>>        End
77615>>>>>>
77615>>>>>    
77615>>>>>        Function_Return (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV" or sDriverID = "DFBTRDRV")
77616>>>>>    End_Function    
77617>>>>>
77617>>>>>
77617>>>>>    //***
77617>>>>>    //*** BW
77617>>>>>    //*** Procedure: Show_Drivers
77617>>>>>    //*** Purpose  : Show loaded database drivers
77617>>>>>    //***
77617>>>>>
77617>>>>>    Procedure Show_Drivers
77619>>>>>        String sCurrentDriver sRevNumber
77619>>>>>        String sLoadedDrivers
77619>>>>>        Integer iNumberOfDrivers iCount
77619>>>>>        Boolean bOK
77619>>>>>
77619>>>>>        Move "" To sLoadedDrivers
77620>>>>>        Get_Attribute DF_NUMBER_DRIVERS To iNumberOfDrivers
77623>>>>>        For iCount From 1 To iNumberOfDrivers
77629>>>>>>
77629>>>>>            Get_Attribute DF_DRIVER_NAME Of iCount To sCurrentDriver
77632>>>>>            If (sLoadedDrivers <> "") Begin
77634>>>>>                Move (Append (sLoadedDrivers, ", ")) To sLoadedDrivers
77635>>>>>            End
77635>>>>>>
77635>>>>>            Get IsDataAccessCK sCurrentDriver to bOK
77636>>>>>            If (bOK) Begin
77638>>>>>                Get CKRevisionNumber sCurrentDriver to sRevNumber
77639>>>>>                Move (sCurrentDriver * "(" + sRevNumber + ")") to sCurrentDriver
77640>>>>>            End
77640>>>>>>
77640>>>>>            Move (Append (sLoadedDrivers, sCurrentDriver)) To sLoadedDrivers
77641>>>>>        Loop
77642>>>>>>
77642>>>>>        Send AppendTextLn (SFormat (C_$DatabaseDriver, sLoadedDrivers))
77643>>>>>    End_Procedure
77644>>>>>
77644>>>>>    Procedure Show_HelpFile
77646>>>>>        String sHelpFile
77646>>>>>        Integer eHelpType
77646>>>>>
77646>>>>>        If (ghoApplication <> 0) Begin
77648>>>>>            Get peHelpType Of ghoApplication To eHelpType
77649>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
77651>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
77652>>>>>            End
77652>>>>>>
77652>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
77655>>>>>                Get Help_filename Of Help_object_id To sHelpFile
77656>>>>>            End
77656>>>>>>
77656>>>>>            Else Begin
77657>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
77658>>>>>            End
77658>>>>>>
77658>>>>>
77658>>>>>            Send AppendTextLn ""
77659>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
77660>>>>>        End
77660>>>>>>
77660>>>>>    End_Procedure
77661>>>>>
77661>>>>>    Procedure Show_EnterAsTab
77663>>>>>        Boolean bEnterKeyAsTabKey
77663>>>>>        String sText
77663>>>>>
77663>>>>>        If (ghoApplication <> 0) Begin
77665>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
77666>>>>>            If (bEnterKeyAsTabKey) Begin
77668>>>>>                Move "True" To sText
77669>>>>>            End
77669>>>>>>
77669>>>>>            Else Begin
77670>>>>>                Move "False" To sText
77671>>>>>            End
77671>>>>>>
77671>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
77672>>>>>        End
77672>>>>>>
77672>>>>>    End_Procedure
77673>>>>>
77673>>>>>    //****************************************************************************
77673>>>>>    // $Module type: PROCEDURE
77673>>>>>    // $Module name: Add_Focus
77673>>>>>    // $Author     : VOO
77673>>>>>    // Created     : 24-09-96 @ 19:43
77673>>>>>    //
77673>>>>>    // Description
77673>>>>>    //    During activation we will remove the old information and add the newly
77673>>>>>    //    found systeminformation
77673>>>>>    //
77673>>>>>    // $Rev History
77673>>>>>    //    24-09-96  Module header created
77673>>>>>    //****************************************************************************
77673>>>>>    Procedure Add_Focus Integer hoRoot
77675>>>>>        Forward Send Add_Focus hoRoot
77677>>>>>
77677>>>>>        Send Delete_Data
77678>>>>>
77678>>>>>        Set Changed_State To False
77679>>>>>        Set Read_Only_State To True
77680>>>>>
77680>>>>>        Send Show_ServicePack
77681>>>>>        If (ghoApplication <> 0) Begin
77683>>>>>            Send Show_WorkSpaceInformation // added To show WS info
77684>>>>>            Send Show_HelpFile
77685>>>>>            Send Show_EnterAsTab
77686>>>>>        End
77686>>>>>>
77686>>>>>        Send Show_Drivers
77687>>>>>        Send Show_Current_User
77688>>>>>        Send Show_Windows_Directory
77689>>>>>        Send Show_Current_Directory
77690>>>>>        Send Show_Filelist_Name
77691>>>>>        Send Show_Versions
77692>>>>>        Send Show_Screen_Size
77693>>>>>        Send Show_Page_Size
77694>>>>>        Send Show_Number_Format
77695>>>>>        Send Show_Date_Format
77696>>>>>        Send Show_Lock_Delay
77697>>>>>        Send Show_Lock_Timeout
77698>>>>>        Send Show_Date
77699>>>>>        Send Show_Systemresources
77700>>>>>        Send Show_Registration
77701>>>>>        Send Beginning_of_Data
77702>>>>>
77702>>>>>        Set Icon to 'default.ico'
77703>>>>>    End_Procedure
77704>>>>>End_Class
77705>>>>>
77705>>>>>//****************************************************************************
77705>>>>>// $Module type: OBJECT
77705>>>>>// $Module name: Sysinfo_Dialog
77705>>>>>// $Author     : VOO
77705>>>>>// Created     : 24-09-96 @ 18:47
77705>>>>>//
77705>>>>>// Description
77705>>>>>//    This object shows the systeminformation on the screen
77705>>>>>//
77705>>>>>// $Rev History
77705>>>>>//    24-09-96  Module header created
77705>>>>>//****************************************************************************
77705>>>>>Class SysInfoDialog Is A ModalPanel
77706>>>>>    Procedure Construct_Object
77708>>>>>        Forward Send Construct_Object
77710>>>>>
77710>>>>>        Set Label to C_$SystemInformation
77711>>>>>        Set Size to 140 267
77712>>>>>        Set piMinSize to 140 267
77713>>>>>        Set Locate_Mode To CENTER_ON_SCREEN
77714>>>>>        Set Border_Style to Border_Thick
77715>>>>>
77715>>>>>        Object oSysinfoDisplay Is A SysInfoDisplay
77717>>>>>            Set peAnchors to anAll
77718>>>>>        End_Object
77719>>>>>
77719>>>>>        Object oCloseButton Is A Button
77721>>>>>            Set Label To C_$Close
77722>>>>>            Set Location To 120 210
77723>>>>>            Set Message Item 0 To (Refproc (Close_Panel))
77724>>>>>            Set Default_State To True
77725>>>>>            Set peAnchors to anBottomRight
77726>>>>>        End_Object
77727>>>>>
77727>>>>>        On_Key kCancel Send Close_Panel
77728>>>>>    End_Procedure
77729>>>>>End_Class
77730>>>>>
77730>>>>>// Purpose:
77730>>>>>//
77730>>>>>// Ken Ross 12/17/96 5:16PM
77730>>>>>//
77730>>>>>Class AboutDialog Is A ModalPanel
77731>>>>>    Procedure Construct_Object
77733>>>>>        String sVdfRootDir
77733>>>>>
77733>>>>>        Forward Send Construct_Object
77735>>>>>
77735>>>>>        Set Label To C_$About
77736>>>>>        Set Size to 89 212
77737>>>>>        Set Locate_Mode To CENTER_ON_SCREEN
77738>>>>>
77738>>>>>        Object oSysInfoDialog Is A SysInfoDialog
77740>>>>>        End_Object
77741>>>>>
77741>>>>>        Object oBox Is A Container3d
77743>>>>>            Set Border_Style To Border_StaticEdge
77744>>>>>            Set Size to 63 202
77745>>>>>            Set Location To 4 5
77746>>>>>
77746>>>>>            Object oAboutGraphic Is A BitmapContainer
77748>>>>>                Set Border_Style To Border_None
77749>>>>>                Set Bitmap_Style To Bitmap_Center
77750>>>>>                Set Size To 48 48
77751>>>>>                Set Location To 7 2
77752>>>>>            End_Object
77753>>>>>
77753>>>>>            Object oProductName Is A TextBox
77755>>>>>                Set Label To C_$ProductName
77756>>>>>                Set Size To 10 45
77757>>>>>                Set Location To 8 53
77758>>>>>            End_Object
77759>>>>>
77759>>>>>            Object oVersion Is A TextBox
77761>>>>>                Set Label To C_$Version
77762>>>>>                Set Size To 10 25
77763>>>>>                Set Location To 21 53
77764>>>>>            End_Object
77765>>>>>
77765>>>>>            Object oCopyright Is A TextBox
77767>>>>>                Set Label To C_$Copyright
77768>>>>>                Set Size To 10 31
77769>>>>>                Set Location To 34 53
77770>>>>>            End_Object
77771>>>>>
77771>>>>>            Object oAuthor Is A TextBox
77773>>>>>                Set Label To C_$Author
77774>>>>>                Set Size To 10 22
77775>>>>>                Set Location To 46 53
77776>>>>>            End_Object
77777>>>>>        End_Object
77778>>>>>
77778>>>>>        Object oOKButton Is A Button
77780>>>>>            On_Item C_$OK Send Close_Panel
77781>>>>>            Set Size To 14 50
77782>>>>>            Set Location To 71 157
77783>>>>>        End_Object
77784>>>>>
77784>>>>>        Object oSysInfoButton Is A Button
77786>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
77787>>>>>            Set Size To 14 50
77788>>>>>            Set Location To 71 101
77789>>>>>        End_Object
77790>>>>>
77790>>>>>        On_Key Kcancel Send KeyAction Of oOKButton
77791>>>>>
77791>>>>>        Set Logo To "DacAbout.bmp"  // square bitmaps Of 42x42 work best
77792>>>>>    End_Procedure
77793>>>>>
77793>>>>>    Procedure Set ProductName String sProductName
77795>>>>>        Set Label Of oProductName To sProductName
77796>>>>>    End_Procedure
77797>>>>>
77797>>>>>    Procedure Set Version String sVersion
77799>>>>>        Set Label Of oVersion To sVersion
77800>>>>>    End_Procedure
77801>>>>>
77801>>>>>    Procedure Set Copyright string sCopyright
77803>>>>>        Set Label Of oCopyright To sCopyright
77804>>>>>    End_Procedure
77805>>>>>
77805>>>>>    Procedure Set Author String sAuthor
77807>>>>>        Set Label Of oAuthor To sAuthor
77808>>>>>    End_Procedure
77809>>>>>
77809>>>>>    Procedure Set Logo string sLogo
77811>>>>>        // square bitmaps Of 42x42 work best
77811>>>>>        Set Bitmap Of oAboutGraphic To sLogo
77812>>>>>    End_Procedure
77813>>>>>
77813>>>>>    Procedure Show_Sysinfo
77815>>>>>        Send Popup_Modal Of oSysinfoDialog
77816>>>>>    End_Procedure
77817>>>>>
77817>>>>>    Procedure End_Construct_Object
77819>>>>>        Handle hoVersionInfo
77819>>>>>        Boolean bIncluded
77819>>>>>        Integer iMajor iMinor iRelease iBuild
77819>>>>>        String sLabel
77819>>>>>
77819>>>>>        Get Label Of oVersion To sLabel
77820>>>>>        If (sLabel = C_$VERSION) Begin
77822>>>>>            // set it To the version info Of the program, if available
77822>>>>>            If (ghoApplication <> 0) Begin
77824>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
77825>>>>>                If (hoVersionInfo <> 0) Begin
77827>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
77828>>>>>                    If (bIncluded) Begin
77830>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
77831>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
77832>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
77833>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
77834>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sLabel
77835>>>>>                        Set Version to sLabel
77836>>>>>                    End
77836>>>>>>
77836>>>>>                End
77836>>>>>>
77836>>>>>            End
77836>>>>>>
77836>>>>>        End
77836>>>>>>
77836>>>>>
77836>>>>>        Forward Send End_Construct_Object
77838>>>>>    End_Procedure
77839>>>>>End_Class
77840>>>
77840>>>// *************************************************************************
77840>>>//  Public message. This is the default message. It is expected that you will
77840>>>//   create your own message to override this
77840>>>// *************************************************************************
77840>>>
77840>>>Procedure Activate_About
77843>>>   Send DoAbout "" "" "" "" ""
77844>>>End_Procedure
77845>>>
77845>>>// *************************************************************************
77845>>>//  Public message. It is expected that you will send this message (most
77845>>>//  likely from Activate_About. This creates an about object, activates it
77845>>>//  and destroys it when done. It is not exepected that you will augment this.
77845>>>// *************************************************************************
77845>>>
77845>>>Procedure DoAbout string sTitle string sVersion string sCopyRight string sAuthor string sBitmap
77848>>>        integer hoObj hoMain
77848>>>
77848>>>        // create object
77848>>>        Object About is an AboutDialog
77850>>>            // if no title passed use the label of the main panel
77850>>>            // (if a main panel exists).
77850>>>            if sTitle     eq '' Begin
77852>>>                Get Main_Window of desktop to hoMain
77853>>>                if hoMain Get Label of hoMain to sTitle
77856>>>            end
77856>>>>
77856>>>            set productname to sTitle
77857>>>            set version     to sVersion
77858>>>            set copyright   to sCopyRight
77859>>>            set author      to sAuthor
77860>>>            If sBitmap    ne '' ;               set logo to sBitMap // square bitmaps of 42x42 work best
77863>>>            Move self to hoObj // object Id
77864>>>        End_Object
77865>>>        Send Popup   of hoObj    // popup the about object
77866>>>        Send Destroy of hoObj // when done, it will be destroyed
77867>>>End_procedure
77868>        Use Views\exemplo.vw
Including file: Views\exemplo.vw    (C:\DataFlex Projects\GNRELibrary\AppSrc\Views\exemplo.vw)
77868>>>Use Windows.pkg
77868>>>Use DFClient.pkg
77868>>>Use Pacotes\GGGCriaAssinatura_Gratis.pkg
Including file: Pacotes\GGGCriaAssinatura_Gratis.pkg    (C:\DataFlex Projects\GNRELibrary\AppSrc\Pacotes\GGGCriaAssinatura_Gratis.pkg)
77868>>>>>//-------------------------------------------------------------------------------------------------
77868>>>>>// Pacote com fun‡äes para assinatura de plano atrav‚s do webservice do portal www.guiasgnre.com.br
77868>>>>>//-------------------------------------------------------------------------------------------------
77868>>>>>//
77868>>>>>//-------------------------------------------------------------------------------------------------
77868>>>>>// Autor .....: Alexandro Maule - Harsy Sistemas
77868>>>>>// Criado em..: 25/04/2016
77868>>>>>// VersÆo.....: 1.0.0
77868>>>>>// Hist¢rico de Altera‡äes: 
77868>>>>>// - 30/05/2016 - Adriano Rodrigues - Reformula‡Æo de toda a fun‡Æo devido mudan‡as 
77868>>>>>// no webservice.
77868>>>>>//
77868>>>>>//-------------------------------------------------------------------------------------------------
77868>>>>>// Parƒmetros
77868>>>>>// -tWstAssinatura - Dados necess rios para cria‡Æo da assinatura
77868>>>>>//-------------------------------------------------------------------------------------------------
77868>>>>>// Retorno: 
77868>>>>>// -tWStRetornoAssinatura: Retorna dados da assinatura, c¢digo e mensagem de retorno, e token API
77868>>>>>//-------------------------------------------------------------------------------------------------
77868>>>>>// Lista de c¢digos de retorno: 
77868>>>>>// 0 = Sucesso
77868>>>>>// 1 = Login nÆo ‚ um e-mail v lido.
77868>>>>>// 2 = Login em uso, tente outro.
77868>>>>>// 3 = Senha deve estar entre 6 e 10 d¡gitos.
77868>>>>>// 4 = RazÆo Social nÆo pode estar em branco.
77868>>>>>// 5 = Fantasia nÆo pode estar em branco.
77868>>>>>// 6 = Telefone deve estar entre 10 e 11 d¡gitos.
77868>>>>>// 7 = Cep deve conter 8 d¡gitos.
77868>>>>>// 8 = Logradouro nÆo pode estar em branco.
77868>>>>>// 9 = Nro nÆo pode ficar em branco, caso nao tenha n£mero no endere‡o, preencher com S/N.
77868>>>>>// 10 = Bairro nÆo pode estar em branco.
77868>>>>>// 11 = C¢digo da UF ‚ inv lido.
77868>>>>>// 12 = C¢digo do Munic¡pio ‚ inv lido.
77868>>>>>// 13 = Telefone cont‚m dig¡tos nÆo num‚ricos.
77868>>>>>// 14 = CEP cont‚m dig¡tos nÆo num‚ricos.
77868>>>>>// 15 = CNPJ ‚ inv lido.
77868>>>>>// 16 = CNPJ em uso por outra assinatura.
77868>>>>>// 17 = Nome do respons vel pela assinatura nÆo pode estar em branco.
77868>>>>>// 18 = Erro ao gravar a conta do usu rio.
77868>>>>>// 19 = Erro ao gravar os dados da empresa.
77868>>>>>// 20 = Erro ao criar a assinatura na forma de pagamento gr tis.
77868>>>>>//-------------------------------------------------------------------------------------------------
77868>>>>>
77868>>>>>Use Pacotes\cWSGeraGuiaGnre.pkg
Including file: Pacotes\cWSGeraGuiaGnre.pkg    (C:\DataFlex Projects\GNRELibrary\AppSrc\Pacotes\cWSGeraGuiaGnre.pkg)
77868>>>>>>>// cWSGeraGuiaGnre.pkg
77868>>>>>>>// Class:   cWSGeraGuiaGnre
77868>>>>>>>// Created: 20/06/2016 10:38:32
77868>>>>>>>// 
77868>>>>>>>
77868>>>>>>>use cClientWebService.pkg
Including file: cClientWebService.pkg    (C:\Program Files (x86)\DataFlex 18.1\Pkg\cClientWebService.pkg)
77868>>>>>>>>>Use Flexml.pkg
Including file: Flexml.pkg    (C:\Program Files (x86)\DataFlex 18.1\Pkg\Flexml.pkg)
77868>>>>>>>>>>>//****************************************************************************************
77868>>>>>>>>>>>//                                                                                       *
77868>>>>>>>>>>>//  FLEXML.PKG                                                                            *
77868>>>>>>>>>>>//                                                                                       *
77868>>>>>>>>>>>//  Interface package for FLEXML.DLL - extension system for Extensible Markup Language.  *
77868>>>>>>>>>>>//                                                                                       *
77868>>>>>>>>>>>//  Written by Michael Gouker, 7/31/99                                                   *
77868>>>>>>>>>>>// 12/19/2000 JJT - Major revision changes for VDF7/SP2.                                 *
77868>>>>>>>>>>>//                                                                                       *
77868>>>>>>>>>>>//****************************************************************************************
77868>>>>>>>>>>>Use LanguageText.pkg
77868>>>>>>>>>>>Use Windows.pkg
77868>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
77868>>>>>>>>>>>
77868>>>>>>>>>>>
77868>>>>>>>>>>>// Used to designate that a handle is a handle to an Xml Dom object. This
77868>>>>>>>>>>>// is used/required by server web-services but could be used elsewhere .
77868>>>>>>>>>>>
77868>>>>>>>>>>>
77868>>>>>>>>>>>// Types of Nodes
77868>>>>>>>>>>>
77868>>>>>>>>>>>
77868>>>>>>>>>>>// classes and methods defined in fmac
77868>>>>>>>>>>>
77868>>>>>>>>>>>
77868>>>>>>>>>>>Register_Function transformNode Integer infcXSLNode Returns String
77868>>>>>>>>>>>
77868>>>>>>>>>>>
77868>>>>>>>>>>>
77868>>>>>>>>>>>
77868>>>>>>>>>>>
77868>>>>>>>>>>>
77868>>>>>>>>>>>
77868>>>>>>>>>>>
77868>>>>>>>>>>>
77868>>>>>>>>>>>// XML function & procedure registration
77868>>>>>>>>>>>
77868>>>>>>>>>>>Register_Procedure Set XmlInterface Integer iHandle
77868>>>>>>>>>>>Register_Function XmlInterface Returns Integer
77868>>>>>>>>>>>
77868>>>>>>>>>>>// NODE Properties
77868>>>>>>>>>>>Register_Function phAttributes Returns Integer
77868>>>>>>>>>>>Register_Function psBaseName Returns String
77868>>>>>>>>>>>Register_Function phChildNodes Returns Integer
77868>>>>>>>>>>>Register_Function phDefinition Returns Integer
77868>>>>>>>>>>>Register_Function phFirstChild Returns Integer
77868>>>>>>>>>>>Register_Function phLastChild Returns Integer
77868>>>>>>>>>>>Register_Function phNextSibling Returns Integer
77868>>>>>>>>>>>Register_Function psNameSpaceURI Returns String
77868>>>>>>>>>>>Register_Function psNodeName Returns String
77868>>>>>>>>>>>Register_Function piNodeType Returns Integer
77868>>>>>>>>>>>Register_Function psNodeTypeString Returns String
77868>>>>>>>>>>>Register_Function phOwnerDocument Returns Integer
77868>>>>>>>>>>>Register_Function phParentNode Returns Integer
77868>>>>>>>>>>>Register_Function pbParsed Returns Integer
77868>>>>>>>>>>>Register_Function psPrefix Returns String
77868>>>>>>>>>>>Register_Function phPreviousSibling Returns Integer
77868>>>>>>>>>>>Register_Function pbSpecified Returns Integer
77868>>>>>>>>>>>Register_Function psText Returns String
77868>>>>>>>>>>>Register_Procedure Set psText String sText
77868>>>>>>>>>>>Register_Function psXML Returns String
77868>>>>>>>>>>>
77868>>>>>>>>>>>// Node Read write properties
77868>>>>>>>>>>>
77868>>>>>>>>>>>Register_Procedure Set psDataType String sTypeName
77868>>>>>>>>>>>Register_Function psDataType Returns String
77868>>>>>>>>>>>Register_Procedure Set pvNodeTypedValue Integer iType Integer iAddress
77868>>>>>>>>>>>Register_Function pvNodeTypedValue Integer iType Returns Integer  // address of data
77868>>>>>>>>>>>Register_Procedure Set psNodeValue String sValue
77868>>>>>>>>>>>Register_Function psNodeValue Returns String
77868>>>>>>>>>>>
77868>>>>>>>>>>>// Node Methods
77868>>>>>>>>>>>
77868>>>>>>>>>>>Register_Function AppendChild Integer iChildInfc Returns Integer
77868>>>>>>>>>>>Register_Function CloneInfcNode Integer bRecurse Returns Integer
77868>>>>>>>>>>>Register_Function HasChildNodes Returns Integer
77868>>>>>>>>>>>Register_Function InsertBefore Integer infcNodeToInsert Integer iWhere Returns Integer
77868>>>>>>>>>>>Register_Function RemoveChild Integer iChildToRemove Returns Integer
77868>>>>>>>>>>>Register_Function ReplaceChild Integer iNewChild Integer iChildToReplace Returns Integer
77868>>>>>>>>>>>Register_Function SelectNodes String selectstring Returns Integer
77868>>>>>>>>>>>Register_Function SelectSingleNode String selectstring Returns Integer
77868>>>>>>>>>>>
77868>>>>>>>>>>>// Node Collections
77868>>>>>>>>>>>// READONLY PROPERTIES
77868>>>>>>>>>>>
77868>>>>>>>>>>>Register_Function phItem Integer iItem Returns Integer
77868>>>>>>>>>>>Register_Function phElementItem Integer iItem Returns Integer
77868>>>>>>>>>>>
77868>>>>>>>>>>>Register_Function piLength Returns Integer
77868>>>>>>>>>>>
77868>>>>>>>>>>>//*     GET_ENUMNODELIST                  */  typ_p1_int | qt_int | out_two,
77868>>>>>>>>>>>//*     GET_RESET                         */  qt_int | out_one,
77868>>>>>>>>>>>
77868>>>>>>>>>>>// Named Node Map
77868>>>>>>>>>>>
77868>>>>>>>>>>>//*     GET_NAMEDITEM                     */  typ_p1_str | qt_int | out_two,
77868>>>>>>>>>>>
77868>>>>>>>>>>>Register_Function NamedItem String sName Returns Integer
77868>>>>>>>>>>>Register_Function QualifiedItem String sBaseName String sNameSpace Returns Integer
77868>>>>>>>>>>>Register_Function RemoveNamedItem String sName Returns Integer
77868>>>>>>>>>>>Register_Function RemoveQualifiedItem String sBaseName String sNameSpace Returns Integer
77868>>>>>>>>>>>Register_Function SetNamedItem Integer iInterface Returns Integer
77868>>>>>>>>>>>
77868>>>>>>>>>>>// XML DOM Document
77868>>>>>>>>>>>// Read only properties
77868>>>>>>>>>>>
77868>>>>>>>>>>>Register_Function phDocType Returns Integer
77868>>>>>>>>>>>Register_Function phImplementation Returns Integer
77868>>>>>>>>>>>Register_Function phParseError Returns Integer
77868>>>>>>>>>>>Register_Function piReadyState Returns Integer
77868>>>>>>>>>>>Register_Function psURL Returns String
77868>>>>>>>>>>>
77868>>>>>>>>>>>// Read Write Properties
77868>>>>>>>>>>>
77868>>>>>>>>>>>Register_Procedure Set pbAsync Integer bValue
77868>>>>>>>>>>>Register_Function pbAsync Returns Integer
77868>>>>>>>>>>>Register_Procedure Set phDocumentElement Integer iElement
77868>>>>>>>>>>>Register_Function phDocumentElement Returns Integer
77868>>>>>>>>>>>Register_Procedure Set pbPreserveWhiteSpace Integer bValue
77868>>>>>>>>>>>Register_Function pbPreserveWhiteSpace Returns Integer
77868>>>>>>>>>>>Register_Procedure Set pbResolveExternals Integer bValue
77868>>>>>>>>>>>Register_Function pbResolveExternals Returns Integer
77868>>>>>>>>>>>Register_Procedure Set pbValidateOnParse Integer bValue
77868>>>>>>>>>>>Register_Function pbValidateOnParse Returns Integer
77868>>>>>>>>>>>
77868>>>>>>>>>>>// Events
77868>>>>>>>>>>>
77868>>>>>>>>>>>// Methods
77868>>>>>>>>>>>
77868>>>>>>>>>>>Register_Function Abort Returns Integer
77868>>>>>>>>>>>Register_Function ElementsByTagName String sTagName Returns Integer
77868>>>>>>>>>>>Register_Function LoadDocument String sURLName Returns Integer
77868>>>>>>>>>>>Register_Function LoadXML String sXMLText Returns Integer
77868>>>>>>>>>>>Register_Function NodeFromID String sNodeName Returns Integer
77868>>>>>>>>>>>Register_Function SaveDocument String sURLName Returns Integer
77868>>>>>>>>>>>
77868>>>>>>>>>>>// Parse Error
77868>>>>>>>>>>>// Read Only Properties
77868>>>>>>>>>>>
77868>>>>>>>>>>>Register_Function piErrorCode Returns Integer
77868>>>>>>>>>>>Register_Function piFilePos Returns Integer
77868>>>>>>>>>>>Register_Function piLine Returns Integer
77868>>>>>>>>>>>Register_Function piLinePos Returns Integer
77868>>>>>>>>>>>Register_Function psReason Returns String
77868>>>>>>>>>>>Register_Function psSrcText Returns String
77868>>>>>>>>>>>Register_Function psURL Returns String
77868>>>>>>>>>>>
77868>>>>>>>>>>>// DOM Implementation
77868>>>>>>>>>>>// Method
77868>>>>>>>>>>>
77868>>>>>>>>>>>Register_Function HasFeature String sSystem String sFeature Returns Integer
77868>>>>>>>>>>>
77868>>>>>>>>>>>// Methods
77868>>>>>>>>>>>
77868>>>>>>>>>>>Register_Function substringData Integer iOffset Integer iCount Returns String
77868>>>>>>>>>>>Register_Function appendData String sData Returns Integer
77868>>>>>>>>>>>Register_Function insertData Integer iOffset String sData Returns Integer
77868>>>>>>>>>>>Register_Function deleteData Integer iOffset Integer iCount Returns Integer
77868>>>>>>>>>>>Register_Function replaceData Integer iOffset Integer iCount String sData Returns Integer
77868>>>>>>>>>>>
77868>>>>>>>>>>>// Attributes
77868>>>>>>>>>>>
77868>>>>>>>>>>>Register_Function psName Returns String
77868>>>>>>>>>>>
77868>>>>>>>>>>>// Elements
77868>>>>>>>>>>>// Read Only properties
77868>>>>>>>>>>>
77868>>>>>>>>>>>Register_Function psTagName Returns String
77868>>>>>>>>>>>
77868>>>>>>>>>>>// Methods
77868>>>>>>>>>>>
77868>>>>>>>>>>>Register_Procedure Set attributeValue String sName String sValue
77868>>>>>>>>>>>Register_Function attributeValue String sName Returns String
77868>>>>>>>>>>>Register_Function removeAttribute String sName Returns Integer
77868>>>>>>>>>>>Register_Function attributeNode String sName Returns Integer
77868>>>>>>>>>>>Register_Procedure Set attributeNode Integer iNode Returns Integer
77868>>>>>>>>>>>Register_Function removeAttributeNode Integer iNode Returns Integer
77868>>>>>>>>>>>
77868>>>>>>>>>>>// DOM Text
77868>>>>>>>>>>>// Methods
77868>>>>>>>>>>>
77868>>>>>>>>>>>Register_Function splitText Integer iOffset Returns Integer
77868>>>>>>>>>>>
77868>>>>>>>>>>>// DOM Processing Instruction
77868>>>>>>>>>>>// Read Only Properties
77868>>>>>>>>>>>Register_Function psTarget Returns String
77868>>>>>>>>>>>
77868>>>>>>>>>>>// DOM Document Type
77868>>>>>>>>>>>
77868>>>>>>>>>>>Register_Function phEntities Returns Integer
77868>>>>>>>>>>>Register_Function phNotations Returns Integer
77868>>>>>>>>>>>
77868>>>>>>>>>>>// DOM Notations
77868>>>>>>>>>>>
77868>>>>>>>>>>>Register_Function psPublicID Returns String
77868>>>>>>>>>>>Register_Function psSystemID Returns String
77868>>>>>>>>>>>Register_Function psNotationName Returns String
77868>>>>>>>>>>>
77868>>>>>>>>>>>// create nodes
77868>>>>>>>>>>>
77868>>>>>>>>>>>Register_Function createAttribute String sName Returns Integer
77868>>>>>>>>>>>Register_Function createCDataSection String sValue Returns Integer
77868>>>>>>>>>>>Register_Function createComment String sValue Returns Integer
77868>>>>>>>>>>>Register_Function createDocumentFragment Returns Integer
77868>>>>>>>>>>>Register_Function createElement String sTagName Returns Integer
77868>>>>>>>>>>>Register_Function createEntityReference String sEntityName Returns Integer
77868>>>>>>>>>>>Register_Function createNode Integer iNodeType String sName String sNameSpace Returns Integer
77868>>>>>>>>>>>Register_Function createProcessingInstruction String sTarget String sData Returns Integer
77868>>>>>>>>>>>Register_Function createTextNode String sData Returns Integer
77868>>>>>>>>>>>
77868>>>>>>>>>>>Register_Function ChangeNodeType Integer iTypeOfNode Integer bSetInterface Returns Integer
77868>>>>>>>>>>>
77868>>>>>>>>>>>
77868>>>>>>>>>>>// ******************************************************************************
77868>>>>>>>>>>>//
77868>>>>>>>>>>>//          Part 1:  Base Document Logic Specialized For Templates
77868>>>>>>>>>>>//
77868>>>>>>>>>>>// ******************************************************************************
77868>>>>>>>>>>>
77868>>>>>>>>>>>//
77868>>>>>>>>>>>//  XML Collections
77868>>>>>>>>>>>//
77868>>>>>>>>>>>//  Collection mixin has common functions to both node lists and named node maps
77868>>>>>>>>>>>//
77868>>>>>>>>>>>
77868>>>>>>>>>>>// This provides functions required of all XMLDOM objects.
77868>>>>>>>>>>>//
77868>>>>>>>>>>>Class cXMLDOMMixin is a Mixin
77869>>>>>>>>>>>
77869>>>>>>>>>>>    // Create an XML object of passed class Id and bind passed interface. returns
77869>>>>>>>>>>>    // the object handle. All dynamic XML object can be created using this syntax
77869>>>>>>>>>>>
77869>>>>>>>>>>>    Function CreateXMLObject Integer iClassId Integer hinfXMLInterface Returns Handle
77871>>>>>>>>>>>        Handle hoId hoDocument
77871>>>>>>>>>>>        // We will always create objects at the DOMDocument level.
77871>>>>>>>>>>>        Get DocumentObject to hoDocument
77872>>>>>>>>>>>        If (hoDocument=0) Begin  // this should never happen.
77874>>>>>>>>>>>            Error DFERR_XML_INTERNAL_ERROR C_$XmlFailedNoDocObject
77875>>>>>>>>>>>>
77875>>>>>>>>>>>            Function_Return 0
77876>>>>>>>>>>>        End
77876>>>>>>>>>>>>
77876>>>>>>>>>>>        If hinfXMLInterface Begin
77878>>>>>>>>>>>            Get Create of hoDocument iClassId to hoID
77879>>>>>>>>>>>            Set XMLInterface of hoID to hinfXMLInterface
77880>>>>>>>>>>>        End
77880>>>>>>>>>>>>
77880>>>>>>>>>>>        Function_Return hoID
77881>>>>>>>>>>>    End_Function
77882>>>>>>>>>>>
77882>>>>>>>>>>>    // create an XML Node object based on the interface type.
77882>>>>>>>>>>>    // this will convert the interface to the proper type and will create
77882>>>>>>>>>>>    // an appropriate DF object.
77882>>>>>>>>>>>    // This requires that a DocumentObject exists
77882>>>>>>>>>>>
77882>>>>>>>>>>>    Function CreateXMLNode Handle hinfc Returns Handle
77884>>>>>>>>>>>        Integer hoNode iType iClassId
77884>>>>>>>>>>>        Handle  hoDocument
77884>>>>>>>>>>>        // Get the node type of the infc handle w/o creating a DF object
77884>>>>>>>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_piNodeType, hinfc, 0, 0, 0, 0)) to iType
77885>>>>>>>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_ChangeNodeType, hinfc, iType, 1, 0, 0)) to hInfc
77886>>>>>>>>>>>        If (hinfc=0) Begin
77888>>>>>>>>>>>            // this should not happen and we would need to know about this.
77888>>>>>>>>>>>            Error DFERR_XML_INTERNAL_ERROR (C_$XmlFailedNoDocObject + String(iType))
77889>>>>>>>>>>>>
77889>>>>>>>>>>>            Function_Return 0
77890>>>>>>>>>>>        End
77890>>>>>>>>>>>>
77890>>>>>>>>>>>        Get DocumentObject to hoDocument
77891>>>>>>>>>>>        // you can augment your class IDs in a single place.
77891>>>>>>>>>>>        Get NodeClassId of hoDocument iType to iClassId
77892>>>>>>>>>>>        // MG: 12/6/00 Changed to create nodes inside of the document object.
77892>>>>>>>>>>>        Get CreateXMLObject of hoDocument iClassId hinfc to hoNode
77893>>>>>>>>>>>
77893>>>>>>>>>>>        Function_Return hoNode
77894>>>>>>>>>>>    End_Function
77895>>>>>>>>>>>
77895>>>>>>>>>>>
77895>>>>>>>>>>>    // Change object's class. This let's you change the class id of an object
77895>>>>>>>>>>>    // on an object by object basis. This would let you create nodes (e.g. elements)
77895>>>>>>>>>>>    // that have a custom interface for each node type. Normally, this would be sent
77895>>>>>>>>>>>    // after a node has been created using one of the default classes
77895>>>>>>>>>>>    Function ChangeNodeClass Integer hoNode Integer iClassID Returns Handle
77897>>>>>>>>>>>        Integer iType
77897>>>>>>>>>>>        Handle  hinfcNew
77897>>>>>>>>>>>        Get piNodeType of hoNode to iType
77898>>>>>>>>>>>        Get ChangeNodeType of hoNode iType False to hInfcNew
77899>>>>>>>>>>>        Send Destroy to hoNode // destroy object and old infc handle.
77900>>>>>>>>>>>        Get CreateXMLObject iClassId hinfcNew to hoNode
77901>>>>>>>>>>>        Function_Return hoNode
77902>>>>>>>>>>>    End_Function
77903>>>>>>>>>>>
77903>>>>>>>>>>>End_Class
77904>>>>>>>>>>>
77904>>>>>>>>>>>
77904>>>>>>>>>>>Class cXMLDOMCollectionMixin is a Mixin
77905>>>>>>>>>>>
77905>>>>>>>>>>>    Import_Class_Protocol cXMLDOMMixin
77906>>>>>>>>>>>
77906>>>>>>>>>>>    //  Returns number of items in the collection
77906>>>>>>>>>>>    //
77906>>>>>>>>>>>    Function NodeListLength Returns Integer
77908>>>>>>>>>>>        Integer iLength
77908>>>>>>>>>>>        Get piLength to iLength
77909>>>>>>>>>>>        Function_Return iLength
77910>>>>>>>>>>>    End_Function
77911>>>>>>>>>>>
77911>>>>>>>>>>>    // Returns an XML node object for pass item
77911>>>>>>>>>>>    //
77911>>>>>>>>>>>    Function CollectionNode Integer I Returns Handle
77913>>>>>>>>>>>        Integer hoNewNode
77913>>>>>>>>>>>        Integer infcItem
77913>>>>>>>>>>>        Get phItem i to infcItem
77914>>>>>>>>>>>        If (infcItem) ;            Get CreateXMLNode infcItem to hoNewNode
77917>>>>>>>>>>>        Function_Return hoNewNode
77918>>>>>>>>>>>    End_Function
77919>>>>>>>>>>>
77919>>>>>>>>>>>
77919>>>>>>>>>>>End_Class
77920>>>>>>>>>>>
77920>>>>>>>>>>>// Simple declarations of collections.
77920>>>>>>>>>>>
77920>>>>>>>>>>>Class cXMLDOMNodeList is a BaseXmlDomNodeList
77921>>>>>>>>>>>    Import_Class_Protocol cXMLDOMCollectionMixin
77922>>>>>>>>>>>End_Class
77923>>>>>>>>>>>
77923>>>>>>>>>>>Class cXMLDOMNamedNodeMap is a BaseXmlDomNamedNodeMap
77924>>>>>>>>>>>
77924>>>>>>>>>>>    Import_Class_Protocol cXMLDOMCollectionMixin
77925>>>>>>>>>>>
77925>>>>>>>>>>>    // returns a node attribute that matches passed name, zero if none
77925>>>>>>>>>>>    Function NamedNode String sName Returns Handle
77927>>>>>>>>>>>        Integer hoNewNode
77927>>>>>>>>>>>        Integer infcItem
77927>>>>>>>>>>>        Get NamedItem sName to infcItem
77928>>>>>>>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
77931>>>>>>>>>>>        Function_Return hoNewNode
77932>>>>>>>>>>>    End_Function
77933>>>>>>>>>>>
77933>>>>>>>>>>>    // Adds or changes a node attribute
77933>>>>>>>>>>>    // This should return the passed object Id which is now bound to the attribute. If an error, returns 0
77933>>>>>>>>>>>    Function SetNamedNode Handle hoNode Returns Handle
77935>>>>>>>>>>>        Integer hinfcNode hinfcItem
77935>>>>>>>>>>>        Get XMLInterface of hoNode to hinfcNode // node of passed attribute
77936>>>>>>>>>>>        Get SetNamedItem hinfcNode to hinfcItem
77937>>>>>>>>>>>        If hinfcItem ;            Set XMLInterface of hoNode to hinfcItem
77940>>>>>>>>>>>        Else ;            Move 0 to hoNode // zero indicates error
77942>>>>>>>>>>>        Function_Return hoNode
77943>>>>>>>>>>>    End_Function
77944>>>>>>>>>>>
77944>>>>>>>>>>>    // removes named attribute, Returns handle of removed node or zero if not found.
77944>>>>>>>>>>>    // Note that returned object must be disposed of or moved somewhere else.
77944>>>>>>>>>>>    Function RemoveNamedNode String sName Returns Handle
77946>>>>>>>>>>>        Integer hoNewNode
77946>>>>>>>>>>>        Integer infcItem
77946>>>>>>>>>>>        Get RemoveNamedItem sName to infcItem
77947>>>>>>>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
77950>>>>>>>>>>>        Function_Return hoNewNode
77951>>>>>>>>>>>    End_Function
77952>>>>>>>>>>>
77952>>>>>>>>>>>    Function QualifiedNode String sNameSpace String sBaseName Returns Handle
77954>>>>>>>>>>>        Integer hoNewNode
77954>>>>>>>>>>>        Integer infcItem
77954>>>>>>>>>>>        Get QualifiedItem  sBaseName sNameSpace  to infcItem
77955>>>>>>>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
77958>>>>>>>>>>>        Function_Return hoNewNode
77959>>>>>>>>>>>    End_Function
77960>>>>>>>>>>>
77960>>>>>>>>>>>    Function RemoveQualifiedNode String sNameSpace String sBaseName Returns Handle
77962>>>>>>>>>>>        Integer hoNewNode
77962>>>>>>>>>>>        Integer infcItem
77962>>>>>>>>>>>        Get RemoveQualifiedItem sBaseName sNameSpace to infcItem
77963>>>>>>>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
77966>>>>>>>>>>>        Function_Return hoNewNode
77967>>>>>>>>>>>    End_Function
77968>>>>>>>>>>>
77968>>>>>>>>>>>End_Class
77969>>>>>>>>>>>
77969>>>>>>>>>>>
77969>>>>>>>>>>>
77969>>>>>>>>>>>// Mixin for nodes.
77969>>>>>>>>>>>//
77969>>>>>>>>>>>//  First the declaration of functions that have no object references.
77969>>>>>>>>>>>//
77969>>>>>>>>>>>
77969>>>>>>>>>>>
77969>>>>>>>>>>>Class cXMLDOMNodeMixin is a Mixin
77970>>>>>>>>>>>
77970>>>>>>>>>>>    Import_Class_Protocol cXMLDOMMixin
77971>>>>>>>>>>>
77971>>>>>>>>>>>    //  Append Node to the end of list. Returns passed Object handle if Ok, 0 if error
77971>>>>>>>>>>>
77971>>>>>>>>>>>    Function AppendNode Handle hoNode Returns Handle
77973>>>>>>>>>>>        Integer hoNewTextNode
77973>>>>>>>>>>>        Integer hinfcNode
77973>>>>>>>>>>>        Integer infcReturned
77973>>>>>>>>>>>        // Get COM Interface to call Append child.
77973>>>>>>>>>>>        Get XMLInterface of hoNode to hinfcNode
77974>>>>>>>>>>>        If (hinfcNode=0) Function_Return 0
77977>>>>>>>>>>>        Get AppendChild hinfcNode to infcReturned
77978>>>>>>>>>>>        // Interface returned is stored in DataFlex object.
77978>>>>>>>>>>>        If (infcReturned=0) Function_Return 0
77981>>>>>>>>>>>        Set XMLInterface of hoNode to infcReturned
77982>>>>>>>>>>>        Function_Return hoNode
77983>>>>>>>>>>>    End_Function
77984>>>>>>>>>>>
77984>>>>>>>>>>>    //  Insert NewNode before Node. Returns passed newnode Object handle if Ok, 0 if error
77984>>>>>>>>>>>
77984>>>>>>>>>>>    Function InsertBeforeNode Integer hoNewNode Integer hoNode Returns Handle
77986>>>>>>>>>>>        Integer hinfcNewNode hinfcNode iType hoRefNode
77986>>>>>>>>>>>        Integer infcReturned
77986>>>>>>>>>>>        // DOM says if no refnode argument passed or it is 0, append to end
77986>>>>>>>>>>>        If (Num_Arguments=1) ;            Move 0 to hoRefNode
77989>>>>>>>>>>>        Else ;            Move hoNode to hoRefNode
77991>>>>>>>>>>>        Get XMLInterface of hoNewNode to hinfcNewNode
77992>>>>>>>>>>>        If (hinfcNewNode=0) Function_Return 0
77995>>>>>>>>>>>        If hoRefNode Begin
77997>>>>>>>>>>>            Get XMLInterface of hoRefNode to hinfcNode
77998>>>>>>>>>>>            If (hinfcNode=0) Function_Return 0
78001>>>>>>>>>>>        End
78001>>>>>>>>>>>>
78001>>>>>>>>>>>        Get InsertBefore hinfcNewNode hinfcNode to infcReturned
78002>>>>>>>>>>>        If (infcReturned=0) Function_Return 0
78005>>>>>>>>>>>        // Interface returned is stored in DataFlex object.
78005>>>>>>>>>>>        Set XMLInterface of hoNewNode to infcReturned
78006>>>>>>>>>>>        Function_Return hoNewNode
78007>>>>>>>>>>>    End_Function
78008>>>>>>>>>>>
78008>>>>>>>>>>>    //  Remove Node. Returns object Id of removed node, zero if error
78008>>>>>>>>>>>    //  Important: The node is not destroyed! This lets you move it elsewhere if you want
78008>>>>>>>>>>>
78008>>>>>>>>>>>    Function RemoveNode Integer hoNode Returns Handle
78010>>>>>>>>>>>        Integer hInfcNode
78010>>>>>>>>>>>        Get XMLInterface of hoNode to hInfcNode
78011>>>>>>>>>>>        If (hinfcNode=0) Function_Return 0
78014>>>>>>>>>>>        Get RemoveChild hInfcNode to hinfcNode
78015>>>>>>>>>>>        If (hinfcNode=0) Function_Return 0
78018>>>>>>>>>>>        Set XMLInterface of hoNode to hinfcNode
78019>>>>>>>>>>>        Function_Return hoNode
78020>>>>>>>>>>>    End_Function
78021>>>>>>>>>>>
78021>>>>>>>>>>>    //  Replace Node. Returns object Id of replaced node, zero if error
78021>>>>>>>>>>>    //  Important: The replaced node is not destroyed! This lets you move it elsewhere if you want
78021>>>>>>>>>>>
78021>>>>>>>>>>>    Function ReplaceNode Integer hoNewNode Integer hoNodeToReplace Returns Handle
78023>>>>>>>>>>>        Integer hInfcNewNode hinfcNodetoReplace hinfcNode
78023>>>>>>>>>>>        Get XMLInterface of hoNewNode       to hInfcNewNode
78024>>>>>>>>>>>        Get XMLInterface of hoNodetoReplace to hInfcNodetoreplace
78025>>>>>>>>>>>        If (hinfcNewNode=0 or hInfcNodeToReplace=0) Function_Return 0
78028>>>>>>>>>>>        Get ReplaceChild hInfcNewNode hinfcNodeToReplace to hinfcNode
78029>>>>>>>>>>>        If (hinfcNode=0) Function_Return 0
78032>>>>>>>>>>>        Set XMLInterface of hoNodetoReplace to hinfcNode
78033>>>>>>>>>>>        Function_Return hoNodetoReplace
78034>>>>>>>>>>>    End_Function
78035>>>>>>>>>>>
78035>>>>>>>>>>>    // Remove the named node. Returns handle to removed node. You must destroy
78035>>>>>>>>>>>    // or move this removed object as needed
78035>>>>>>>>>>>
78035>>>>>>>>>>>    Function RemoveNamedNode String sQueryString Returns Handle
78037>>>>>>>>>>>        Integer hoNode
78037>>>>>>>>>>>        Integer hInfcTemplate hinfcNode
78037>>>>>>>>>>>        Get SelectSingleNode sQueryString to hinfcTemplate
78038>>>>>>>>>>>        If (hinfcTemplate) Begin
78040>>>>>>>>>>>            // Remove child returns an interface to the disassociated node.
78040>>>>>>>>>>>            // It should be disposed by setting it to an object and then calling destroy
78040>>>>>>>>>>>            Get RemoveChild hInfcTemplate to hInfcNode
78041>>>>>>>>>>>            If hInfcNode Get CreateXMLNode hinfcNode to hoNode
78044>>>>>>>>>>>        End
78044>>>>>>>>>>>>
78044>>>>>>>>>>>        Function_Return hoNode
78045>>>>>>>>>>>    End_Function
78046>>>>>>>>>>>
78046>>>>>>>>>>>    // This function creates a clone of the passed Node. if bRecurse all child nodes are also
78046>>>>>>>>>>>    // cloned. The object Id of the new clone object is returned.
78046>>>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
78046>>>>>>>>>>>    // the node to the XML Document.
78046>>>>>>>>>>>
78046>>>>>>>>>>>    Function CloneNode Integer bRecurse Returns Handle
78048>>>>>>>>>>>        Handle hoNewNode
78048>>>>>>>>>>>        Handle hinfcNewNode
78048>>>>>>>>>>>        Get CloneInfcNode (If(bRecurse,-1,0)) to hinfcNewNode
78049>>>>>>>>>>>        If hinfcNewNode ;            Get CreateXMLNode hinfcNewNode to hoNewNode
78052>>>>>>>>>>>        Function_Return hoNewNode
78053>>>>>>>>>>>    End_Function
78054>>>>>>>>>>>
78054>>>>>>>>>>>    //  Create a collection of all nodes. returns handle of a cXMLDomNodeList
78054>>>>>>>>>>>
78054>>>>>>>>>>>    Function ChildNodes Returns Handle
78056>>>>>>>>>>>        Integer infcNodeList
78056>>>>>>>>>>>        Integer hoNodeList
78056>>>>>>>>>>>        Get phChildNodes to infcNodeList
78057>>>>>>>>>>>        If (infcNodeList) ;            Get CreateXMLObject U_cXMLDOMNodeList infcNodeList to hoNodeList
78060>>>>>>>>>>>        Function_Return hoNodeList
78061>>>>>>>>>>>    End_Function
78062>>>>>>>>>>>
78062>>>>>>>>>>>    //  Create a collection of all attributes. returns handle of a cXMLDomNodeMapList
78062>>>>>>>>>>>
78062>>>>>>>>>>>    Function AttributeNodes Returns Handle
78064>>>>>>>>>>>        Integer hoCollectionId   // Object to hold collection
78064>>>>>>>>>>>        Integer hinfcAttributes  // XML Interface for collection
78064>>>>>>>>>>>        Get phAttributes to hinfcAttributes
78065>>>>>>>>>>>        If (hinfcAttributes) ;            Get CreateXMLObject U_cXMLDOMNamedNodeMap hinfcAttributes to hoCollectionId
78068>>>>>>>>>>>        Function_Return hoCollectionId
78069>>>>>>>>>>>    End_Function
78070>>>>>>>>>>>    
78070>>>>>>>>>>>    //  Create a collection of all attributes for the temporary attribute node object.
78070>>>>>>>>>>>    //  Using this saves a small amount of time creating and destroying this object but
78070>>>>>>>>>>>    //  it must be used with care. This binding is temporary!
78070>>>>>>>>>>>    Function TempAttributeNodes Returns Handle
78072>>>>>>>>>>>        Handle hoCollectionId hoDocument
78072>>>>>>>>>>>        Handle hinfcAttributes  // XML Interface for collection
78072>>>>>>>>>>>        Get phAttributes to hinfcAttributes
78073>>>>>>>>>>>        If (hinfcAttributes) Begin
78075>>>>>>>>>>>            Get DocumentObject to hoDocument
78076>>>>>>>>>>>            Get phoTempDomNodeMap of hoDocument to hoCollectionId
78077>>>>>>>>>>>            Set XMLInterface of hoCollectionId to hinfcAttributes
78078>>>>>>>>>>>        End
78078>>>>>>>>>>>>
78078>>>>>>>>>>>        Function_Return hoCollectionId
78079>>>>>>>>>>>    End_Function
78080>>>>>>>>>>>    
78080>>>>>>>>>>>
78080>>>>>>>>>>>    // Returns a collection of just elements
78080>>>>>>>>>>>
78080>>>>>>>>>>>    Function ElementNodes String sQueryString Returns Handle
78082>>>>>>>>>>>        Integer hoNodeList
78082>>>>>>>>>>>        Integer hinfcNodeList
78082>>>>>>>>>>>        Get ElementsByTagName sQueryString to hinfcNodeList
78083>>>>>>>>>>>        If (hinfcNodeList <> 0) ;            Get CreateXMLObject U_cXMLDOMNodeList hinfcNodeList to hoNodeList
78086>>>>>>>>>>>        Function_Return hoNodeList
78087>>>>>>>>>>>    End_Function
78088>>>>>>>>>>>
78088>>>>>>>>>>>
78088>>>>>>>>>>>
78088>>>>>>>>>>>    // Return object handle for query.
78088>>>>>>>>>>>
78088>>>>>>>>>>>    Function FindNode String sQueryString Returns Handle
78090>>>>>>>>>>>        Integer hoNode
78090>>>>>>>>>>>        Integer hinfcNode
78090>>>>>>>>>>>        Get SelectSingleNode sQueryString to hinfcNode
78091>>>>>>>>>>>        //inkey windowindex
78091>>>>>>>>>>>        If (hinfcNode <> 0) ;            Get CreateXMLNode hInfcNode to hoNode
78094>>>>>>>>>>>        Function_Return hoNode
78095>>>>>>>>>>>    End_Function
78096>>>>>>>>>>>
78096>>>>>>>>>>>    // Return object handle for a collection node.
78096>>>>>>>>>>>
78096>>>>>>>>>>>
78096>>>>>>>>>>>    Function FindNodeList String sQueryString Returns Handle
78098>>>>>>>>>>>        Integer hoNodeList
78098>>>>>>>>>>>        Integer hinfcNodeList
78098>>>>>>>>>>>        Get SelectNodes sQueryString to hinfcNodeList
78099>>>>>>>>>>>        If (hinfcNodeList <> 0) ;            Get CreateXMLObject U_cXMLDOMNodeList hinfcNodeList to hoNodeList
78102>>>>>>>>>>>        Function_Return hoNodeList
78103>>>>>>>>>>>    End_Function
78104>>>>>>>>>>>
78104>>>>>>>>>>>    // The CreatexxxxxNode messages creates an node object for the type specified. Both
78104>>>>>>>>>>>    // the interface and the object or of the correct type (i.e. element, comment)
78104>>>>>>>>>>>    // These all return an object handle which can be used to place the object via
78104>>>>>>>>>>>    // appendNode or InsertBeforeNode
78104>>>>>>>>>>>
78104>>>>>>>>>>>    // This function creates a child element, returning a dataflex object.
78104>>>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
78104>>>>>>>>>>>    // the element to the XML Document.
78104>>>>>>>>>>>
78104>>>>>>>>>>>    Function CreateElementNode String sTagName String sValue Returns Handle
78106>>>>>>>>>>>        Integer hoNewElement
78106>>>>>>>>>>>        Integer hoDocumentObject
78106>>>>>>>>>>>        Integer infcNewElement
78106>>>>>>>>>>>        Integer iClassId
78106>>>>>>>>>>>        // The DataFlex objects are created inside the nodes (elements).
78106>>>>>>>>>>>        // Create an element in the document and assign its interface to the new DF object.
78106>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
78107>>>>>>>>>>>        Get createElement of hoDocumentObject sTagName to infcNewElement
78108>>>>>>>>>>>        If infcNewElement Begin // if there was an error, no infc handle would be returned
78110>>>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_ELEMENT to iClassId
78111>>>>>>>>>>>            Get CreateXMLObject iClassId infcNewElement to hoNewElement
78112>>>>>>>>>>>            If hoNewElement ; // very unlikely this will be zero                Set psText of hoNewElement to sValue
78115>>>>>>>>>>>        End
78115>>>>>>>>>>>>
78115>>>>>>>>>>>        Function_Return hoNewElement
78116>>>>>>>>>>>    End_Function
78117>>>>>>>>>>>
78117>>>>>>>>>>>    // This function creates an attribute in a document. Attributes are _NOT_ children of an element.
78117>>>>>>>>>>>    // A DataFlex object is returned. An attribute can be added to an xml document using
78117>>>>>>>>>>>    // get AddAttributeNode.
78117>>>>>>>>>>>
78117>>>>>>>>>>>    Function CreateAttributeNode String sName String sValue Returns Handle
78119>>>>>>>>>>>        Integer hoNewAttribute
78119>>>>>>>>>>>        Integer hoDocumentObject
78119>>>>>>>>>>>        Integer infcNewAttribute
78119>>>>>>>>>>>        Integer iClassId
78119>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
78120>>>>>>>>>>>        // Create an Attribute in the document and assign its interface to the new DF object.
78120>>>>>>>>>>>        Get createAttribute of hoDocumentObject sName to infcNewAttribute
78121>>>>>>>>>>>        If infcNewAttribute Begin // if there was an error, no infc handle would be returned
78123>>>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_ATTRIBUTE to iClassId
78124>>>>>>>>>>>            Get CreateXMLObject iClassId infcNewAttribute to hoNewAttribute
78125>>>>>>>>>>>            // Set the value of the attribute.
78125>>>>>>>>>>>            If hoNewAttribute ; // very unlikely this will be 0                Set psText of hoNewAttribute to sValue
78128>>>>>>>>>>>        End
78128>>>>>>>>>>>>
78128>>>>>>>>>>>        Function_Return hoNewAttribute
78129>>>>>>>>>>>    End_Function
78130>>>>>>>>>>>
78130>>>>>>>>>>>    // This function creates a child comment, returning a dataflex object.
78130>>>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
78130>>>>>>>>>>>    // the comment to the XML Document.
78130>>>>>>>>>>>
78130>>>>>>>>>>>    Function CreateChildComment String sValue Returns Handle
78132>>>>>>>>>>>        Integer hoNewComment
78132>>>>>>>>>>>        Integer hoDocumentObject
78132>>>>>>>>>>>        Integer infcNewComment
78132>>>>>>>>>>>        Integer iClassID
78132>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
78133>>>>>>>>>>>        // Create an Comment in the document and assign its interface to the new DF object.
78133>>>>>>>>>>>        Get createComment of hoDocumentObject sValue to infcNewComment
78134>>>>>>>>>>>        If infcNewComment Begin // if there was an error, no infc handle would be returned
78136>>>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_COMMENT to iClassId
78137>>>>>>>>>>>            Get CreateXMLObject iClassId infcNewComment to hoNewComment
78138>>>>>>>>>>>            If hoNewComment ; // very unlikely this will be 0                Set psText of hoNewComment to sValue
78141>>>>>>>>>>>        End
78141>>>>>>>>>>>>
78141>>>>>>>>>>>        Function_Return hoNewComment
78142>>>>>>>>>>>    End_Function
78143>>>>>>>>>>>
78143>>>>>>>>>>>    // This function creates a child processing instruction, returning a dataflex object.
78143>>>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
78143>>>>>>>>>>>    // the processing instruction to the XML Document.
78143>>>>>>>>>>>
78143>>>>>>>>>>>    Function CreateChildProcessingInstruction String sTarget String sValue Returns Handle
78145>>>>>>>>>>>        Integer hoNewProcessingInstruction
78145>>>>>>>>>>>        Integer hoDocumentObject
78145>>>>>>>>>>>        Integer infcNewProcessingInstruction
78145>>>>>>>>>>>        Integer iClassID
78145>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
78146>>>>>>>>>>>        // Create an ProcessingInstruction in the document and assign its interface to the new DF object.
78146>>>>>>>>>>>        Get createProcessingInstruction of hoDocumentObject sTarget sValue to infcNewProcessingInstruction
78147>>>>>>>>>>>        If infcNewProcessingInstruction  Begin // if there was an error, no infc handle would be returned
78149>>>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_PROCESSING_INSTRUCTION to iClassId
78150>>>>>>>>>>>            Get CreateXMLObject iClassID infcNewProcessingInstruction to hoNewProcessingInstruction
78151>>>>>>>>>>>        End
78151>>>>>>>>>>>>
78151>>>>>>>>>>>        Function_Return hoNewProcessingInstruction
78152>>>>>>>>>>>    End_Function
78153>>>>>>>>>>>
78153>>>>>>>>>>>    // This function creates a child text node, returning a dataflex object.
78153>>>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
78153>>>>>>>>>>>    // the text node to the XML Document.
78153>>>>>>>>>>>
78153>>>>>>>>>>>    Function CreateChildTextNode String sValue Returns Handle
78155>>>>>>>>>>>        Integer hoNewTextNode
78155>>>>>>>>>>>        Integer hoDocumentObject
78155>>>>>>>>>>>        Integer infcNewTextNode
78155>>>>>>>>>>>        Integer iClassID
78155>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
78156>>>>>>>>>>>        // Create an TextNode in the document and assign its interface to the new DF object.
78156>>>>>>>>>>>        Get createTextNode of hoDocumentObject sValue to infcNewTextNode
78157>>>>>>>>>>>        If infcNewTextNode Begin // if there was an error, no infc handle would be returned
78159>>>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_TEXT to iClassId
78160>>>>>>>>>>>            Get CreateXMLObject iClassId infcNewTextNode to hoNewTextNode
78161>>>>>>>>>>>        End
78161>>>>>>>>>>>>
78161>>>>>>>>>>>        Function_Return hoNewTextNode
78162>>>>>>>>>>>    End_Function
78163>>>>>>>>>>>
78163>>>>>>>>>>>    // This function creates a cdata text node, returning a dataflex object.
78163>>>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
78163>>>>>>>>>>>    // the cdata node to the XML Document.
78163>>>>>>>>>>>
78163>>>>>>>>>>>    Function CreateCDATASectionNode String sValue Returns Handle
78165>>>>>>>>>>>        Integer hoNewNode
78165>>>>>>>>>>>        Integer hoDocumentObject
78165>>>>>>>>>>>        Integer infcNewNode
78165>>>>>>>>>>>        Integer iClassId
78165>>>>>>>>>>>        // The DataFlex objects are created inside the nodes (elements).
78165>>>>>>>>>>>        // Create an element in the document and assign its interface to the new DF object.
78165>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
78166>>>>>>>>>>>        Get createCDATASection of hoDocumentObject sValue to infcNewNode
78167>>>>>>>>>>>        If infcNewNode Begin
78169>>>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_CDATA_SECTION to iClassId
78170>>>>>>>>>>>            Get CreateXMLObject iClassId infcNewNode to hoNewNode
78171>>>>>>>>>>>        End
78171>>>>>>>>>>>>
78171>>>>>>>>>>>        Function_Return hoNewNode
78172>>>>>>>>>>>    End_Function
78173>>>>>>>>>>>
78173>>>>>>>>>>>    // Create a document fragment.  Document fragments can be used to house nodes temporarily. When
78173>>>>>>>>>>>    // You append or insert a document fragment (appendNode InsertBeforeNode) child nodes are appended
78173>>>>>>>>>>>    // to the destination object and not the fragment node itself. This is useful!
78173>>>>>>>>>>>
78173>>>>>>>>>>>    Function CreateDocumentFragmentNode Returns Handle
78175>>>>>>>>>>>        Integer hoNew
78175>>>>>>>>>>>        Integer hoDocumentObject
78175>>>>>>>>>>>        Integer infcNew
78175>>>>>>>>>>>        Integer iClassID
78175>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
78176>>>>>>>>>>>        // Create an Comment in the document and assign its interface to the new DF object.
78176>>>>>>>>>>>        Get createDocumentFragment of hoDocumentObject to infcNew
78177>>>>>>>>>>>        If infcNew Begin // if there was an error, no infc handle would be returned
78179>>>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_DOCUMENT_FRAGMENT to iClassId
78180>>>>>>>>>>>            Get CreateXMLObject iClassId infcNew to hoNew
78181>>>>>>>>>>>        End
78181>>>>>>>>>>>>
78181>>>>>>>>>>>        Function_Return hoNew
78182>>>>>>>>>>>    End_Function
78183>>>>>>>>>>>
78183>>>>>>>>>>>    //  Create a Node of any passed Type (e.g. Node_element). Normally you don't need this as there are
78183>>>>>>>>>>>    //  specific messages to do this for each node type. Node that this lets you pass namespaces as a separate
78183>>>>>>>>>>>    //  parameter. With all of the other messages (e.g. createElementNode) you pass namespaces as prefixed to
78183>>>>>>>>>>>    // the tagname (e.g. Get CreateElementNode "MyNameSpace:MyTag" "MyValue" to hoEle)
78183>>>>>>>>>>>
78183>>>>>>>>>>>    Function CreateChildNode Integer iNodeType String sTagName String sNameSpace Returns Handle
78185>>>>>>>>>>>        Integer hoNewNode hoDocumentObject
78185>>>>>>>>>>>        Integer infcNewNode
78185>>>>>>>>>>>        Integer iClassid iType
78185>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
78186>>>>>>>>>>>        Get NodeClassId iNodeType to iClassId
78187>>>>>>>>>>>        If (iClassId<>0) Begin
78189>>>>>>>>>>>            // Create a node in the document and assign its interface to the new DF object.
78189>>>>>>>>>>>            Get createNode of hoDocumentObject iNodeType sTagName sNameSpace to infcNewNode
78190>>>>>>>>>>>            // this is required to force the interface type to be correct.
78190>>>>>>>>>>>            Move (invokexml(DF_IXMLDOMNODE, GET_piNodeType, infcNewNode, 0, 0, 0, 0)) to iType
78191>>>>>>>>>>>            Move (invokexml(DF_IXMLDOMNODE, GET_ChangeNodeType, infcNewNode, iType, 1, 0, 0)) to infcNewNode
78192>>>>>>>>>>>
78192>>>>>>>>>>>            If infcNewNode ;                Get CreateXMLObject iClassId infcNewNode to hoNewNode
78195>>>>>>>>>>>        End
78195>>>>>>>>>>>>
78195>>>>>>>>>>>        Function_Return hoNewNode
78196>>>>>>>>>>>    End_Function
78197>>>>>>>>>>>
78197>>>>>>>>>>>
78197>>>>>>>>>>>
78197>>>>>>>>>>>    // The Addxxxxx messages create a new node and appends it to the list. When used as a function,
78197>>>>>>>>>>>    // the object handle is returned and must be disposed of later by the programmer.
78197>>>>>>>>>>>    // When used as a procedure, the object is destroyed--it just does it and is done.
78197>>>>>>>>>>>
78197>>>>>>>>>>>    Function AddElement String sTagName String sValue Returns Handle
78199>>>>>>>>>>>        Integer hoNewElement
78199>>>>>>>>>>>        Get CreateElementNode sTagName sValue to hoNewElement
78200>>>>>>>>>>>        If hoNewElement Get AppendNode hoNewElement to hoNewElement
78203>>>>>>>>>>>        Function_Return hoNewElement
78204>>>>>>>>>>>    End_Function
78205>>>>>>>>>>>
78205>>>>>>>>>>>    Procedure AddElement String sTagName String sValue
78207>>>>>>>>>>>        Integer hoNewElement
78207>>>>>>>>>>>        Get AddElement sTagName sValue to hoNewElement
78208>>>>>>>>>>>        If hoNewElement ;            Send Destroy to hoNewElement
78211>>>>>>>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddElement"))
78213>>>>>>>>>>>    End_Procedure
78214>>>>>>>>>>>
78214>>>>>>>>>>>    // this returns the object, This is often needed
78214>>>>>>>>>>>    Function CreateElementNodeNS String sNameSpace String sTagName String sValue Returns Handle
78216>>>>>>>>>>>        Integer hoNewElement
78216>>>>>>>>>>>        Get CreateChildNode NODE_ELEMENT sTagName sNameSpace to hoNewElement
78217>>>>>>>>>>>        If (hoNewElement and sValue<>"") ;            Set psText of hoNewElement to sValue
78220>>>>>>>>>>>        Function_Return hoNewElement
78221>>>>>>>>>>>    End_Procedure
78222>>>>>>>>>>>
78222>>>>>>>>>>>
78222>>>>>>>>>>>    // this returns the object, This is often needed
78222>>>>>>>>>>>    Function AddElementNS String sNameSpace String sTagName String sValue Returns Handle
78224>>>>>>>>>>>        Integer hoNewElement
78224>>>>>>>>>>>        Get CreateElementNodeNS sNameSpace sTagName sValue to hoNewElement
78225>>>>>>>>>>>        If hoNewElement Begin
78227>>>>>>>>>>>            Get AppendNode hoNewElement to hoNewElement
78228>>>>>>>>>>>        End
78228>>>>>>>>>>>>
78228>>>>>>>>>>>        Function_Return hoNewElement
78229>>>>>>>>>>>    End_Function
78230>>>>>>>>>>>
78230>>>>>>>>>>>    Procedure AddElementNS String sNameSpace String sTagName String sValue
78232>>>>>>>>>>>        Integer hoNewElement
78232>>>>>>>>>>>        Get AddElementNS sNameSpace sTagName sValue to hoNewElement
78233>>>>>>>>>>>        If hoNewElement ;            Send Destroy to hoNewElement
78236>>>>>>>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddElementNS"))
78238>>>>>>>>>>>    End_Procedure
78239>>>>>>>>>>>
78239>>>>>>>>>>>    Function AddAttributeNode Handle hoNode Returns Handle
78241>>>>>>>>>>>        Handle hInfc
78241>>>>>>>>>>>        Get Set_AttributeNode (XmlInterface(hoNode)) to hInfc
78242>>>>>>>>>>>        If hInfc ; // if ret value we have a replacement            Set XmlInterface of hoNode to hInfc
78245>>>>>>>>>>>        Function_Return hoNode
78246>>>>>>>>>>>    End_Function
78247>>>>>>>>>>>
78247>>>>>>>>>>>//    // is this needed
78247>>>>>>>>>>>//    Function AddAttributeNodeNS handle hoNode returns Handle
78247>>>>>>>>>>>//        Get AddAttributeNode hoNode to hoNode
78247>>>>>>>>>>>//        function_return hoNode
78247>>>>>>>>>>>//    End_Function
78247>>>>>>>>>>>
78247>>>>>>>>>>>    Function AttributeValueNode String sName Returns Handle
78249>>>>>>>>>>>        Handle hInfc
78249>>>>>>>>>>>        Handle hoNode
78249>>>>>>>>>>>        Get AttributeNode sName to hInfc
78250>>>>>>>>>>>        If hInfc ; // if ret value we have a replacement           Get CreateXMLNode hInfc to hoNode
78253>>>>>>>>>>>        Function_Return hoNode
78254>>>>>>>>>>>    End_Function
78255>>>>>>>>>>>
78255>>>>>>>>>>>    Function AttributeValueNodeNS String sNameSpace String sBaseName Returns Handle
78257>>>>>>>>>>>        Handle hoAttrs hoAttr
78257>>>>>>>>>>>        String sValue
78257>>>>>>>>>>>        Get TempAttributeNodes to hoAttrs
78258>>>>>>>>>>>        If hoAttrs Begin
78260>>>>>>>>>>>            Get QualifiedNode of hoAttrs sNamespace sBaseName to hoAttr
78261>>>>>>>>>>>            Set XMLInterface of hoAttrs to 0
78262>>>>>>>>>>>        End
78262>>>>>>>>>>>>
78262>>>>>>>>>>>        Function_Return hoAttr
78263>>>>>>>>>>>    End_Function
78264>>>>>>>>>>>
78264>>>>>>>>>>>
78264>>>>>>>>>>>    Function CreateAttributeNodeNS String sNameSpace String sName String sValue Returns Handle
78266>>>>>>>>>>>        Integer hoNewAttribute
78266>>>>>>>>>>>        Get CreateChildNode NODE_ATTRIBUTE sName sNameSpace to hoNewAttribute
78267>>>>>>>>>>>        If hoNewAttribute ;            Set psText of hoNewAttribute to sValue
78270>>>>>>>>>>>        Function_Return hoNewAttribute
78271>>>>>>>>>>>    End_Function
78272>>>>>>>>>>>
78272>>>>>>>>>>>    Procedure AddAttributeNS String sNameSpace String sName String sValue
78274>>>>>>>>>>>       Handle hoNode
78274>>>>>>>>>>>       Get CreateAttributeNodeNS sNameSpace sName sValue to hoNode
78275>>>>>>>>>>>       If hoNode Begin
78277>>>>>>>>>>>          Get AddAttributeNode hoNode to hoNode
78278>>>>>>>>>>>          If hoNode Send Destroy of hoNode
78281>>>>>>>>>>>       End
78281>>>>>>>>>>>>
78281>>>>>>>>>>>       Else ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddAttributeNS"))
78283>>>>>>>>>>>    End_Procedure
78284>>>>>>>>>>>
78284>>>>>>>>>>>
78284>>>>>>>>>>>    // This function encapsulates creation and addition of attributes to a node.
78284>>>>>>>>>>>    // should only work with element class
78284>>>>>>>>>>>    Procedure AddAttribute String sName String sValue
78286>>>>>>>>>>>        Set AttributeValue sName to sValue
78287>>>>>>>>>>>    End_Procedure
78288>>>>>>>>>>>
78288>>>>>>>>>>>    // This function encapsulates creation and addition of comments to a node.
78288>>>>>>>>>>>    // The return value is a Boolean that is currently unused.
78288>>>>>>>>>>>
78288>>>>>>>>>>>    Procedure AddChildComment String sValue
78290>>>>>>>>>>>        Integer hoNewNode
78290>>>>>>>>>>>        Get createChildComment sValue to hoNewNode
78291>>>>>>>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddChildComment"))
78294>>>>>>>>>>>        Else Begin
78295>>>>>>>>>>>            Get AppendNode hoNewNode to hoNewNode
78296>>>>>>>>>>>            Send Destroy to hoNewNode
78297>>>>>>>>>>>        End
78297>>>>>>>>>>>>
78297>>>>>>>>>>>    End_Procedure
78298>>>>>>>>>>>
78298>>>>>>>>>>>    // This function encapsulates creation and addition of processing instructions to a node.
78298>>>>>>>>>>>    // The return value is a Boolean that is currently unused.
78298>>>>>>>>>>>
78298>>>>>>>>>>>    Procedure AddChildProcessingInstruction String sTarget String sValue
78300>>>>>>>>>>>        Integer hoNewNode
78300>>>>>>>>>>>        Get createChildProcessingInstruction sTarget sValue to hoNewNode
78301>>>>>>>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddChildProcessingInstruction"))
78304>>>>>>>>>>>        Else Begin
78305>>>>>>>>>>>            Get AppendNode hoNewNode to hoNewNode
78306>>>>>>>>>>>            Send Destroy to hoNewNode
78307>>>>>>>>>>>        End
78307>>>>>>>>>>>>
78307>>>>>>>>>>>    End_Procedure
78308>>>>>>>>>>>
78308>>>>>>>>>>>
78308>>>>>>>>>>>    // This function encapsulates creation and addition of text nodes to a node.
78308>>>>>>>>>>>    // The return value is a Boolean that is currently unused.
78308>>>>>>>>>>>
78308>>>>>>>>>>>    Procedure AddChildTextNode String sValue
78310>>>>>>>>>>>        Integer hoNewNode
78310>>>>>>>>>>>        Get createChildTextNode sValue to hoNewNode
78311>>>>>>>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddChildTextNode"))
78314>>>>>>>>>>>        Else Begin
78315>>>>>>>>>>>            Get AppendNode hoNewNode to hoNewNode
78316>>>>>>>>>>>            Send Destroy to hoNewNode
78317>>>>>>>>>>>        End
78317>>>>>>>>>>>>
78317>>>>>>>>>>>    End_Procedure
78318>>>>>>>>>>>
78318>>>>>>>>>>>    // This procedure encapsulates creation and addition of cdata text nodes to a node.
78318>>>>>>>>>>>    Procedure AddCDataSection String sValue
78320>>>>>>>>>>>        Handle hoNewNode
78320>>>>>>>>>>>        Get CreateCDATASectionNode sValue to hoNewNode
78321>>>>>>>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddCDataSection"))
78324>>>>>>>>>>>        Else Begin
78325>>>>>>>>>>>            Get AppendNode hoNewNode to hoNewNode
78326>>>>>>>>>>>            Send Destroy to hoNewNode
78327>>>>>>>>>>>        End
78327>>>>>>>>>>>>
78327>>>>>>>>>>>    End_Procedure
78328>>>>>>>>>>>
78328>>>>>>>>>>>
78328>>>>>>>>>>>    Function AddChildNode Integer iNodeType String sTagName String sNameSpace Returns Handle
78330>>>>>>>>>>>        Integer hoNewNode
78330>>>>>>>>>>>        Integer hoDocumentObject
78330>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
78331>>>>>>>>>>>        Get createChildNode of hoDocumentObject iNodeType sTagName sNamespace to hoNewNode
78332>>>>>>>>>>>        If hoNewNode ;            Get AppendNode hoNewNode to hoNewNode
78335>>>>>>>>>>>        Function_Return hoNewNode
78336>>>>>>>>>>>    End_Function
78337>>>>>>>>>>>    
78337>>>>>>>>>>>    // don't use the runtime/msxml version of this. Instead just return the
78337>>>>>>>>>>>    // first text from the first child node. This is much faster
78337>>>>>>>>>>>    Function psText Returns String
78339>>>>>>>>>>>        Handle hText
78339>>>>>>>>>>>        String sValue
78339>>>>>>>>>>>        Get phFirstChild to hText
78340>>>>>>>>>>>        Get InfcNodeValue hText to sValue
78341>>>>>>>>>>>        Function_Return sValue        
78342>>>>>>>>>>>    End_Function
78343>>>>>>>>>>>     
78343>>>>>>>>>>>    // Use this to call the internal Text property. This returns all text for all child
78343>>>>>>>>>>>    // node. You rarely would want to do this. The is uses the msxml psText which can 
78343>>>>>>>>>>>    // get slow with very large files. If for some reason you need all of the child node's
78343>>>>>>>>>>>    // text and the file is large, you might want to consider doing this process manually.
78343>>>>>>>>>>>    Function AllChildNodesText Returns String
78345>>>>>>>>>>>        String sValue
78345>>>>>>>>>>>        Forward Get psText to sValue
78347>>>>>>>>>>>        Function_Return sValue        
78348>>>>>>>>>>>    End_Function
78349>>>>>>>>>>>    
78349>>>>>>>>>>>    // return the interface NodeValue without having to create a
78349>>>>>>>>>>>    // new object
78349>>>>>>>>>>>    Function InfcNodeValue Handle hInfc Returns String
78351>>>>>>>>>>>        Integer hoDocument hoTempNode
78351>>>>>>>>>>>        String sValue
78351>>>>>>>>>>>        If (hinfc) Begin
78353>>>>>>>>>>>            Get DocumentObject to hoDocument
78354>>>>>>>>>>>            Get phoTempDomNode of hoDocument to hoTempNode
78355>>>>>>>>>>>            Set XMLInterface of hoTempNode to hInfc
78356>>>>>>>>>>>            Get psNodeValue of hoTempNode to sValue
78357>>>>>>>>>>>            Set XMLInterface of hoTempNode to 0
78358>>>>>>>>>>>        End
78358>>>>>>>>>>>>
78358>>>>>>>>>>>        Function_Return sValue
78359>>>>>>>>>>>    End_Function
78360>>>>>>>>>>>    
78360>>>>>>>>>>>    // ChildNodeValue is used to get the "value" of an element. This is useful when the element
78360>>>>>>>>>>>    // only has a single value (similar to an attribute).
78360>>>>>>>>>>>    
78360>>>>>>>>>>>    Function ChildNodeValue String sTagName Returns String
78362>>>>>>>>>>>        Integer hoTempNode hoDocument
78362>>>>>>>>>>>        Integer hinfcTempNode 
78362>>>>>>>>>>>        String sRetVal
78362>>>>>>>>>>>        Get SelectSingleNode sTagName to hinfcTempNode
78363>>>>>>>>>>>        If (hinfcTempNode <> 0) Begin
78365>>>>>>>>>>>            Get DocumentObject to hoDocument
78366>>>>>>>>>>>            Get phoTempDomNode of hoDocument to hoTempNode
78367>>>>>>>>>>>            Set XMLInterface of hoTempNode to hinfcTempNode
78368>>>>>>>>>>>            Get phFirstChild of hoTempNode to hinfcTempNode
78369>>>>>>>>>>>            Set XMLInterface of hoTempNode to 0
78370>>>>>>>>>>>            If hinfcTempNode Begin
78372>>>>>>>>>>>                Get InfcNodeValue hinfcTempNode to sRetVal
78373>>>>>>>>>>>            End
78373>>>>>>>>>>>>
78373>>>>>>>>>>>        End
78373>>>>>>>>>>>>
78373>>>>>>>>>>>        Function_Return sRetVal
78374>>>>>>>>>>>    End_Function
78375>>>>>>>>>>>
78375>>>>>>>>>>>    // This simple function allows a parent to change the text of one of its elements.
78375>>>>>>>>>>>    // This actually occurs quite a bit, because (as stated above) lowest level
78375>>>>>>>>>>>    // elements are frequently used as properties.
78375>>>>>>>>>>>    //
78375>>>>>>>>>>>    Procedure SetChildNodeValue String sTagName String sValue
78377>>>>>>>>>>>        Integer hoTempNode
78377>>>>>>>>>>>        Integer hinfcTempNode
78377>>>>>>>>>>>        // Search for the node that matches.
78377>>>>>>>>>>>        Get SelectSingleNode sTagName to hinfcTempNode
78378>>>>>>>>>>>        // If no match is found, add a new element with the tag.
78378>>>>>>>>>>>        If (hinfcTempNode = 0) ;            Send AddElement sTagName sValue
78381>>>>>>>>>>>        Else Begin
78382>>>>>>>>>>>            Get CreateXMLObject U_BaseXMLDOMNode hinfcTempNode to hoTempNode
78383>>>>>>>>>>>            If hoTempNode Begin
78385>>>>>>>>>>>                // Set the text of the element.
78385>>>>>>>>>>>                Set psText of hoTempNode to sValue
78386>>>>>>>>>>>                Send Destroy to hoTempNode
78387>>>>>>>>>>>            End
78387>>>>>>>>>>>>
78387>>>>>>>>>>>            Else ;                Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_SetChildNodeValue"))
78389>>>>>>>>>>>        End
78389>>>>>>>>>>>>
78389>>>>>>>>>>>    End_Procedure
78390>>>>>>>>>>>
78390>>>>>>>>>>>    // These messages are used to allow you to travese through a nodes.
78390>>>>>>>>>>>
78390>>>>>>>>>>>    Function FirstChild Returns Handle
78392>>>>>>>>>>>        Handle hoChild
78392>>>>>>>>>>>        Integer hinfcChild
78392>>>>>>>>>>>        Get phFirstChild  to hinfcChild
78393>>>>>>>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
78396>>>>>>>>>>>        Function_Return hoChild
78397>>>>>>>>>>>    End_Function
78398>>>>>>>>>>>
78398>>>>>>>>>>>    Function NextSibling Returns Handle
78400>>>>>>>>>>>        Handle hoChild
78400>>>>>>>>>>>        Integer hinfcChild
78400>>>>>>>>>>>        Get phNextSibling  to hinfcChild
78401>>>>>>>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
78404>>>>>>>>>>>        Function_Return hoChild
78405>>>>>>>>>>>    End_Function
78406>>>>>>>>>>>
78406>>>>>>>>>>>    Function PreviousSibling Returns Handle
78408>>>>>>>>>>>        Handle hoChild
78408>>>>>>>>>>>        Integer hinfcChild
78408>>>>>>>>>>>        Get phPreviousSibling  to hinfcChild
78409>>>>>>>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
78412>>>>>>>>>>>        Function_Return hoChild
78413>>>>>>>>>>>    End_Function
78414>>>>>>>>>>>
78414>>>>>>>>>>>    Function LastChild Returns Handle
78416>>>>>>>>>>>        Handle hoChild
78416>>>>>>>>>>>        Integer hinfcChild
78416>>>>>>>>>>>        Get phLastChild  to hinfcChild
78417>>>>>>>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
78420>>>>>>>>>>>        Function_Return hoChild
78421>>>>>>>>>>>    End_Function
78422>>>>>>>>>>>
78422>>>>>>>>>>>    // return an object that is the parent of the current node
78422>>>>>>>>>>>    Function ParentNode Returns Handle
78424>>>>>>>>>>>        Handle hoId
78424>>>>>>>>>>>        Handle hinfcXMLInterface
78424>>>>>>>>>>>        Get phParentNode to hinfcXMLInterface
78425>>>>>>>>>>>        If (hinfcXMLInterface) ;            Get CreateXmlNode hinfcXMLInterface to hoID
78428>>>>>>>>>>>        Function_Return hoID
78429>>>>>>>>>>>    End_Function
78430>>>>>>>>>>>
78430>>>>>>>>>>>    // Same as NextSibling except it uses or destroys the current node
78430>>>>>>>>>>>    //
78430>>>>>>>>>>>    // optimized version does not destroy/create object unless it needs to.  
78430>>>>>>>>>>>    // if the next node is the same node type we will resuse this object
78430>>>>>>>>>>>    // else this object is destroyed 
78430>>>>>>>>>>>    Function NextNode Returns Handle
78432>>>>>>>>>>>        Handle hoNode hoDocument
78432>>>>>>>>>>>        Handle hInfc
78432>>>>>>>>>>>        Get phNextSibling to hInfc
78433>>>>>>>>>>>        If hInfc Begin
78435>>>>>>>>>>>            Get DocumentObject to hoDocument
78436>>>>>>>>>>>            Move Self to hoNode
78437>>>>>>>>>>>            Send BindXMLInfc of hoDocument hInfc (&hoNode)
78438>>>>>>>>>>>        End
78438>>>>>>>>>>>>
78438>>>>>>>>>>>        Else Begin
78439>>>>>>>>>>>            Send Destroy
78440>>>>>>>>>>>            Move 0 to hoNode
78441>>>>>>>>>>>        End
78441>>>>>>>>>>>>
78441>>>>>>>>>>>        Function_Return hoNode
78442>>>>>>>>>>>    End_Function
78443>>>>>>>>>>>        
78443>>>>>>>>>>>        
78443>>>>>>>>>>>    // Enumerate through all nodes.
78443>>>>>>>>>>>
78443>>>>>>>>>>>    Procedure EnumerateNodes Integer iMsg Integer hoReceiver String sVal1 String sVal2
78445>>>>>>>>>>>        Integer i iLen
78445>>>>>>>>>>>        Integer hoNode
78445>>>>>>>>>>>        Integer hoNodeCollection
78445>>>>>>>>>>>        Get ChildNodes to hoNodeCollection
78446>>>>>>>>>>>        If (hoNodeCollection <> 0) Begin
78448>>>>>>>>>>>            Get NodeListLength of hoNodeCollection to iLen
78449>>>>>>>>>>>            Decrement iLen
78450>>>>>>>>>>>            For i from 0 to iLen
78456>>>>>>>>>>>>
78456>>>>>>>>>>>                // For each record, process its fields.
78456>>>>>>>>>>>                Get CollectionNode of hoNodeCollection i to hoNode
78457>>>>>>>>>>>                Send iMsg of hoReceiver hoNode sVal1 sVal2
78458>>>>>>>>>>>                Send Destroy of hoNode
78459>>>>>>>>>>>            Loop
78460>>>>>>>>>>>>
78460>>>>>>>>>>>            Send Destroy of hoNodeCollection
78461>>>>>>>>>>>        End
78461>>>>>>>>>>>>
78461>>>>>>>>>>>    End_Procedure
78462>>>>>>>>>>>
78462>>>>>>>>>>>    // Enumerate through all elements.
78462>>>>>>>>>>>
78462>>>>>>>>>>>    Procedure EnumerateElements Integer iMsg Integer hoReceiver String sVal1 String sVal2
78464>>>>>>>>>>>        Integer i iLen
78464>>>>>>>>>>>        Integer hoNode
78464>>>>>>>>>>>        Integer hoNodeCollection
78464>>>>>>>>>>>        Get ChildNodes to hoNodeCollection
78465>>>>>>>>>>>        If (hoNodeCollection <> 0) Begin
78467>>>>>>>>>>>            Get NodeListLength of hoNodeCollection to iLen
78468>>>>>>>>>>>            Decrement iLen
78469>>>>>>>>>>>            For i from 0 to iLen
78475>>>>>>>>>>>>
78475>>>>>>>>>>>                // For each record, process its fields.
78475>>>>>>>>>>>                Get CollectionNode of hoNodeCollection i to hoNode
78476>>>>>>>>>>>                If (piNodeType(hoNode)=NODE_ELEMENT) ;                    Send iMsg of hoReceiver hoNode sVal1 sVal2
78479>>>>>>>>>>>                Send Destroy of hoNode
78480>>>>>>>>>>>            Loop
78481>>>>>>>>>>>>
78481>>>>>>>>>>>            Send Destroy of hoNodeCollection
78482>>>>>>>>>>>        End
78482>>>>>>>>>>>>
78482>>>>>>>>>>>    End_Procedure
78483>>>>>>>>>>>
78483>>>>>>>>>>>
78483>>>>>>>>>>>    // enumerate through all attributes. There is no recurse here because attributes will not
78483>>>>>>>>>>>    // contain attributes.
78483>>>>>>>>>>>
78483>>>>>>>>>>>    Procedure EnumerateAttributes Integer iMsg Integer hoReceiver String sSomeValue
78485>>>>>>>>>>>        Integer i iLen
78485>>>>>>>>>>>        Integer hoNode
78485>>>>>>>>>>>        Integer hoNodeMapCollection
78485>>>>>>>>>>>        // we don't use tempattributenodes because we don't know what the enum message will do.
78485>>>>>>>>>>>        Get AttributeNodes to hoNodeMapCollection
78486>>>>>>>>>>>        If (hoNodeMapCollection <> 0) Begin
78488>>>>>>>>>>>            Get NodeListLength of hoNodeMapCollection to iLen
78489>>>>>>>>>>>            Decrement iLen
78490>>>>>>>>>>>            For i from 0 to iLen
78496>>>>>>>>>>>>
78496>>>>>>>>>>>                // For each record, process its fields.
78496>>>>>>>>>>>                Get CollectionNode of hoNodeMapCollection i to hoNode
78497>>>>>>>>>>>                Send iMsg of hoReceiver hoNode sSomeValue
78498>>>>>>>>>>>                Send Destroy of hoNode
78499>>>>>>>>>>>            Loop
78500>>>>>>>>>>>>
78500>>>>>>>>>>>            Send Destroy of hoNodeMapCollection
78501>>>>>>>>>>>        End
78501>>>>>>>>>>>>
78501>>>>>>>>>>>    End_Procedure
78502>>>>>>>>>>>
78502>>>>>>>>>>>
78502>>>>>>>>>>>    Function XSLTransformation Integer hoXSLDocument Returns String
78504>>>>>>>>>>>        Integer infcXSLStartAt
78504>>>>>>>>>>>        String sBuffer
78504>>>>>>>>>>>        // Transformation is of current object using passed XSLDocument.
78504>>>>>>>>>>>        Get XMLInterface of hoXSLDocument to infcXSLStartAt
78505>>>>>>>>>>>        Get TransformNode infcXSLStartAt to sBuffer
78506>>>>>>>>>>>        Function_Return sBuffer
78507>>>>>>>>>>>    End_Function
78508>>>>>>>>>>>
78508>>>>>>>>>>>    // This allows for transformations not limited to the size of the string buffer
78508>>>>>>>>>>>    //
78508>>>>>>>>>>>    // Note that it is up to the programmer to dispose of the memory allocated at pBuffer
78508>>>>>>>>>>>    // by using the free(pBuffer) function
78508>>>>>>>>>>>    //
78508>>>>>>>>>>>    Function XSLTransformationToAddress Integer hoXSLDocument Returns Address
78510>>>>>>>>>>>        Integer infcXSLStartAt
78510>>>>>>>>>>>        Address pBuffer
78510>>>>>>>>>>>        // Transformation is of current object using passed XSLDocument.
78510>>>>>>>>>>>        Get XMLInterface of hoXSLDocument to infcXSLStartAt
78511>>>>>>>>>>>        Get TransformNodeToAddress infcXSLStartAt to pBuffer
78512>>>>>>>>>>>        Function_Return pBuffer
78513>>>>>>>>>>>    End_Function
78514>>>>>>>>>>>
78514>>>>>>>>>>>
78514>>>>>>>>>>>    // extract base name from string. e.g.: ns:name --> name
78514>>>>>>>>>>>    //
78514>>>>>>>>>>>    Function BaseNameFromQName String sName Returns String
78516>>>>>>>>>>>        Integer iPos
78516>>>>>>>>>>>        Move (Pos(":",sName)) to iPos
78517>>>>>>>>>>>        If iPos Begin
78519>>>>>>>>>>>            Move (remove(sName,1,iPos)) to sName
78520>>>>>>>>>>>        End
78520>>>>>>>>>>>>
78520>>>>>>>>>>>        Function_Return sName
78521>>>>>>>>>>>    End_Function
78522>>>>>>>>>>>
78522>>>>>>>>>>>    // extract prefix name from string. e.g.: ns:name --> ns
78522>>>>>>>>>>>    //
78522>>>>>>>>>>>    Function PrefixNameFromQName String sName Returns String
78524>>>>>>>>>>>        String sPreFix
78524>>>>>>>>>>>        Integer iPos
78524>>>>>>>>>>>        Move (Pos(":",sName)) to iPos
78525>>>>>>>>>>>        If iPos Begin
78527>>>>>>>>>>>            Move (Left(sName,iPos-1)) to sPreFix
78528>>>>>>>>>>>        End
78528>>>>>>>>>>>>
78528>>>>>>>>>>>        Function_Return sPreFix
78529>>>>>>>>>>>    End_Function
78530>>>>>>>>>>>
78530>>>>>>>>>>>
78530>>>>>>>>>>>    // Returns true if node is element and namespace and base name match
78530>>>>>>>>>>>    //
78530>>>>>>>>>>>    Function IsElementNS String sNamespaceURI String sBaseName Returns Boolean
78532>>>>>>>>>>>         Function_Return (piNodeType(Self)=NODE_ELEMENT and ;                          psNameSpaceURI(Self)=sNamespaceURI and ;                          psBaseName(Self)=sBaseName )
78533>>>>>>>>>>>    End_Function
78534>>>>>>>>>>>
78534>>>>>>>>>>>    // Returns node of first occurence of child node matching namespace and base name
78534>>>>>>>>>>>    //
78534>>>>>>>>>>>    Function ChildElementNS String sNameSpaceURI String sBaseName Returns Handle
78536>>>>>>>>>>>        Handle hoNode
78536>>>>>>>>>>>        Get FirstChild to hoNode
78537>>>>>>>>>>>        While (hoNode and not(IsElementNS(hoNode, sNameSpaceURI, sBaseName)))
78541>>>>>>>>>>>            Get NextNode of hoNode to hoNode
78542>>>>>>>>>>>        End
78543>>>>>>>>>>>>
78543>>>>>>>>>>>        Function_Return hoNode
78544>>>>>>>>>>>    End_Function
78545>>>>>>>>>>>
78545>>>>>>>>>>>    // Returns node of next occurence of sibling node matching namespace and base name
78545>>>>>>>>>>>    // and destroys the current node.
78545>>>>>>>>>>>//    Function NextElementNS String sNameSpaceURI String sBaseName Returns Handle
78545>>>>>>>>>>>//        handle hoNode
78545>>>>>>>>>>>//        Get NextSibling to hoNode
78545>>>>>>>>>>>//        While (hoNode and not(IsElementNS(hoNode, sNameSpaceURI, sBaseName)))
78545>>>>>>>>>>>//            Get NextNode of hoNode to hoNode
78545>>>>>>>>>>>//        end
78545>>>>>>>>>>>//        Send Destroy
78545>>>>>>>>>>>//        function_return hoNode
78545>>>>>>>>>>>//    end_function
78545>>>>>>>>>>>
78545>>>>>>>>>>>    Function NextElementNS String sNameSpaceURI String sBaseName Returns Handle
78547>>>>>>>>>>>        Handle hoNode
78547>>>>>>>>>>>        // NextNode may return the same object or it may destroy the object and
78547>>>>>>>>>>>        // return nothing or a different object
78547>>>>>>>>>>>        Get NextNode to hoNode
78548>>>>>>>>>>>        While (hoNode and not(IsElementNS(hoNode, sNameSpaceURI, sBaseName)))
78552>>>>>>>>>>>            // use of hoNode is required. This can be different than self
78552>>>>>>>>>>>            Get NextNode of hoNode to hoNode
78553>>>>>>>>>>>        End
78554>>>>>>>>>>>>
78554>>>>>>>>>>>         
78554>>>>>>>>>>>        Function_Return hoNode
78555>>>>>>>>>>>    End_Function
78556>>>>>>>>>>>
78556>>>>>>>>>>>
78556>>>>>>>>>>>    // Returns value (string) first occurence of child node matching namespace and base name
78556>>>>>>>>>>>    //
78556>>>>>>>>>>>    Function ChildElementValueNS String sNameSpaceURI String sBaseName Returns String
78558>>>>>>>>>>>        Handle hoNext
78558>>>>>>>>>>>        String sText
78558>>>>>>>>>>>        Get ChildElementNS sNameSpaceURI sBaseName to hoNext
78559>>>>>>>>>>>        If hoNext Begin
78561>>>>>>>>>>>            Get psText of hoNext to sText
78562>>>>>>>>>>>            Send destroy of hoNext
78563>>>>>>>>>>>        End
78563>>>>>>>>>>>>
78563>>>>>>>>>>>        Function_Return sText
78564>>>>>>>>>>>    End_Function
78565>>>>>>>>>>>
78565>>>>>>>>>>>    Procedure SetChildElementValueNS String sNameSpaceURI String sBaseName String sValue
78567>>>>>>>>>>>        Integer hoNode
78567>>>>>>>>>>>        Integer hinfcTempNode
78567>>>>>>>>>>>        Get ChildElementNS sNameSpaceURI sBaseName to hoNode
78568>>>>>>>>>>>        If (hoNode=0) Begin
78570>>>>>>>>>>>            Send AddElementNS sNameSpaceURI sBaseName sValue
78571>>>>>>>>>>>        End
78571>>>>>>>>>>>>
78571>>>>>>>>>>>        Else Begin
78572>>>>>>>>>>>            Set psText of hoNode to sValue
78573>>>>>>>>>>>            Send destroy of hoNode
78574>>>>>>>>>>>        End
78574>>>>>>>>>>>>
78574>>>>>>>>>>>    End_Procedure
78575>>>>>>>>>>>
78575>>>>>>>>>>>
78575>>>>>>>>>>>//    // Returns node of first occurence of child node matching namespace and base name
78575>>>>>>>>>>>//    // that has an attrib value that contains a specified value
78575>>>>>>>>>>>//    //
78575>>>>>>>>>>>//    //Doc/ Visibility=Public
78575>>>>>>>>>>>//    Function FindElementNodeWithAttribNS string sNamespace string sBaseName string sAttribName string sAttribValue returns handle
78575>>>>>>>>>>>//        handle hoNext hoNode
78575>>>>>>>>>>>//        string sName
78575>>>>>>>>>>>//        Get FirstChild to hoNode
78575>>>>>>>>>>>//        While (hoNode)
78575>>>>>>>>>>>//            If (IsElementNS(hoNode, sNameSpace, sBaseName)) begin
78575>>>>>>>>>>>//                Get AttributeValue of hoNode sAttribName to sName
78575>>>>>>>>>>>//                If (sName=sAttribValue) Begin
78575>>>>>>>>>>>//                    Function_return hoNode
78575>>>>>>>>>>>//                end
78575>>>>>>>>>>>//            end
78575>>>>>>>>>>>//            Get NextSibling of hoNode to hoNext
78575>>>>>>>>>>>//            Send Destroy of hoNode
78575>>>>>>>>>>>//            Move hoNext to hoNode
78575>>>>>>>>>>>//        end
78575>>>>>>>>>>>//        function_return 0
78575>>>>>>>>>>>//    end_function
78575>>>>>>>>>>>
78575>>>>>>>>>>>    // pass a prefix and try to finds its NameSpaceURI. Start at current node and work up to parent.
78575>>>>>>>>>>>    // This can be useful when a qualified name is found in an attribute value
78575>>>>>>>>>>>    //
78575>>>>>>>>>>>    Function PrefixToNamespaceURI String sPrefix Returns String
78577>>>>>>>>>>>        Handle hoNode
78577>>>>>>>>>>>        Integer i iNodes
78577>>>>>>>>>>>        Integer hoNodes hoParentNode hoAttNode
78577>>>>>>>>>>>        Boolean bDone bParent
78577>>>>>>>>>>>        String sAttPrefix sName sNameSpace
78577>>>>>>>>>>>
78577>>>>>>>>>>>        Move Self to hoNode
78578>>>>>>>>>>>        While not bDone
78582>>>>>>>>>>>            Get TempAttributeNodes of hoNode to hoNodes
78583>>>>>>>>>>>            If (hoNodes <> 0) Begin
78585>>>>>>>>>>>                Get NodeListLength of hoNodes to iNodes
78586>>>>>>>>>>>                For i from 0 to (iNodes-1)
78592>>>>>>>>>>>>
78592>>>>>>>>>>>                    // For each record, process its fields.
78592>>>>>>>>>>>                    Get CollectionNode of hoNodes i to hoAttNode
78593>>>>>>>>>>>                    Get psPrefix of hoAttNode to sAttPrefix
78594>>>>>>>>>>>                    Get psBaseName of hoAttNode to sName
78595>>>>>>>>>>>                    // with legacy msxml, xmlns="foo" returns psPrefix="xmlns" and pbBaseName=""
78595>>>>>>>>>>>                    // with newer msxml, xmlns="foo" returns psPrefix="" and pbBaseName="xmlns"
78595>>>>>>>>>>>                    // We handle both cases here. 
78595>>>>>>>>>>>                    
78595>>>>>>>>>>>                    If ( (sAttPrefix="xmlns" and sName=sPrefix) or ; // if a normal xmlns:xx="foo" match (sPrefix="xx") or a legacy xmlns="foo" match (sPrefix="")                         (sPrefix="" and sAttPrefix="" and sName="xmlns") ) Begin // special test for newer msxml xmlns="foo" match (sPrefix="")
78597>>>>>>>>>>>
78597>>>>>>>>>>>                        Get Value of hoAttNode to sNameSpace
78598>>>>>>>>>>>                        Move True to bDone
78599>>>>>>>>>>>                        Move (iNodes-1) to i
78600>>>>>>>>>>>
78600>>>>>>>>>>>                    End
78600>>>>>>>>>>>>
78600>>>>>>>>>>>
78600>>>>>>>>>>>                    Send Destroy of hoAttNode
78601>>>>>>>>>>>                Loop
78602>>>>>>>>>>>>
78602>>>>>>>>>>>                Set XMLInterface of hoNodes to 0
78603>>>>>>>>>>>            End
78603>>>>>>>>>>>>
78603>>>>>>>>>>>            
78603>>>>>>>>>>>            Get ParentNode of hoNode to hoParentNode
78604>>>>>>>>>>>            If bParent Send destroy of hoNode
78607>>>>>>>>>>>            If not bDone Begin
78609>>>>>>>>>>>                If not hoParentNode Move True to bDone
78612>>>>>>>>>>>                Else Begin
78613>>>>>>>>>>>                    Move True to bParent
78614>>>>>>>>>>>                    Move hoParentNode to hoNode
78615>>>>>>>>>>>                End
78615>>>>>>>>>>>>
78615>>>>>>>>>>>            End
78615>>>>>>>>>>>>
78615>>>>>>>>>>>        End
78616>>>>>>>>>>>>
78616>>>>>>>>>>>        Function_Return sNameSpace
78617>>>>>>>>>>>    End_Function
78618>>>>>>>>>>>
78618>>>>>>>>>>>
78618>>>>>>>>>>>
78618>>>>>>>>>>>End_Class
78619>>>>>>>>>>>
78619>>>>>>>>>>>// Set up basic inheritance for specialized forms of XML classes.
78619>>>>>>>>>>>// This needs to be done so we can make objects of these types.
78619>>>>>>>>>>>
78619>>>>>>>>>>>Class cXMLDOMElement is a BaseXmlDomElement
78620>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
78621>>>>>>>>>>>
78621>>>>>>>>>>>// Send AddAttribute
78621>>>>>>>>>>>// Get  AddAttributeNode
78621>>>>>>>>>>>// Send RemoveAttribute
78621>>>>>>>>>>>// Get  AttributeValue
78621>>>>>>>>>>>// Get  AttributeValueNode
78621>>>>>>>>>>>
78621>>>>>>>>>>>// Send AddAttributeNS
78621>>>>>>>>>>>// Get  AddAttributeNodeNS
78621>>>>>>>>>>>// Send RemoveAttributeNs
78621>>>>>>>>>>>// Get  AttributeValueNS
78621>>>>>>>>>>>// Get  AttributeValueNodeNS
78621>>>>>>>>>>>
78621>>>>>>>>>>>    // Should use AddAttributeValue...does same thing
78621>>>>>>>>>>>    Procedure SetAttributeValue String sName String sValue
78623>>>>>>>>>>>        Send AddAttribute sName sValue
78624>>>>>>>>>>>    End_Procedure
78625>>>>>>>>>>>
78625>>>>>>>>>>>    // Note: Get_AttributeValue already there
78625>>>>>>>>>>>
78625>>>>>>>>>>>    Procedure RemoveAttribute String sName
78627>>>>>>>>>>>        Integer iVal
78627>>>>>>>>>>>        Get RemoveAttribute sName to iVal
78628>>>>>>>>>>>    End_Procedure
78629>>>>>>>>>>>
78629>>>>>>>>>>>    Function AttributeValueNS String sNameSpace String sBaseName Returns String
78631>>>>>>>>>>>        String sValue
78631>>>>>>>>>>>        Handle hinfcItem
78631>>>>>>>>>>>        Handle hoDoc hoTempAttributeNodes hoNode
78631>>>>>>>>>>>        Integer hinfcAttributes
78631>>>>>>>>>>>        
78631>>>>>>>>>>>//        // test if the basename attribute exists at all. This is an opimization as this
78631>>>>>>>>>>>//        // message is much faster allowing for quicker false matches (good for client web-services).
78631>>>>>>>>>>>//        Get AttributeValue sBaseName to sValue // doesn't work as expected
78631>>>>>>>>>>>//        If (sValue<>"") Begin 
78631>>>>>>>>>>>            Get TempAttributeNodes to hoTempAttributeNodes
78632>>>>>>>>>>>            Get QualifiedItem of hoTempAttributeNodes sBaseName sNameSpace  to hinfcItem
78633>>>>>>>>>>>            Set XMLInterface of hoTempAttributeNodes to 0
78634>>>>>>>>>>>            If hinfcItem Begin
78636>>>>>>>>>>>                Get DocumentObject to hoDoc
78637>>>>>>>>>>>                Get phoTempDomNode of hoDoc to hoNode
78638>>>>>>>>>>>                Set XMLInterface of hoNode to hinfcItem
78639>>>>>>>>>>>                Get psNodeValue of hoNode to sValue
78640>>>>>>>>>>>                Set XMLInterface of hoNode to 0
78641>>>>>>>>>>>            End
78641>>>>>>>>>>>>
78641>>>>>>>>>>>//        End
78641>>>>>>>>>>>        Function_Return sValue
78642>>>>>>>>>>>    End_Function
78643>>>>>>>>>>>
78643>>>>>>>>>>>// replaced with optimized version above
78643>>>>>>>>>>>//    Function AttributeValueNS String sNameSpace String sBaseName Returns String
78643>>>>>>>>>>>//        Handle hoAttr
78643>>>>>>>>>>>//        String sValue
78643>>>>>>>>>>>//
78643>>>>>>>>>>>//        Get AttributeValueNodeNS sNameSpace sBaseName to hoAttr
78643>>>>>>>>>>>//        If hoAttr Begin
78643>>>>>>>>>>>//            Get Value of hoAttr to sValue
78643>>>>>>>>>>>//            Send destroy of hoAttr
78643>>>>>>>>>>>//        End
78643>>>>>>>>>>>//        function_return sValue
78643>>>>>>>>>>>//    end_function
78643>>>>>>>>>>>
78643>>>>>>>>>>>    Procedure RemoveAttributeNS String sNameSpace String sBaseName
78645>>>>>>>>>>>        Handle hoAttrs hoAttr
78645>>>>>>>>>>>        String sValue
78645>>>>>>>>>>>        Get TempAttributeNodes to hoAttrs
78646>>>>>>>>>>>        If hoAttrs Begin
78648>>>>>>>>>>>            Get RemoveQualifiedNode of hoAttrs sNamespace sBaseName to hoAttr
78649>>>>>>>>>>>            Set XMLInterface of hoAttrs to 0
78650>>>>>>>>>>>            If hoAttr ;                Send destroy of hoAttr
78653>>>>>>>>>>>        End
78653>>>>>>>>>>>>
78653>>>>>>>>>>>    End_Procedure
78654>>>>>>>>>>>
78654>>>>>>>>>>>End_Class
78655>>>>>>>>>>>
78655>>>>>>>>>>>Class cXMLDOMNode is a BaseXmlDomNode
78656>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
78657>>>>>>>>>>>End_Class
78658>>>>>>>>>>>
78658>>>>>>>>>>>Class cXMLDOMAttribute is a BaseXmlDomAttribute
78659>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
78660>>>>>>>>>>>End_Class
78661>>>>>>>>>>>
78661>>>>>>>>>>>Class cXMLDOMComment is a BaseXmlDomComment
78662>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
78663>>>>>>>>>>>End_Class
78664>>>>>>>>>>>
78664>>>>>>>>>>>Class cXMLDOMProcessingInstruction is a BaseXmlDomProcessingInstruction
78665>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
78666>>>>>>>>>>>End_Class
78667>>>>>>>>>>>
78667>>>>>>>>>>>Class cXMLDOMTextNode is a BaseXmlDomTextNode
78668>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
78669>>>>>>>>>>>End_Class
78670>>>>>>>>>>>
78670>>>>>>>>>>>Class cXMLDOMCDATASection is a BaseXmlDomCDATASection
78671>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
78672>>>>>>>>>>>End_Class
78673>>>>>>>>>>>
78673>>>>>>>>>>>Class cXMLDOMDocumentType is a BaseXmlDomDocumentType
78674>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
78675>>>>>>>>>>>    
78675>>>>>>>>>>>
78675>>>>>>>>>>>//        Function EnumerateEntities Integer iMsg Integer hoReceiver Integer bEnumerate Integer iSomeValue Returns Handle
78675>>>>>>>>>>>//            Integer i
78675>>>>>>>>>>>//            Integer hoNode
78675>>>>>>>>>>>//            Integer hoNamedNodeMap
78675>>>>>>>>>>>//            Integer hinfcNamedNodeMap
78675>>>>>>>>>>>//            Integer iLength
78675>>>>>>>>>>>
78675>>>>>>>>>>>//            Get phEntities To hinfcNamedNodeMap
78675>>>>>>>>>>>
78675>>>>>>>>>>>//            showln "The interface of the named node map is " hinfcNamedNodeMap
78675>>>>>>>>>>>
78675>>>>>>>>>>>//            If (hinfcNamedNodeMap <> 0) Begin
78675>>>>>>>>>>>//                Get CreateXMLObject U_cXMLDOMNamedNodeMap hinfcNamedNodeMap to hoNamedNodeMap
78675>>>>>>>>>>>//                Get piLength Of hoNamedNodeMap To iLength
78675>>>>>>>>>>>//                Showln "There are " iLength " items in map"
78675>>>>>>>>>>>
78675>>>>>>>>>>>//                ///                For i From 0 To (NodeListLength(hoNamedNodeMap)-1)
78675>>>>>>>>>>>//                ///                    // For each record, process its fields.
78675>>>>>>>>>>>//                //                    Get CollectionNode Of hoNamedNodeMap i To hoNode
78675>>>>>>>>>>>//                //                    Send iMsg Of hoReceiver hoNode bEnumerate iSomeValue
78675>>>>>>>>>>>//                //                    Send Destroy_Object Of hoNode
78675>>>>>>>>>>>//                //                Loop
78675>>>>>>>>>>>//            End
78675>>>>>>>>>>>//            Send Destroy To hoNamedNodeMap
78675>>>>>>>>>>>//            Function_Return 0
78675>>>>>>>>>>>//        End_Function
78675>>>>>>>>>>>
78675>>>>>>>>>>>//        Function EnumerateNotations Integer iMsg Integer hoReceiver Integer bEnumerate Integer iSomeValue Returns Handle
78675>>>>>>>>>>>//            Integer i
78675>>>>>>>>>>>//            Integer hoNode
78675>>>>>>>>>>>//            Integer hoNamedNodeMap
78675>>>>>>>>>>>//            Integer hinfcNamedNodeMap
78675>>>>>>>>>>>//            Integer iLength
78675>>>>>>>>>>>
78675>>>>>>>>>>>//            Object oNamedNodeMap Is A cXMLDOMNamedNodeMap
78675>>>>>>>>>>>//                Move Self To hoNamedNodeMap
78675>>>>>>>>>>>//            End_Object
78675>>>>>>>>>>>
78675>>>>>>>>>>>//            Get phNotations To hinfcNamedNodeMap
78675>>>>>>>>>>>
78675>>>>>>>>>>>//            showln "The interface of the named node map is " hinfcNamedNodeMap
78675>>>>>>>>>>>
78675>>>>>>>>>>>//            If (hinfcNamedNodeMap <> 0) Begin
78675>>>>>>>>>>>//                Set XMLInterface Of hoNamedNodeMap To hinfcNamedNodeMap
78675>>>>>>>>>>>//                Get piLength Of hoNamedNodeMap To iLength
78675>>>>>>>>>>>//                Showln "There are " iLength " items in map"
78675>>>>>>>>>>>
78675>>>>>>>>>>>/////                For i From 0 To (NodeListLength(hoNamedNodeMap)-1)
78675>>>>>>>>>>>/////                    // For each record, process its fields.
78675>>>>>>>>>>>////                    Get CollectionNode Of hoNamedNodeMap i To hoNode
78675>>>>>>>>>>>////                    Send iMsg Of hoReceiver hoNode bEnumerate iSomeValue
78675>>>>>>>>>>>////                    Send Destroy_Object Of hoNode
78675>>>>>>>>>>>////                Loop
78675>>>>>>>>>>>//            End
78675>>>>>>>>>>>//            Send Destroy_Object To hoNamedNodeMap
78675>>>>>>>>>>>//            Function_Return 0
78675>>>>>>>>>>>//        End_Function
78675>>>>>>>>>>>
78675>>>>>>>>>>>End_Class
78676>>>>>>>>>>>
78676>>>>>>>>>>>Class cXMLDOMNotation is a BaseXmlDomNotation
78677>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
78678>>>>>>>>>>>End_Class
78679>>>>>>>>>>>
78679>>>>>>>>>>>Class cXMLDOMEntity is a BaseXmlDomEntity
78680>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
78681>>>>>>>>>>>End_Class
78682>>>>>>>>>>>
78682>>>>>>>>>>>Class cXMLDOMEntityReference is a BaseXmlDomEntityReference
78683>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
78684>>>>>>>>>>>End_Class
78685>>>>>>>>>>>
78685>>>>>>>>>>>Class cXMLDOMDocumentFragment is a BaseXmlDomDocumentFragment
78686>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
78687>>>>>>>>>>>End_Class
78688>>>>>>>>>>>
78688>>>>>>>>>>>
78688>>>>>>>>>>>Class cXMLDOMParseError is a BaseXMLDomParseError
78689>>>>>>>>>>>    // returns an error sub-object as a sibling of this error object
78689>>>>>>>>>>>    Function ErrorItemNode Integer iItem Returns Handle
78691>>>>>>>>>>>        Handle hoParseErrorNode hoParent
78691>>>>>>>>>>>        Handle hParseErrorIntf
78691>>>>>>>>>>>        Get ErrorItem iItem to hParseErrorIntf
78692>>>>>>>>>>>        If (hParseErrorIntf) Begin
78694>>>>>>>>>>>            // add to parent in case developer destroys the current object
78694>>>>>>>>>>>            Get Parent to hoParent
78695>>>>>>>>>>>            Get Create of hoParent U_cXMLDOMParseError to hoParseErrorNode
78696>>>>>>>>>>>            Set XmlInterface of hoParseErrorNode to hParseErrorIntf
78697>>>>>>>>>>>        End
78697>>>>>>>>>>>>
78697>>>>>>>>>>>        Function_Return hoParseErrorNode
78698>>>>>>>>>>>    End_Function         
78699>>>>>>>>>>>End_Class
78700>>>>>>>>>>>
78700>>>>>>>>>>>// Base document class with Base functions.
78700>>>>>>>>>>>
78700>>>>>>>>>>>Class cXMLDOMDocument is an BaseXmlDomDocument
78701>>>>>>>>>>>
78701>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
78702>>>>>>>>>>>
78702>>>>>>>>>>>    Procedure Construct_Object
78704>>>>>>>>>>>        Handle hInfc
78704>>>>>>>>>>>        Forward Send Construct_Object
78706>>>>>>>>>>>        Property String psDocumentName ""
78707>>>>>>>>>>>        Property Integer phPrivateDocumentElement 0
78708>>>>>>>>>>>        Property Handle phoTempDomNode (Create(Self,U_cXMLDomNode))
78709>>>>>>>>>>>        Property Handle phoTempDomNodeMap (Create(Self,U_cXMLDOMNamedNodeMap))
78710>>>>>>>>>>>        
78710>>>>>>>>>>>        // added in 15.1. If no COM pointer, msxml6 is most likely not installed. This will
78710>>>>>>>>>>>        // raise an unhandled error, which could be augmented to do something else.
78710>>>>>>>>>>>        Get XmlInterface to hInfc
78711>>>>>>>>>>>        If (hInfc=0) Begin
78713>>>>>>>>>>>            Send ErrorCreatingXMLObject
78714>>>>>>>>>>>        End
78714>>>>>>>>>>>>
78714>>>>>>>>>>>        
78714>>>>>>>>>>>        // as of 18.0 pbAsync now defaults to False. In most cases, this is what you want
78714>>>>>>>>>>>        Set pbAsync to False
78715>>>>>>>>>>>    End_Procedure
78716>>>>>>>>>>>
78716>>>>>>>>>>>    // returns the classId for the passed NodeType. This is a good augmentation point. All nodes
78716>>>>>>>>>>>    // within an xml document come here to get a class. So, if you want to augment and return a
78716>>>>>>>>>>>    // different class, just check the node type and return whatever -- else forward
78716>>>>>>>>>>>
78716>>>>>>>>>>>    Function NodeClassId Integer iType Returns Integer
78718>>>>>>>>>>>        Integer iClassId
78718>>>>>>>>>>>        Case Begin
78718>>>>>>>>>>>            Case (iType=NODE_ELEMENT)                   Move U_cXMLDOMElement      to iClassId
78721>>>>>>>>>>>            Case (iType=NODE_ATTRIBUTE)                 Move U_cXMLDOMAttribute    to iClassId
78725>>>>>>>>>>>            Case (iType=NODE_TEXT)                      Move U_cXMLDOMTextNode     to iClassId
78729>>>>>>>>>>>            Case (iType=NODE_CDATA_SECTION)             Move U_cXMLDOMCDATASection to iClassId
78733>>>>>>>>>>>            Case (iType=NODE_ENTITY_REFERENCE)          Move U_cXMLDOMEntityReference to iClassId
78737>>>>>>>>>>>            Case (iType=NODE_ENTITY)                    Move U_cXMLDOMEntity       to iClassId
78741>>>>>>>>>>>            Case (iType=NODE_PROCESSING_INSTRUCTION)    Move U_cXMLDOMProcessingInstruction to iClassId
78745>>>>>>>>>>>            Case (iType=NODE_COMMENT)                   Move U_cXMLDOMComment      to iClassId
78749>>>>>>>>>>>            Case (iType=NODE_DOCUMENT)                  Move U_cXMLDOMDocument     to iClassId
78753>>>>>>>>>>>            Case (iType=NODE_DOCUMENT_TYPE)             Move U_cXMLDOMDocumentType to iClassId
78757>>>>>>>>>>>            Case (iType=NODE_DOCUMENT_FRAGMENT)         Move U_cXMLDOMDocumentFragment to iClassId
78761>>>>>>>>>>>            Case (iType=NODE_NOTATION)                  Move U_cXMLDOMNotation     to iClassId
78765>>>>>>>>>>>            Case (iType=0)                              Move 0                     to iClassId // this is an error!!
78769>>>>>>>>>>>            Case Else                                   Move U_cXMLDOMNode         to iClassId
78771>>>>>>>>>>>        Case End
78771>>>>>>>>>>>        Function_Return iClassId
78772>>>>>>>>>>>    End_Function
78773>>>>>>>>>>>
78773>>>>>>>>>>>    // Load an XML Document. The name of the document is stored in a property
78773>>>>>>>>>>>    // that must be set for this function to work correctly.
78773>>>>>>>>>>>
78773>>>>>>>>>>>    Function LoadXMLDocument Returns Integer
78775>>>>>>>>>>>        String sDocumentName
78775>>>>>>>>>>>        Integer bRetVal
78775>>>>>>>>>>>        Get psDocumentName to sDocumentName
78776>>>>>>>>>>>        Get LoadDocument sDocumentName to bRetVal
78777>>>>>>>>>>>        If (bRetVal = 0);            Function_Return True
78780>>>>>>>>>>>        Else;            Function_Return False
78782>>>>>>>>>>>    End_Function
78783>>>>>>>>>>>
78783>>>>>>>>>>>    Function SaveXMLDocument Returns Integer
78785>>>>>>>>>>>        String sDocumentName
78785>>>>>>>>>>>        Integer bRetVal
78785>>>>>>>>>>>        Get psDocumentName to sDocumentName
78786>>>>>>>>>>>        Get SaveDocument sDocumentName to bRetVal
78787>>>>>>>>>>>        Function_Return bRetVal
78788>>>>>>>>>>>    End_Function
78789>>>>>>>>>>>
78789>>>>>>>>>>>    // Load an XML from a string. This aguments the C message to ret 1 if Ok and 0 if error.
78789>>>>>>>>>>>    //
78789>>>>>>>>>>>    Function LoadXML String sXML Returns Integer
78791>>>>>>>>>>>        Integer bRetVal
78791>>>>>>>>>>>        // for some reason the parser will not work properly with embedded double quotes.
78791>>>>>>>>>>>        // Change all " to ' in document.
78791>>>>>>>>>>>        //Move (replaces('"',sXML,"'")) to sXML  // removed this. Bad Idea.
78791>>>>>>>>>>>        Forward Get LoadXml sXML to bRetVal
78793>>>>>>>>>>>        If (bRetVal = 0) ;            Function_Return True
78796>>>>>>>>>>>        Else;            Function_Return False
78798>>>>>>>>>>>    End_Function
78799>>>>>>>>>>>
78799>>>>>>>>>>>    // Load an XML string from an address. This aguments the C message to ret 1 if Ok and 0 if error.
78799>>>>>>>>>>>    //
78799>>>>>>>>>>>    Function LoadXMLFromAddress Address pXML Returns Integer
78801>>>>>>>>>>>        Integer bRetVal
78801>>>>>>>>>>>        Forward Get LoadXmlFromAddress pXML to bRetVal
78803>>>>>>>>>>>        If (bRetVal = 0) ;            Function_Return True
78806>>>>>>>>>>>        Else;            Function_Return False
78808>>>>>>>>>>>    End_Function
78809>>>>>>>>>>>
78809>>>>>>>>>>>
78809>>>>>>>>>>>    // Allow Nodes and Node node lists to get the parent document.
78809>>>>>>>>>>>
78809>>>>>>>>>>>    Function DocumentObject Returns Handle
78811>>>>>>>>>>>        Function_Return Self
78812>>>>>>>>>>>    End_Function
78813>>>>>>>>>>>
78813>>>>>>>>>>>    // Access to the root node allows for searches and iterations.
78813>>>>>>>>>>>    // The root node is a cNode.
78813>>>>>>>>>>>
78813>>>>>>>>>>>    Function DocumentElement Returns Handle
78815>>>>>>>>>>>        Integer hNewNode       // Object ID of Root Node
78815>>>>>>>>>>>        Integer infcNode   // XML Element Interface
78815>>>>>>>>>>>// we used to buffer this so we'd always return the same object. This is dangerous. If the devloper
78815>>>>>>>>>>>// deletes the root and then creates some other object with this name, we will have problems. Now we
78815>>>>>>>>>>>// always create a new root now - which means you can create multiple roots (which is probably ok).
78815>>>>>>>>>>>
78815>>>>>>>>>>>//        Get phPrivateDocumentElement to hNewNode
78815>>>>>>>>>>>//        // if for some reason the developer sends destroy to the root element then
78815>>>>>>>>>>>//        // we must check that acutally exists. If not, create the root all over again
78815>>>>>>>>>>>//        Get Object_Id of hNewNode to hNewNode // if Object no longer exists, 0 is returned
78815>>>>>>>>>>>//        If not (hNewNode) Begin
78815>>>>>>>>>>>//            // Call XML to get the document root element.
78815>>>>>>>>>>>//            Get phDocumentElement To infcNode
78815>>>>>>>>>>>//            If infcNode Begin
78815>>>>>>>>>>>//                Get CreateXMLObject U_cXMLDOMElement infcNode to hNewNode
78815>>>>>>>>>>>//                Set phPrivateDocumentElement to hNewNode
78815>>>>>>>>>>>//            end
78815>>>>>>>>>>>//        End
78815>>>>>>>>>>>
78815>>>>>>>>>>>        Get phDocumentElement to infcNode
78816>>>>>>>>>>>        If infcNode Begin
78818>>>>>>>>>>>            Get CreateXMLObject U_cXMLDOMElement infcNode to hNewNode
78819>>>>>>>>>>>            Set phPrivateDocumentElement to hNewNode // we no longer use this at all
78820>>>>>>>>>>>        End
78820>>>>>>>>>>>>
78820>>>>>>>>>>>        Function_Return hNewNode
78821>>>>>>>>>>>    End_Function
78822>>>>>>>>>>>
78822>>>>>>>>>>>    //  CreateRootNode is used to set up the first element in a document.
78822>>>>>>>>>>>    //  It should only be used when creating new files.
78822>>>>>>>>>>>
78822>>>>>>>>>>>    Function CreateDocumentElement String sTagName Returns Handle
78824>>>>>>>>>>>        Integer hNewNode       // Object ID of Root Node
78824>>>>>>>>>>>        Integer infcNode   // XML Element Interface
78824>>>>>>>>>>>        // Call XML to create an element in the document.
78824>>>>>>>>>>>        Get CreateElement sTagName to infcNode
78825>>>>>>>>>>>        // Tie the element interface to the DataFlex object.
78825>>>>>>>>>>>        If infcNode ;            Get CreateXMLObject U_cXMLDOMElement infcNode to hNewNode
78828>>>>>>>>>>>        // Call XML to set the root element of the document.
78828>>>>>>>>>>>        Set phDocumentElement to infcNode
78829>>>>>>>>>>>        Set phPrivateDocumentElement to hNewNode
78830>>>>>>>>>>>        Function_Return hNewNode
78831>>>>>>>>>>>    End_Function
78832>>>>>>>>>>>
78832>>>>>>>>>>>    Function CreateDocumentElementNS String sNamespace String sTagName Returns Handle
78834>>>>>>>>>>>        Integer hNewNode       // Object ID of Root Node
78834>>>>>>>>>>>        Integer infcNode iType  // XML Element Interface
78834>>>>>>>>>>>        Get CreateElementNodeNS sNameSpace sTagName "" to hNewNode
78835>>>>>>>>>>>        Get XmlInterface of hNewNode to infcNode
78836>>>>>>>>>>>        Set phDocumentElement to infcNode
78837>>>>>>>>>>>        Set phPrivateDocumentElement to hNewNode
78838>>>>>>>>>>>        Function_Return hNewNode
78839>>>>>>>>>>>    End_Function
78840>>>>>>>>>>>
78840>>>>>>>>>>>
78840>>>>>>>>>>>
78840>>>>>>>>>>>    // return the DocType as a document-type object. Returns 0 if no dtd
78840>>>>>>>>>>>    // Access to information from the doc type object is limited. Use get psXML
78840>>>>>>>>>>>    Function DocTypeNode Returns Handle
78842>>>>>>>>>>>        Handle hinfcDocType hoDocType
78842>>>>>>>>>>>        Get phDocType to hinfcDocType
78843>>>>>>>>>>>        If hinfcDocType ;            Get CreateXMLObject U_cXMLDOMDocumentType hinfcDocType to hoDocType
78846>>>>>>>>>>>        Function_Return hoDocType
78847>>>>>>>>>>>    End_Function
78848>>>>>>>>>>>
78848>>>>>>>>>>>    Function phXMLErrorObject Returns Handle
78850>>>>>>>>>>>        Integer hoParseErrorObject
78850>>>>>>>>>>>        Integer hInfcParseError
78850>>>>>>>>>>>        Get phParseError to hInfcParseError
78851>>>>>>>>>>>        If hInfcParseError ;            Get CreateXMLObject U_cXMLDOMParseError hinfcParseError to hoParseErrorObject
78854>>>>>>>>>>>        Function_Return hoParseErrorObject
78855>>>>>>>>>>>    End_Function
78856>>>>>>>>>>>
78856>>>>>>>>>>>    //  The following procedure is meant to be overridden by one provided by the developer.
78856>>>>>>>>>>>
78856>>>>>>>>>>>    Procedure BasicParseErrorReport
78858>>>>>>>>>>>        String sProblem
78858>>>>>>>>>>>        String sLinePosition
78858>>>>>>>>>>>        String sDescr
78858>>>>>>>>>>>        String sReason
78858>>>>>>>>>>>        String sSource
78858>>>>>>>>>>>        Integer hoParseErrorObject
78858>>>>>>>>>>>        Get phXMLErrorObject to hoParseErrorObject
78859>>>>>>>>>>>        If hoParseErrorObject Begin
78861>>>>>>>>>>>            Move (SFormat(C_$CannotLoad, psDocumentName(Self)) + "."+character(13)+character(10)) to sProblem
78862>>>>>>>>>>>            Move (SFormat(C_$ParsingError, piLine(hoParseErrorObject), piLinePos(hoParseErrorObject))) to sLinePosition
78863>>>>>>>>>>>            Move (sLinePosition +character(13)+character(10)) to sLinePosition
78864>>>>>>>>>>>
78864>>>>>>>>>>>            Move (C_$Reason + ":" * (psReason(hoParseErrorObject))  +character(13)+character(10)) to sReason
78865>>>>>>>>>>>            Move (C_$Source + ":" * (psSrcText(hoParseErrorObject))) to sSource
78866>>>>>>>>>>>            Move (sProblem + sLinePosition + sReason + sSource) to sDescr
78867>>>>>>>>>>>            Error DFERR_XML_INTERNAL_ERROR sDescr
78868>>>>>>>>>>>>
78868>>>>>>>>>>>            Send Destroy of hoParseErrorObject
78869>>>>>>>>>>>        End
78869>>>>>>>>>>>>
78869>>>>>>>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR C_$NotCreatedParseObject
78871>>>>>>>>>>>    End_Procedure
78872>>>>>>>>>>>
78872>>>>>>>>>>>    // bind an xml interface node to the passed XML object. If the
78872>>>>>>>>>>>    // object type is of the wrong type, we will destroy it and recreate it
78872>>>>>>>>>>>    // which is why hoNode is passed byRef.
78872>>>>>>>>>>>    // to use this you'd have to use the lower level private messages to get the
78872>>>>>>>>>>>    // xml interface handles and then bind them to an object. Just like in COM you could
78872>>>>>>>>>>>    // bind these to the same object, which might save some parsing time. This is made private
78872>>>>>>>>>>>    // because the time savings would probably be small and would not justify the extra
78872>>>>>>>>>>>    // complexity.
78872>>>>>>>>>>>    // It is a programming error to pass this a zero handle.
78872>>>>>>>>>>>    Procedure BindXMLInfc Handle hInfc Handle ByRef hoNode
78874>>>>>>>>>>>        Integer iType iClassId iType2
78874>>>>>>>>>>>        Get piNodeType of hoNode to iType2 // type of the DF XML object
78875>>>>>>>>>>>        
78875>>>>>>>>>>>        // Get the node type of the infc handle w/o creating a DF object
78875>>>>>>>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_piNodeType, hinfc, 0, 0, 0, 0)) to iType
78876>>>>>>>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_ChangeNodeType, hinfc, iType, 1, 0, 0)) to hInfc
78877>>>>>>>>>>>        If (hinfc=0) Begin
78879>>>>>>>>>>>            // this should not happen and we would need to know about this.
78879>>>>>>>>>>>            Error DFERR_XML_INTERNAL_ERROR (C_$XmlFailedNoDocObject + String(iType))
78880>>>>>>>>>>>>
78880>>>>>>>>>>>            Function_Return 0
78881>>>>>>>>>>>        End
78881>>>>>>>>>>>>
78881>>>>>>>>>>>        // if the type is the same we can reuse the current object and binding it to the interface pointer
78881>>>>>>>>>>>        If (iType=iType2) Begin
78883>>>>>>>>>>>            // resuse Self and return
78883>>>>>>>>>>>            Set XMLInterface of hoNode to hInfc
78884>>>>>>>>>>>        End
78884>>>>>>>>>>>>
78884>>>>>>>>>>>        // if diffrent type, destroy the existing object and recreate it
78884>>>>>>>>>>>        Else Begin
78885>>>>>>>>>>>            Send Destroy of hoNode
78886>>>>>>>>>>>            Get NodeClassId iType to iClassId
78887>>>>>>>>>>>            Get CreateXMLObject iClassId hInfc to hoNode
78888>>>>>>>>>>>        End
78888>>>>>>>>>>>>
78888>>>>>>>>>>>    End_Procedure
78889>>>>>>>>>>>    
78889>>>>>>>>>>>    Function ValidateDocument Returns Handle
78891>>>>>>>>>>>        Handle hParseErrorIntf hoParseError
78891>>>>>>>>>>>        Forward Get ValidateDocument to hParseErrorIntf
78893>>>>>>>>>>>        If hParseErrorIntf Begin
78895>>>>>>>>>>>            Get CreateXMLObject U_cXMLDOMParseError hParseErrorIntf to hoParseError
78896>>>>>>>>>>>        End
78896>>>>>>>>>>>>
78896>>>>>>>>>>>        Function_Return hoParseError
78897>>>>>>>>>>>    End_Function
78898>>>>>>>>>>>    
78898>>>>>>>>>>>    Function AddExternalSchemaDocument String sSchema Handle hoSchema Returns Boolean
78900>>>>>>>>>>>        Handle hInfc
78900>>>>>>>>>>>        Boolean bOk
78900>>>>>>>>>>>        Get XmlInterface of hoSchema to hInfc
78901>>>>>>>>>>>        Forward Get AddExternalSchemaDocument sSchema hInfc to bOk
78903>>>>>>>>>>>        Function_Return (not(bOk))
78904>>>>>>>>>>>    End_Function
78905>>>>>>>>>>>        
78905>>>>>>>>>>>    Function AddExternalSchemaFile String sSchema String sFile Returns Boolean
78907>>>>>>>>>>>        Boolean bOk
78907>>>>>>>>>>>        Forward Get AddExternalSchemaFile sSchema sFile to bOk
78909>>>>>>>>>>>        Function_Return (not(bOk))
78910>>>>>>>>>>>    End_Function
78911>>>>>>>>>>>
78911>>>>>>>>>>>    Procedure Set psSelectionNamespaces String sNamespaces
78913>>>>>>>>>>>        Set psDomSecondLevelProperty "SelectionNamespaces" to sNamespaces
78914>>>>>>>>>>>    End_Procedure
78915>>>>>>>>>>>
78915>>>>>>>>>>>    Function psSelectionNamespaces Returns String
78917>>>>>>>>>>>        String  sNamespaces
78917>>>>>>>>>>>        Get psDomSecondLevelProperty "SelectionNamespaces" to sNamespaces
78918>>>>>>>>>>>        Function_Return sNamespaces
78919>>>>>>>>>>>    End_Function
78920>>>>>>>>>>>    
78920>>>>>>>>>>>    Procedure Set pbMultipleErrorMessages Boolean bMultipleErrors
78922>>>>>>>>>>>        Set pbDomSecondLevelProperty "MultipleErrorMessages" to bMultipleErrors
78923>>>>>>>>>>>    End_Procedure
78924>>>>>>>>>>>
78924>>>>>>>>>>>    Function pbMultipleErrorMessages Returns Boolean
78926>>>>>>>>>>>        Boolean bMultipleErrors
78926>>>>>>>>>>>        Get pbDomSecondLevelProperty "MultipleErrorMessages" to bMultipleErrors
78927>>>>>>>>>>>        Function_Return bMultipleErrors
78928>>>>>>>>>>>    End_Function
78929>>>>>>>>>>>    
78929>>>>>>>>>>>    Procedure ErrorCreatingXMLObject
78931>>>>>>>>>>>        Error DFERR_XML_INTERNAL_ERROR "Could not create XML COM object. MSXML6 may not be properly installed and registered."
78932>>>>>>>>>>>>
78932>>>>>>>>>>>    End_Procedure
78933>>>>>>>>>>>    
78933>>>>>>>>>>>    // returns the last parse error. If 0, you know everything parsed. This can be
78933>>>>>>>>>>>    // used along wit pbReadyState to load XML documents in async mode. 
78933>>>>>>>>>>>    Function LastParseError Returns Integer
78935>>>>>>>>>>>        Integer iErr
78935>>>>>>>>>>>        Handle hoParseErrorReport
78935>>>>>>>>>>>        Get phXMLErrorObject to hoParseErrorReport
78936>>>>>>>>>>>        Get piErrorCode of hoParseErrorReport to iErr
78937>>>>>>>>>>>        Send Destroy of hoParseErrorReport 
78938>>>>>>>>>>>        Function_Return iErr
78939>>>>>>>>>>>    End_Function
78940>>>>>>>>>>>    
78940>>>>>>>>>>>
78940>>>>>>>>>>>End_Class
78941>>>>>>>>>>>
78941>>>>>>>>>Use cXmlHttpTransfer.pkg
Including file: cXmlHttpTransfer.pkg    (C:\Program Files (x86)\DataFlex 18.1\Pkg\cXmlHttpTransfer.pkg)
78941>>>>>>>>>>>//*************************************************************************
78941>>>>>>>>>>>//*
78941>>>>>>>>>>>//*  Copyright (c) 2001 Data Access Corporation, Miami Florida,
78941>>>>>>>>>>>//*  All rights reserved.
78941>>>>>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.
78941>>>>>>>>>>>//*
78941>>>>>>>>>>>//*************************************************************************
78941>>>>>>>>>>>//*
78941>>>>>>>>>>>//*  Module Name:
78941>>>>>>>>>>>//*      cXmlHttpTransfer.pkg
78941>>>>>>>>>>>//*
78941>>>>>>>>>>>//*  Creator:
78941>>>>>>>>>>>//*      JJT
78941>>>>>>>>>>>//*
78941>>>>>>>>>>>//*
78941>>>>>>>>>>>//*  Purpose:
78941>>>>>>>>>>>//*      VDF XML internet transfer class definitions.
78941>>>>>>>>>>>//*
78941>>>>>>>>>>>//*************************************************************************
78941>>>>>>>>>>>
78941>>>>>>>>>>>Use cHttpTransfer.pkg
78941>>>>>>>>>>>Use CharTranslate.pkg
78941>>>>>>>>>>>Use Flexml.pkg
78941>>>>>>>>>>>Use RegistryAPI.pkg
78941>>>>>>>>>>>Use cCharTranslate.pkg
Including file: cCharTranslate.pkg    (C:\Program Files (x86)\DataFlex 18.1\Pkg\cCharTranslate.pkg)
78941>>>>>>>>>>>>>Use Variant.pkg
78941>>>>>>>>>>>>>Use CharTranslate.pkg
78941>>>>>>>>>>>>>
78941>>>>>>>>>>>>>Class cCharTranslate is a cObject
78942>>>>>>>>>>>>>
78942>>>>>>>>>>>>>
78942>>>>>>>>>>>>>    // ==========================================================================================
78942>>>>>>>>>>>>>    // UTF16 functions that allow you to move between a char (UTF8, ANS, OEM) and a UTF16 buffer
78942>>>>>>>>>>>>>    // ==========================================================================================
78942>>>>>>>>>>>>>
78942>>>>>>>>>>>>>    // converts from buffer of encoded eCharType to a new UTF16 buffer
78942>>>>>>>>>>>>>    
78942>>>>>>>>>>>>>    // note: Utf16FromBuffer with eCharType of CP_OEM can replace OEMToUTF16Buffer
78942>>>>>>>>>>>>>    Function Utf16FromBuffer  Address pMultiCharBuffer Integer eCharType Integer ByRef iLen Returns Address
78944>>>>>>>>>>>>>        Address pWideBuf
78944>>>>>>>>>>>>>        Integer iWideBufLen iStrLen
78944>>>>>>>>>>>>>        Move 0 to pWideBuf
78945>>>>>>>>>>>>>        Move 0 to iLen
78946>>>>>>>>>>>>>        If (pMultiCharBuffer) Begin
78948>>>>>>>>>>>>>            Move (CStringLength(pMultiCharBuffer)) to iStrLen
78949>>>>>>>>>>>>>            If (iStrLen) Begin
78951>>>>>>>>>>>>>                Move (MultiToWideBuffer(eCharType,pMultiCharBuffer, iStrLen, AddressOf(pWideBuf))) to iLen
78952>>>>>>>>>>>>>                If (iLen=0) Begin
78954>>>>>>>>>>>>>                    Function_Return 0
78955>>>>>>>>>>>>>                End
78955>>>>>>>>>>>>>>
78955>>>>>>>>>>>>>            End
78955>>>>>>>>>>>>>>
78955>>>>>>>>>>>>>        End
78955>>>>>>>>>>>>>>
78955>>>>>>>>>>>>>        Function_Return pWideBuf
78956>>>>>>>>>>>>>    End_Function
78957>>>>>>>>>>>>>    
78957>>>>>>>>>>>>>    Function Utf16FromStr String sValue Integer eCharType Integer ByRef iLen Returns Address
78959>>>>>>>>>>>>>        Address aValue
78959>>>>>>>>>>>>>        Get Utf16FromBuffer (AddressOf(sValue)) eCharType (&iLen) to aValue
78960>>>>>>>>>>>>>        Function_Return aValue
78961>>>>>>>>>>>>>    End_Function
78962>>>>>>>>>>>>>    
78962>>>>>>>>>>>>>    // converts from utf16 buffer to a new buffer of encoded eCharType
78962>>>>>>>>>>>>>    
78962>>>>>>>>>>>>>    // note: Utf16ToBuffer with eCharType of CP_OEM can replace UTFtoOEMBuffer
78962>>>>>>>>>>>>>    Function Utf16ToBuffer Address pWideBuf Integer eCharType Integer iLen Returns Address
78964>>>>>>>>>>>>>        Address pRetBuf
78964>>>>>>>>>>>>>        Integer iRetBufLen
78964>>>>>>>>>>>>>        Move 0 to pRetBuf
78965>>>>>>>>>>>>>        If (pWideBuf and iLen) Begin
78967>>>>>>>>>>>>>            Move (WideToMultiBuffer(eCharType,pWideBuf,iLen,AddressOf(pRetBuf))) to iRetBufLen
78968>>>>>>>>>>>>>            If (iRetBufLen=0) Begin
78970>>>>>>>>>>>>>                Function_Return 0
78971>>>>>>>>>>>>>            End
78971>>>>>>>>>>>>>>
78971>>>>>>>>>>>>>        End
78971>>>>>>>>>>>>>>
78971>>>>>>>>>>>>>        Function_Return pRetBuf
78972>>>>>>>>>>>>>    End_Function
78973>>>>>>>>>>>>>    
78973>>>>>>>>>>>>>    Function Utf16ToStr Address pWideBuf Integer eCharType Integer iLen Returns String
78975>>>>>>>>>>>>>        String sValue
78975>>>>>>>>>>>>>        Address aValue
78975>>>>>>>>>>>>>        Boolean bOk
78975>>>>>>>>>>>>>        Get Utf16ToBuffer pWideBuf eCharType iLen to aValue
78976>>>>>>>>>>>>>        If (not(ValidStringBufferLength(aValue))) Begin
78978>>>>>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
78979>>>>>>>>>>>>>>
78979>>>>>>>>>>>>>        End
78979>>>>>>>>>>>>>>
78979>>>>>>>>>>>>>        Move aValue to sValue
78980>>>>>>>>>>>>>        Move (Free(aValue)) to bOk
78981>>>>>>>>>>>>>        Function_Return sValue    
78982>>>>>>>>>>>>>    End_Function
78983>>>>>>>>>>>>>    
78983>>>>>>>>>>>>>
78983>>>>>>>>>>>>>    // ==========================================================================================
78983>>>>>>>>>>>>>    // UTF8 functions that allow you to move between a UTF8 buffer and other single char OEM/ASNI
78983>>>>>>>>>>>>>    // ==========================================================================================
78983>>>>>>>>>>>>>
78983>>>>>>>>>>>>>    
78983>>>>>>>>>>>>>    Function Utf8FromBuffer Address pMultiCharBuffer Integer eCharType Returns Address
78985>>>>>>>>>>>>>        Address pWideBuf
78985>>>>>>>>>>>>>        Address pUtf8Buf
78985>>>>>>>>>>>>>        Integer iLen iMultiBufLen
78985>>>>>>>>>>>>>        Boolean bOk
78985>>>>>>>>>>>>>        Get Utf16FromBuffer pMultiCharBuffer eCharType (&iLen) to pWideBuf
78986>>>>>>>>>>>>>        If (iLen=0) Begin
78988>>>>>>>>>>>>>            Function_Return 0
78989>>>>>>>>>>>>>        End
78989>>>>>>>>>>>>>>
78989>>>>>>>>>>>>>        Move 0 to pUtf8Buf
78990>>>>>>>>>>>>>        Move (WideToMultiBuffer(CP_UTF8,pWideBuf,iLen,AddressOf(pUtf8Buf))) to iMultiBufLen
78991>>>>>>>>>>>>>        Move (Free(pWideBuf)) to bOk
78992>>>>>>>>>>>>>        Function_Return pUtf8Buf
78993>>>>>>>>>>>>>    End_Function
78994>>>>>>>>>>>>>    
78994>>>>>>>>>>>>>    Function Utf8FromStr String sValue Integer eCharType Returns Address
78996>>>>>>>>>>>>>        Address aValue
78996>>>>>>>>>>>>>        Get Utf8FromBuffer (AddressOf(sValue)) eCharType to aValue
78997>>>>>>>>>>>>>        Function_Return aValue
78998>>>>>>>>>>>>>    End_Function
78999>>>>>>>>>>>>>    
78999>>>>>>>>>>>>>    Function Utf8ToBuffer Address pMultiCharBuffer Integer eCharType Returns Address
79001>>>>>>>>>>>>>        Address pRetBuf pWideBuf
79001>>>>>>>>>>>>>        Integer iWideBufLen
79001>>>>>>>>>>>>>        Integer iRetBufLen
79001>>>>>>>>>>>>>        Boolean bOk
79001>>>>>>>>>>>>>        Get Utf16FromBuffer pMultiCharBuffer CP_UTF8 (&iWideBufLen) to pWideBuf
79002>>>>>>>>>>>>>        If (iWideBufLen=0) Begin
79004>>>>>>>>>>>>>            Function_Return 0
79005>>>>>>>>>>>>>        End
79005>>>>>>>>>>>>>>
79005>>>>>>>>>>>>>        Move 0 to pRetBuf
79006>>>>>>>>>>>>>        Move (WideToMultiBuffer(eCharType,pWideBuf,iWideBufLen,AddressOf(pRetBuf))) to iRetBufLen
79007>>>>>>>>>>>>>        Move (Free(pWideBuf)) to bOk
79008>>>>>>>>>>>>>        Function_Return pRetBuf
79009>>>>>>>>>>>>>    End_Function
79010>>>>>>>>>>>>>    
79010>>>>>>>>>>>>>    Function Utf8ToStr Address pWideBuf Integer eCharType Returns String
79012>>>>>>>>>>>>>        String sValue
79012>>>>>>>>>>>>>        Address aValue
79012>>>>>>>>>>>>>        Boolean bOk
79012>>>>>>>>>>>>>        Get Utf8ToBuffer pWideBuf eCharType to aValue
79013>>>>>>>>>>>>>        If (not(ValidStringBufferLength(aValue))) Begin
79015>>>>>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
79016>>>>>>>>>>>>>>
79016>>>>>>>>>>>>>        End
79016>>>>>>>>>>>>>>
79016>>>>>>>>>>>>>        Move aValue to sValue
79017>>>>>>>>>>>>>        Move (Free(aValue)) to bOk
79018>>>>>>>>>>>>>        Function_Return sValue    
79019>>>>>>>>>>>>>    End_Function
79020>>>>>>>>>>>>>
79020>>>>>>>>>>>>>    // ==========================================================================================
79020>>>>>>>>>>>>>    // Variant functions that allow you to move between a variant string (wide char) and other
79020>>>>>>>>>>>>>    // buffer and string types. Normally a Move vVar to sVar does a OEM/Unicode translation. These
79020>>>>>>>>>>>>>    // allow you translate to other formats (UTF8, OEM and ANSI)
79020>>>>>>>>>>>>>    // ==========================================================================================
79020>>>>>>>>>>>>>    
79020>>>>>>>>>>>>>    // Create data buffer from variant string. data buffer is encoded by eCharType
79020>>>>>>>>>>>>>    Function VariantStrToBuffer Variant vValue Integer eCharType Returns Address
79022>>>>>>>>>>>>>        Address aBSTR pRetStr
79022>>>>>>>>>>>>>        Integer iLen iBufLen
79022>>>>>>>>>>>>>        Boolean bOk
79022>>>>>>>>>>>>>        Move 0 to pRetStr
79023>>>>>>>>>>>>>        Get VariantStringLength vValue to iLen
79024>>>>>>>>>>>>>        If (iLen) Begin
79026>>>>>>>>>>>>>            Move (DeRefDw(AddressOf(vValue),8)) to aBSTR
79027>>>>>>>>>>>>>            Move (WideToMultiBuffer(eCharType,aBSTR,iLen,AddressOf(pRetStr))) to iBufLen
79028>>>>>>>>>>>>>        End
79028>>>>>>>>>>>>>>
79028>>>>>>>>>>>>>        Function_Return pRetStr
79029>>>>>>>>>>>>>    End_Function
79030>>>>>>>>>>>>>    
79030>>>>>>>>>>>>>    // Create string from variant string. data buffer is encoded by eCharType
79030>>>>>>>>>>>>>    
79030>>>>>>>>>>>>>    Function VariantStrToStr Variant vValue Integer eCharType Returns String
79032>>>>>>>>>>>>>        String sValue
79032>>>>>>>>>>>>>        Address aValue
79032>>>>>>>>>>>>>        Boolean bOk
79032>>>>>>>>>>>>>        Get VariantStrToBuffer vValue eCharType to aValue
79033>>>>>>>>>>>>>        If (not(ValidStringBufferLength(aValue))) Begin
79035>>>>>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
79036>>>>>>>>>>>>>>
79036>>>>>>>>>>>>>        End
79036>>>>>>>>>>>>>>
79036>>>>>>>>>>>>>        Move aValue to sValue
79037>>>>>>>>>>>>>        Move (Free(aValue)) to bOk
79038>>>>>>>>>>>>>        Function_Return sValue    
79039>>>>>>>>>>>>>    End_Function
79040>>>>>>>>>>>>>    
79040>>>>>>>>>>>>>    // Create variant string from data buffer. data buffer is encoded by eCharType
79040>>>>>>>>>>>>>    
79040>>>>>>>>>>>>>    Function VariantStrFromBuffer Address aSource Integer eCodeType Returns Variant
79042>>>>>>>>>>>>>        Variant vValue
79042>>>>>>>>>>>>>        Address pvValue
79042>>>>>>>>>>>>>        Boolean bOk
79042>>>>>>>>>>>>>        Address pWStr
79042>>>>>>>>>>>>>        Move "" to vValue
79043>>>>>>>>>>>>>        If (aSource) Begin
79045>>>>>>>>>>>>>            //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
79045>>>>>>>>>>>>>            Move 0 to pWStr
79046>>>>>>>>>>>>>            //Convert the Ansi string to Unicode
79046>>>>>>>>>>>>>            Get MultiToWideBuffer eCodeType aSource (CStringLength(aSource)) (AddressOf(pWStr)) to bOk
79047>>>>>>>>>>>>>            //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
79047>>>>>>>>>>>>>            Move 0 to vValue
79048>>>>>>>>>>>>>            Move (AddressOf(vValue)) to pvValue
79049>>>>>>>>>>>>>            //Change the Variant type to VT_BSTR
79049>>>>>>>>>>>>>            Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
79050>>>>>>>>>>>>>            //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
79050>>>>>>>>>>>>>            Move (StoreDw(pvValue,8,SysAllocString(pWStr))) to bOk
79051>>>>>>>>>>>>>            //Now clear up the Unicode string, the Variant owns a BSTR copy of the string
79051>>>>>>>>>>>>>            Move (Free(pWStr)) to bOk
79052>>>>>>>>>>>>>        End
79052>>>>>>>>>>>>>>
79052>>>>>>>>>>>>>        Function_Return vValue
79053>>>>>>>>>>>>>    End_Function
79054>>>>>>>>>>>>>    
79054>>>>>>>>>>>>>    // Create variant string from data string. data string is encoded by eCharType
79054>>>>>>>>>>>>>    
79054>>>>>>>>>>>>>    Function VariantStrFromStr String sValue Integer eCodeType Returns Variant
79056>>>>>>>>>>>>>        Variant vValue
79056>>>>>>>>>>>>>        Get VariantStrFromBuffer (AddressOf(sValue)) eCodeType to vValue
79057>>>>>>>>>>>>>        Function_Return vValue
79058>>>>>>>>>>>>>    End_Function    
79059>>>>>>>>>>>>>    
79059>>>>>>>>>>>>>    // Create buffer of utf16 data from variant. 
79059>>>>>>>>>>>>>    // Returns newly created memory address and length (by reference)
79059>>>>>>>>>>>>>    Function VariantStrToUTF16 Variant vValue Integer ByRef iLen Returns Address
79061>>>>>>>>>>>>>        Address aBSTR pRetStr
79061>>>>>>>>>>>>>        Boolean bOk
79061>>>>>>>>>>>>>        Move 0 to pRetStr
79062>>>>>>>>>>>>>        Get VariantStringLength vValue to iLen
79063>>>>>>>>>>>>>        If (iLen) Begin
79065>>>>>>>>>>>>>            Move (DeRefDw(AddressOf(vValue),8)) to aBSTR
79066>>>>>>>>>>>>>            Move (Alloc(iLen+1 * 2)) to pRetStr
79067>>>>>>>>>>>>>            Move (CopyMemory(pRetStr,aBSTR,(iLen+1 * 2))) to bOk
79068>>>>>>>>>>>>>        End
79068>>>>>>>>>>>>>>
79068>>>>>>>>>>>>>        Function_Return pRetStr
79069>>>>>>>>>>>>>    End_Function
79070>>>>>>>>>>>>>    
79070>>>>>>>>>>>>>    // Create variant from buffer of utf16 data
79070>>>>>>>>>>>>>    Function VariantStrFromUTF16 Address aSource Returns Variant
79072>>>>>>>>>>>>>        Variant vValue
79072>>>>>>>>>>>>>        Address pvValue
79072>>>>>>>>>>>>>        Boolean bOk
79072>>>>>>>>>>>>>        Move "" to vValue
79073>>>>>>>>>>>>>        If (aSource) Begin
79075>>>>>>>>>>>>>            //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
79075>>>>>>>>>>>>>            //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
79075>>>>>>>>>>>>>            Move 0 to vValue
79076>>>>>>>>>>>>>            Move (AddressOf(vValue)) to pvValue
79077>>>>>>>>>>>>>            //Change the Variant type to VT_BSTR
79077>>>>>>>>>>>>>            Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
79078>>>>>>>>>>>>>            //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
79078>>>>>>>>>>>>>            Move (StoreDw(pvValue,8,SysAllocString(aSource))) to bOk
79079>>>>>>>>>>>>>        End
79079>>>>>>>>>>>>>>
79079>>>>>>>>>>>>>        Function_Return vValue
79080>>>>>>>>>>>>>    End_Function
79081>>>>>>>>>>>>>    
79081>>>>>>>>>>>>>    // ==========================================================================================
79081>>>>>>>>>>>>>    // Base64 Encoding functions that allow you to encode to and decode from strings and 
79081>>>>>>>>>>>>>    // Variant strings. Binary data is always buffer
79081>>>>>>>>>>>>>    // ==========================================================================================
79081>>>>>>>>>>>>> 
79081>>>>>>>>>>>>>    Function Base64EncodeToStr Address pBinaryData Integer iBinaryLen Returns String
79083>>>>>>>>>>>>>        Address pBase64
79083>>>>>>>>>>>>>        String sResult
79083>>>>>>>>>>>>>        Integer iVoid iMax
79083>>>>>>>>>>>>>        Get_Argument_Size to iMax
79084>>>>>>>>>>>>>        Move (Base64Encode(pBinaryData, iBinaryLen)) to pBase64
79085>>>>>>>>>>>>>        If (iMax<CStringLength(pBase64)) Begin
79087>>>>>>>>>>>>>            Error DFERR_PROGRAM "Base64 encoded string exceeds max string size"
79088>>>>>>>>>>>>>>
79088>>>>>>>>>>>>>        End
79088>>>>>>>>>>>>>>
79088>>>>>>>>>>>>>        Move pBase64 to sResult
79089>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid    
79090>>>>>>>>>>>>>        Function_Return sResult    
79091>>>>>>>>>>>>>    End_Function
79092>>>>>>>>>>>>>    
79092>>>>>>>>>>>>>    Function Base64DecodeFromStr String sBase64 Integer ByRef iBinaryLen Returns Address
79094>>>>>>>>>>>>>        Address pBinaryData
79094>>>>>>>>>>>>>        String sBinary
79094>>>>>>>>>>>>>        Integer iVoid
79094>>>>>>>>>>>>>        Move (Base64Decode(AddressOf(sBase64), &iBinaryLen)) to pBinaryData
79095>>>>>>>>>>>>>        Function_Return pBinaryData
79096>>>>>>>>>>>>>    End_Function
79097>>>>>>>>>>>>>    
79097>>>>>>>>>>>>>    Function Base64EncodeToVariantStr Address pBinaryData Integer iBinaryLen Returns Variant
79099>>>>>>>>>>>>>        Address aBase64
79099>>>>>>>>>>>>>        Variant vVar
79099>>>>>>>>>>>>>        Integer iBase64Len iVoid
79099>>>>>>>>>>>>>        If (pBinaryData and iBinaryLen) Begin
79101>>>>>>>>>>>>>            Move (Base64Encode(pBinaryData,iBinaryLen)) to aBase64
79102>>>>>>>>>>>>>            Get  VariantStrFromBuffer aBase64 CP_ACP to vVar
79103>>>>>>>>>>>>>            Move (Free(aBase64)) to iVoid
79104>>>>>>>>>>>>>        End
79104>>>>>>>>>>>>>>
79104>>>>>>>>>>>>>        Function_Return vVar
79105>>>>>>>>>>>>>    End_Function
79106>>>>>>>>>>>>>    
79106>>>>>>>>>>>>>    Function Base64DecodeFromVariantStr Variant vBase64Str Integer ByRef iBinaryLen Returns Address
79108>>>>>>>>>>>>>        Address aBase64 pBinaryData
79108>>>>>>>>>>>>>        Integer iVoid
79108>>>>>>>>>>>>>        Move 0 to iBinaryLen
79109>>>>>>>>>>>>>        Get VariantStrToBuffer vBase64Str CP_ACP to aBase64
79110>>>>>>>>>>>>>        If (aBase64) Begin
79112>>>>>>>>>>>>>            Move (Base64Decode(aBase64,&iBinaryLen)) to pBinaryData
79113>>>>>>>>>>>>>            Move (Free(aBase64)) to iVoid
79114>>>>>>>>>>>>>        End
79114>>>>>>>>>>>>>>
79114>>>>>>>>>>>>>        Function_Return pBinaryData
79115>>>>>>>>>>>>>    End_Function
79116>>>>>>>>>>>>>
79116>>>>>>>>>>>>>End_Class
79117>>>>>>>>>>>>>
79117>>>>>>>>>>>
79117>>>>>>>>>>>// Xml Translate modes
79117>>>>>>>>>>>//
79117>>>>>>>>>>>Enum_List
79117>>>>>>>>>>>    Define xtNoTranslate    // no translation
79117>>>>>>>>>>>    Define xtUtf8toOem      // from UTF-8 to OEM
79117>>>>>>>>>>>    Define xtOemtoUtf8      // from OEM to UTF-8
79117>>>>>>>>>>>End_Enum_List
79117>>>>>>>>>>>
79117>>>>>>>>>>>// these define the three characters that define BOM for utf8.
79117>>>>>>>>>>>// These serve no purpos and are rarely used. If used they must be removed 
79117>>>>>>>>>>>Define C_BOM1 for |CI$EF
79117>>>>>>>>>>>Define C_BOM2 for |CI$BB
79117>>>>>>>>>>>Define C_BOM3 for |CI$BF
79117>>>>>>>>>>>
79117>>>>>>>>>>>
79117>>>>>>>>>>>
79117>>>>>>>>>>>// define Xml transfer status codes used by peXmlTransferStatus
79117>>>>>>>>>>>Enum_List
79117>>>>>>>>>>>    Define xtsOk                 // ok
79117>>>>>>>>>>>    Define xtsHttpRequestFailed  // the post/get http request returned an error
79117>>>>>>>>>>>    Define xtsBadRequest         // Request data is bad or missing
79117>>>>>>>>>>>    Define xtsInvalidContentType // response content type not xml
79117>>>>>>>>>>>    Define xtsNoData             // return has no data
79117>>>>>>>>>>>    Define xtsNotXml             // return value not XML (could not load in object)
79117>>>>>>>>>>>    Define xtsError              // unspecified return error
79117>>>>>>>>>>>End_Enum_List
79117>>>>>>>>>>>
79117>>>>>>>>>>>
79117>>>>>>>>>>>Class cXmlHttpTransfer is a cHttpTransfer
79118>>>>>>>>>>>
79118>>>>>>>>>>>   Procedure Construct_Object
79120>>>>>>>>>>>      Forward Send Construct_object
79122>>>>>>>>>>>
79122>>>>>>>>>>>      Property Integer peTranslateSent     xtOemtoUtf8  // translation mode for sent posted data
79123>>>>>>>>>>>
79123>>>>>>>>>>>      Property Integer peTranslateReceived xtUtf8toOem  // tranlation mode for received data
79124>>>>>>>>>>>
79124>>>>>>>>>>>      Property String  psContentTypeSent "text/xml; charset=utf-8"     // default content type for posted data
79125>>>>>>>>>>>
79125>>>>>>>>>>>      Property Boolean pbClearHeaders      True         // should headers always be cleared before a post
79126>>>>>>>>>>>
79126>>>>>>>>>>>      Property Address paDataReceived 0                 // maintained by object
79127>>>>>>>>>>>
79127>>>>>>>>>>>      Property Integer piDataReceivedLength 0           // maintained by object
79128>>>>>>>>>>>
79128>>>>>>>>>>>      Property String  psContentTypeReceived ''         // content type received
79129>>>>>>>>>>>
79129>>>>>>>>>>>      Property String  psContentTypeExpected 'text/xml' // content type received - expected value should be contained in here.
79130>>>>>>>>>>>
79130>>>>>>>>>>>      Property Boolean pbDataRequiredSent True
79131>>>>>>>>>>>      Property Boolean pbDataRequiredReceived True
79132>>>>>>>>>>>      Property Integer peXmlTransferStatus xtsOk
79133>>>>>>>>>>>      
79133>>>>>>>>>>>      // this uses variants to do the xml transfers for HttpPostXmlNode and HttpGetXmlNode, which means that
79133>>>>>>>>>>>      // output will always be UTF8, which will get converted directly to XML without going through an OEM
79133>>>>>>>>>>>      // translation, meaning no data loss.
79133>>>>>>>>>>>      Property Boolean pbUseVariantXfer True
79134>>>>>>>>>>>      
79134>>>>>>>>>>>      // if true, the http post does not happend and whatever was posted is just returned as a copy.
79134>>>>>>>>>>>      // Good for internal Testing
79134>>>>>>>>>>>      Property Boolean pbPostLoopTest False 
79135>>>>>>>>>>>      
79135>>>>>>>>>>>      Property Handle phoCharTranslate (Create(Self,RefClass(cCharTranslate)))
79136>>>>>>>>>>>   End_Procedure
79137>>>>>>>>>>>
79137>>>>>>>>>>>   // private helper function. Convert data passed by pointer to an XML document.
79137>>>>>>>>>>>   // return 0, if error
79137>>>>>>>>>>>   //
79137>>>>>>>>>>>   Function DatatoXml Address aXml Returns Handle
79139>>>>>>>>>>>       Integer iVoid bOk
79139>>>>>>>>>>>       Handle hoXml
79139>>>>>>>>>>>       Move 0 to hoXml
79140>>>>>>>>>>>       // Create the XML dom object at the desktop level so it does not get destroyed
79140>>>>>>>>>>>       // when this cXmlHttpTransfer object is destroyed.
79140>>>>>>>>>>>       Get Create of desktop (RefClass(cXmlDomDocument)) to hoXml
79141>>>>>>>>>>>       Get LoadXmlFromAddress of hoXml aXml to bOk
79142>>>>>>>>>>>       If not bOk Begin
79144>>>>>>>>>>>           Send Destroy of hoXml
79145>>>>>>>>>>>           Move 0 to hoXml
79146>>>>>>>>>>>       End
79146>>>>>>>>>>>>
79146>>>>>>>>>>>       Function_Return hoXml
79147>>>>>>>>>>>   End_Function
79148>>>>>>>>>>>
79148>>>>>>>>>>>   // private helper function. Convert data passed by variant to an XML document.
79148>>>>>>>>>>>   // return 0, if error
79148>>>>>>>>>>>   //
79148>>>>>>>>>>>   Function VarianttoXML Variant vXml Returns Handle
79150>>>>>>>>>>>       Integer bOk
79150>>>>>>>>>>>       Handle hoXml
79150>>>>>>>>>>>       Move 0 to hoXml
79151>>>>>>>>>>>       // Create the XML dom object at the desktop level so it does not get destroyed
79151>>>>>>>>>>>       // when this cXmlHttpTransfer object is destroyed.
79151>>>>>>>>>>>       Get Create of desktop (RefClass(cXmlDomDocument)) to hoXml
79152>>>>>>>>>>>       Get LoadXMLFromVariant of hoXml vXml to  bOk
79153>>>>>>>>>>>       If not bOk Begin
79155>>>>>>>>>>>           Send Destroy of hoXml
79156>>>>>>>>>>>           Move 0 to hoXml
79157>>>>>>>>>>>       End
79157>>>>>>>>>>>>
79157>>>>>>>>>>>       Function_Return hoXml
79158>>>>>>>>>>>   End_Function
79159>>>>>>>>>>>
79159>>>>>>>>>>>   // Translate data. pass: Data and translation mode.
79159>>>>>>>>>>>   //     returns pointer to new translated data 0 if no translate needed.
79159>>>>>>>>>>>   //     Passed data is not changed.
79159>>>>>>>>>>>   // Currently we support: xtUtf8toOem, xtOemtoUtf8 and xtNoTranslate
79159>>>>>>>>>>>   // This is an excellent candidate for augmentation to add more modes
79159>>>>>>>>>>>   //
79159>>>>>>>>>>>   Function TranslateData Integer eXlt Address aData Integer iDataLen Returns Address
79161>>>>>>>>>>>       Address aDataXlt
79161>>>>>>>>>>>       Case Begin
79161>>>>>>>>>>>          Case (eXlt=xtUtf8toOem)
79163>>>>>>>>>>>              Move (Utf8toOemBuffer(aData,iDataLen)) to aDataXlt
79164>>>>>>>>>>>              Case Break
79165>>>>>>>>>>>          Case (eXlt=xtOemtoUtf8)
79168>>>>>>>>>>>              Move (OemToUtf8Buffer(aData,iDataLen)) to aDataXlt
79169>>>>>>>>>>>              Case Break
79170>>>>>>>>>>>          Case Else
79170>>>>>>>>>>>              Move 0 to aDataXlt
79171>>>>>>>>>>>       Case End
79171>>>>>>>>>>>       Function_Return aDataXlt
79172>>>>>>>>>>>   End_Function
79173>>>>>>>>>>>
79173>>>>>>>>>>>   // Clear paDataReceived and free any memory associated w/ pointer
79173>>>>>>>>>>>   //
79173>>>>>>>>>>>   Procedure ClearDataReceived
79175>>>>>>>>>>>        Address aDataReceived
79175>>>>>>>>>>>        Integer iVoid
79175>>>>>>>>>>>        Get paDataReceived to aDataReceived
79176>>>>>>>>>>>        If (aDataReceived<>0) ;            Move (Free(aDataReceived)) to iVoid
79179>>>>>>>>>>>        Set paDataReceived to 0
79180>>>>>>>>>>>        Set piDataReceivedLength to 0
79181>>>>>>>>>>>   End_Procedure
79182>>>>>>>>>>>
79182>>>>>>>>>>>   // augment to release any memory in paDataReceived
79182>>>>>>>>>>>   //
79182>>>>>>>>>>>   Procedure Destroy_Object
79184>>>>>>>>>>>       Send ClearDataReceived
79185>>>>>>>>>>>       Forward Send Destroy_object
79187>>>>>>>>>>>   End_Procedure
79188>>>>>>>>>>>
79188>>>>>>>>>>>   // translate data in paReveived based on peTranslateReceived property.
79188>>>>>>>>>>>   // This clears the data received buffer and returns zero terminated memory pointer
79188>>>>>>>>>>>   // you create invalid translations
79188>>>>>>>>>>>   //
79188>>>>>>>>>>>   Function TranslateDataReceived Returns Address
79190>>>>>>>>>>>       Address aDataReceived aDataReceivedXlt
79190>>>>>>>>>>>       Get paDataReceived to aDataReceived
79191>>>>>>>>>>>       Get TranslateData (peTranslateReceived(Self)) aDataReceived (piDataReceivedLength(Self)) to aDataReceivedXlt
79192>>>>>>>>>>>       If (aDataReceivedXLT<>0) ;  // if translation occurred,          Send ClearDataReceived   // clear out the original received data
79195>>>>>>>>>>>       Else Begin
79196>>>>>>>>>>>          Move aDataReceived to aDataReceivedXlt // if no translation, just point to the existing data
79197>>>>>>>>>>>          Set paDataReceived to 0                // and remove the object's access to that data
79198>>>>>>>>>>>          Set piDataReceivedLength to 0
79199>>>>>>>>>>>       End
79199>>>>>>>>>>>>
79199>>>>>>>>>>>       Function_Return aDataReceivedXlt
79200>>>>>>>>>>>   End_Function
79201>>>>>>>>>>>
79201>>>>>>>>>>>   // called during http transfer. Take passed data and append to paDataReceived.
79201>>>>>>>>>>>   // If new transfer save contenttype.
79201>>>>>>>>>>>   //
79201>>>>>>>>>>>   Procedure OnDataReceived String sContentType String sData
79203>>>>>>>>>>>        Integer bOk iVoid
79203>>>>>>>>>>>        Address aOldData
79203>>>>>>>>>>>        Address aNewData
79203>>>>>>>>>>>        Integer iOldDataLen
79203>>>>>>>>>>>        Integer iDataLen
79203>>>>>>>>>>>        Integer iNewLen
79203>>>>>>>>>>>        Move (length(sData)) to iDataLen
79204>>>>>>>>>>>        If (iDatalen>0) Begin // if passed data is empty--do nothing
79206>>>>>>>>>>>            Get paDataReceived to aOldData
79207>>>>>>>>>>>            If (aOldData=0) Begin                           // first time called, new data
79209>>>>>>>>>>>
79209>>>>>>>>>>>                // check for BOM (Byte Order Marker) at the start of the file.
79209>>>>>>>>>>>                // if found remove it as it serves no purpose and messes up the translate logic.                
79209>>>>>>>>>>>                If (iDataLen>3 and Ascii(Left(sData,1))=C_BOM1 and Ascii(Mid(sData,1,2))=C_BOM2 and Ascii(Mid(sData,1,3))=C_BOM3) Begin
79211>>>>>>>>>>>                    Move (Remove(sData,1,3)) to sData
79212>>>>>>>>>>>                    Move (iDataLen-3) to iDataLen
79213>>>>>>>>>>>                End
79213>>>>>>>>>>>>
79213>>>>>>>>>>>                
79213>>>>>>>>>>>                Set psContentTypeReceived to sContentType   // store content type
79214>>>>>>>>>>>                Move (Alloc(iDataLen+1)) to aNewData  // alloc extra byte for zero termination...just in case.
79215>>>>>>>>>>>                Move 0 to iOldDataLen
79216>>>>>>>>>>>                Move iDataLen to iNewLen
79217>>>>>>>>>>>            End
79217>>>>>>>>>>>>
79217>>>>>>>>>>>            Else Begin
79218>>>>>>>>>>>                Get piDataReceivedLength to iOldDataLen
79219>>>>>>>>>>>                Move (iOldDataLen+iDataLen) to iNewLen
79220>>>>>>>>>>>                Move (ReAlloc(aOldData,iNewLen+1)) to aNewData // note extra byte at end
79221>>>>>>>>>>>            End
79221>>>>>>>>>>>>
79221>>>>>>>>>>>            Move (memcopy(aNewData+iOldDataLen, AddressOf(sData), iDataLen)) to bOk // copy on top of term zero
79222>>>>>>>>>>>            Move (StoreC(aNewData,iNewLen,0)) to iVoid // add terminating zero at end.
79223>>>>>>>>>>>            Set paDataReceived to aNewData
79224>>>>>>>>>>>            Set piDataReceivedLength to iNewLen // length does not include term zero
79225>>>>>>>>>>>        End
79225>>>>>>>>>>>>
79225>>>>>>>>>>>   End_Procedure
79226>>>>>>>>>>>
79226>>>>>>>>>>>   // Post and Receive XML data via node. Returns 0 if failure (could not xfer, bad data, etc.)
79226>>>>>>>>>>>   //
79226>>>>>>>>>>>   Function HttpPostXmlNode  String sHost String sFilePath Handle  hoXmlNode Returns Handle
79228>>>>>>>>>>>       Address aXml aXMLNode
79228>>>>>>>>>>>       Variant vXmlNode vXml
79228>>>>>>>>>>>       Integer iVoid iLen
79228>>>>>>>>>>>       Handle hoXml hoCharTranslate
79228>>>>>>>>>>>       Boolean bUseVariant
79228>>>>>>>>>>>
79228>>>>>>>>>>>       Get pbUseVariantXfer to bUseVariant
79229>>>>>>>>>>>       
79229>>>>>>>>>>>       // if the node is zero, this might be an error. We will test for this later
79229>>>>>>>>>>>       // by seeing if the address point is 0 or the length is 0
79229>>>>>>>>>>>       If not bUseVariant Begin
79231>>>>>>>>>>>        
79231>>>>>>>>>>>           Move 0 to aXmlNode
79232>>>>>>>>>>>           Move 0 to iLen
79233>>>>>>>>>>>           
79233>>>>>>>>>>>           If (hoXmlNode<>0) Begin
79235>>>>>>>>>>>               Get paXml of hoXmlNode to aXmlNode
79236>>>>>>>>>>>               If (aXmlNode<>0) ;                  Move (CStringLength(aXmlNode)) to iLen // we assume data from paXml is always zero terminated
79239>>>>>>>>>>>           End
79239>>>>>>>>>>>>
79239>>>>>>>>>>>           Get HttpPostXmlAddr sHost sFilePath aXmlNode iLen to aXml
79240>>>>>>>>>>>           If aXmlNode ;               Move (free(aXmlNode)) to iVoid
79243>>>>>>>>>>>    
79243>>>>>>>>>>>           // if data is returned (aXML) it is non-zero and content type is correct.
79243>>>>>>>>>>>           // if no data, an error has been registered or no data is an ok condition
79243>>>>>>>>>>>           If (aXml<>0) Begin
79245>>>>>>>>>>>               Get DatatoXml aXml to hoXml
79246>>>>>>>>>>>               If (hoXml=0) Begin
79248>>>>>>>>>>>                   // this indicates that data was returned but it could not be loaded as XML
79248>>>>>>>>>>>                   Set peXmlTransferStatus to xtsNotXml
79249>>>>>>>>>>>                   // store the bad data for debugging purposes
79249>>>>>>>>>>>                   Set paDataReceived to aXml
79250>>>>>>>>>>>                   Set piDataReceivedLength to (CStringLength(aXml))
79251>>>>>>>>>>>               End
79251>>>>>>>>>>>>
79251>>>>>>>>>>>               Else Begin
79252>>>>>>>>>>>                   Move (Free(aXml)) to iVoid
79253>>>>>>>>>>>               End
79253>>>>>>>>>>>>
79253>>>>>>>>>>>           End
79253>>>>>>>>>>>>
79253>>>>>>>>>>>           Else Begin
79254>>>>>>>>>>>              Move 0 to hoXml
79255>>>>>>>>>>>           End
79255>>>>>>>>>>>>
79255>>>>>>>>>>>       End
79255>>>>>>>>>>>>
79255>>>>>>>>>>>       Else Begin
79256>>>>>>>>>>>           Get phoCharTranslate to hoCharTranslate
79257>>>>>>>>>>>           Move '' to vXmlNode
79258>>>>>>>>>>>           If (hoXmlNode<>0) Begin
79260>>>>>>>>>>>               Get pvXml of hoXmlNode to vXmlNode
79261>>>>>>>>>>>           End
79261>>>>>>>>>>>>
79261>>>>>>>>>>>           Get HttpPostXmlVar sHost sFilePath vXmlNode to vXml
79262>>>>>>>>>>>           // if data is returned (aXML) it is non-zero and content type is correct.
79262>>>>>>>>>>>           // if no data, an error has been registered or no data is an ok condition
79262>>>>>>>>>>>           If (vXml<>"") Begin
79264>>>>>>>>>>>               Get VarianttoXML vXml to hoXml
79265>>>>>>>>>>>               If (hoXml=0) Begin
79267>>>>>>>>>>>                   // this indicates that data was returned but it could not be loaded as XML
79267>>>>>>>>>>>                   Set peXmlTransferStatus to xtsNotXml
79268>>>>>>>>>>>                   // store the bad data for debugging purposes. Will store as OEM
79268>>>>>>>>>>>                   Get VariantStrToBuffer of hoCharTranslate vXml CP_OEMCP to aXml
79269>>>>>>>>>>>                   Set paDataReceived to aXml
79270>>>>>>>>>>>                   Set piDataReceivedLength to (VariantStringLength(vXml))
79271>>>>>>>>>>>               End
79271>>>>>>>>>>>>
79271>>>>>>>>>>>           End
79271>>>>>>>>>>>>
79271>>>>>>>>>>>           Else Begin
79272>>>>>>>>>>>              Move 0 to hoXml
79273>>>>>>>>>>>           End
79273>>>>>>>>>>>>
79273>>>>>>>>>>>       End
79273>>>>>>>>>>>>
79273>>>>>>>>>>>       Function_Return hoXml
79274>>>>>>>>>>>   End_Function
79275>>>>>>>>>>>
79275>>>>>>>>>>>   Function HttpPostXmlString String sHost String sFilePath String  sXml Returns String
79277>>>>>>>>>>>       Address aXml
79277>>>>>>>>>>>       Integer iVoid
79277>>>>>>>>>>>       Get HttpPostXmlAddr sHost sFilePath (AddressOf(sXml)) (Length(sXml)) to aXml
79278>>>>>>>>>>>       If (aXml<>0) Begin
79280>>>>>>>>>>>          Move aXml to sXml           // if data returned, assign to string
79281>>>>>>>>>>>          Move (Free(aXml)) to iVoid  // and free data
79282>>>>>>>>>>>       End
79282>>>>>>>>>>>>
79282>>>>>>>>>>>       Else ;          Move '' to sXml
79284>>>>>>>>>>>       Function_Return sXml
79285>>>>>>>>>>>   End_Function
79286>>>>>>>>>>>
79286>>>>>>>>>>>   Function HttpPostXmlVar String sHost String sFilePath Variant vXml Returns Variant
79288>>>>>>>>>>>        Integer iLen
79288>>>>>>>>>>>        Address aXml aDataReceived
79288>>>>>>>>>>>        Variant vXMLReceived
79288>>>>>>>>>>>        Boolean bOk
79288>>>>>>>>>>>        Integer eTranslateSent eTranslateReceived
79288>>>>>>>>>>>        Handle hoCharTranslate
79288>>>>>>>>>>>        
79288>>>>>>>>>>>        Get phoCharTranslate to hoCharTranslate
79289>>>>>>>>>>>        Get peTranslateSent to eTranslateSent
79290>>>>>>>>>>>        Get peTranslateReceived to eTranslateReceived
79291>>>>>>>>>>>        Set peTranslateSent to xtNoTranslate
79292>>>>>>>>>>>        Set peTranslateReceived to xtNoTranslate
79293>>>>>>>>>>>
79293>>>>>>>>>>>        // we will do our own translation. 
79293>>>>>>>>>>>        // Send: UTF16 -> UTF8 
79293>>>>>>>>>>>        // Rec:  UTF8  -> UTF16
79293>>>>>>>>>>>        Get VariantStrToBuffer of hoCharTranslate vXml CP_UTF8 to aXml
79294>>>>>>>>>>>        Move (CStringLength(aXml)) to iLen
79295>>>>>>>>>>>        Get HttpPostXmlAddr sHost sFilePath aXml iLen to aDataReceived
79296>>>>>>>>>>>        
79296>>>>>>>>>>>        If (aDataReceived) Begin
79298>>>>>>>>>>>            Get VariantStrFromBuffer of hoCharTranslate aDataReceived CP_UTF8 to vXMLReceived
79299>>>>>>>>>>>            Move (Free(aDataReceived)) to bOk
79300>>>>>>>>>>>        End
79300>>>>>>>>>>>>
79300>>>>>>>>>>>        Else Begin
79301>>>>>>>>>>>            Move '' to vXMLReceived
79302>>>>>>>>>>>        End
79302>>>>>>>>>>>>
79302>>>>>>>>>>>        Move (Free(aXml)) to bOk
79303>>>>>>>>>>>        
79303>>>>>>>>>>>        Set peTranslateSent to eTranslateSent
79304>>>>>>>>>>>        Set peTranslateReceived to eTranslateReceived
79305>>>>>>>>>>>        
79305>>>>>>>>>>>        Function_Return vXMLReceived    
79306>>>>>>>>>>>
79306>>>>>>>>>>>   End_Function
79307>>>>>>>>>>>   
79307>>>>>>>>>>>   Function LoopDataBack Address aOutData Integer iLen Returns Boolean
79309>>>>>>>>>>>        Integer aInData
79309>>>>>>>>>>>        Boolean bOk
79309>>>>>>>>>>>        Move (Alloc(iLen+1)) to aInData
79310>>>>>>>>>>>        Move (MemCopy(aInData,aOutData,iLen)) to bOk
79311>>>>>>>>>>>        Move (StoreC(aInData,iLen,0)) to bOk
79312>>>>>>>>>>>        Set paDataReceived to aInData
79313>>>>>>>>>>>        Set psContentTypeReceived to (psContentTypeExpected(Self))
79314>>>>>>>>>>>        Function_Return True
79315>>>>>>>>>>>   End_Function
79316>>>>>>>>>>>   
79316>>>>>>>>>>>   Function HttpPostXmlAddr  String sHost String sFilePath Address aXml Integer iLen Returns Address
79318>>>>>>>>>>>        Integer bOk iVoid
79318>>>>>>>>>>>        Address aXmlXlt
79318>>>>>>>>>>>        Address aDataReceived
79318>>>>>>>>>>>        Boolean bDataRequiredSent bDataRequiredReceived
79318>>>>>>>>>>>        String sContentTypeReceived sContentTypeExpected
79318>>>>>>>>>>>
79318>>>>>>>>>>>        Get pbDataRequiredSent     to bDataRequiredSent
79319>>>>>>>>>>>        Get pbDataRequiredReceived to bDataRequiredReceived
79320>>>>>>>>>>>
79320>>>>>>>>>>>
79320>>>>>>>>>>>        // This checks that data exists. If it exists, we assume it is XML format which
79320>>>>>>>>>>>        // will always be true when you use HttpXmlNode
79320>>>>>>>>>>>        If (bDataRequiredSent and (aXML=0 or iLen=0)) Begin
79322>>>>>>>>>>>            Set peXmlTransferStatus to xtsBadRequest
79323>>>>>>>>>>>            Function_Return 0
79324>>>>>>>>>>>        End
79324>>>>>>>>>>>>
79324>>>>>>>>>>>
79324>>>>>>>>>>>        // translate data if needed, returns 0 if no translation
79324>>>>>>>>>>>        If (aXML<>0) Begin
79326>>>>>>>>>>>            Get TranslateData (peTranslateSent(Self)) aXml iLen to aXmlXlt
79327>>>>>>>>>>>        End
79327>>>>>>>>>>>>
79327>>>>>>>>>>>        
79327>>>>>>>>>>>        If (pbPostLoopTest(Self)) Begin
79329>>>>>>>>>>>            Get LoopDataBack aXml iLen to bOk
79330>>>>>>>>>>>        End
79330>>>>>>>>>>>>
79330>>>>>>>>>>>        Else Begin
79331>>>>>>>>>>>                
79331>>>>>>>>>>>            If (aXmlXlt<>0) Begin
79333>>>>>>>>>>>                Move (CStringLength(aXmlXlt)) to iLen // if translated...assume zero termination at end
79334>>>>>>>>>>>                //Move (Length(aXmlXlt)) to iLen // if translated...assume zero termination at end
79334>>>>>>>>>>>                Get HttpPostXmlAddrNoXlt sHost sFilepath aXmlXlt iLen to bOk
79335>>>>>>>>>>>                Move (Free(aXmlXlt)) to iVoid // no longer need tranlsated data
79336>>>>>>>>>>>            End
79336>>>>>>>>>>>>
79336>>>>>>>>>>>            Else Begin
79337>>>>>>>>>>>                Get HttpPostXmlAddrNoXlt sHost sFilepath aXml iLen to bOk
79338>>>>>>>>>>>            End
79338>>>>>>>>>>>>
79338>>>>>>>>>>>        End
79338>>>>>>>>>>>>
79338>>>>>>>>>>>
79338>>>>>>>>>>>
79338>>>>>>>>>>>        If bOk Begin
79340>>>>>>>>>>>           Set peXmlTransferStatus to xtsOk
79341>>>>>>>>>>>           Get TranslateDataReceived to aDataReceived   // current pointer to data (is returned)
79342>>>>>>>>>>>        End
79342>>>>>>>>>>>>
79342>>>>>>>>>>>        Else Begin
79343>>>>>>>>>>>            Set peXmlTransferStatus to xtsHttpRequestFailed
79344>>>>>>>>>>>            Send ClearDataReceived               // if error, clear data
79345>>>>>>>>>>>            Move 0 to aDataReceived              // and return 0
79346>>>>>>>>>>>            Function_Return 0
79347>>>>>>>>>>>        End
79347>>>>>>>>>>>>
79347>>>>>>>>>>>
79347>>>>>>>>>>>        // I am not sure this could ever happen. But if length is 0, we have no data
79347>>>>>>>>>>>        //If (aDataReceived and Length(aDataReceived)=0) Begin
79347>>>>>>>>>>>        If (aDataReceived and CStringLength(aDataReceived)=0) Begin
79349>>>>>>>>>>>            Move (Free(aDataReceived)) to iVoid
79350>>>>>>>>>>>            Move 0 to aDataReceived
79351>>>>>>>>>>>        End
79351>>>>>>>>>>>>
79351>>>>>>>>>>>
79351>>>>>>>>>>>        If aDataReceived Begin
79353>>>>>>>>>>>            // we have data, check that the content type is ok. This is as far
79353>>>>>>>>>>>            // as we can go here.
79353>>>>>>>>>>>            Get psContentTypeReceived to sContentTypeReceived
79354>>>>>>>>>>>            Get psContentTypeExpected to sContentTypeExpected
79355>>>>>>>>>>>            // If contentType expected is empty, we allow anything
79355>>>>>>>>>>>            If (sContentTypeExpected<>"" and pos(sContentTypeExpected,sContentTypeReceived)=0) Begin
79357>>>>>>>>>>>                 Set peXmlTransferStatus to xtsInvalidContentType
79358>>>>>>>>>>>                 // store the bad data for debugging purposes
79358>>>>>>>>>>>                 Set paDataReceived to aDataReceived
79359>>>>>>>>>>>                 Set piDataReceivedLength to (CStringLength(aDataReceived))
79360>>>>>>>>>>>                 //Set piDataReceivedLength to (Length(aDataReceived))
79360>>>>>>>>>>>                 Move 0 to aDataReceived
79361>>>>>>>>>>>            End
79361>>>>>>>>>>>>
79361>>>>>>>>>>>        End
79361>>>>>>>>>>>>
79361>>>>>>>>>>>        Else If (bDataRequiredReceived) Begin // data is zero but required
79364>>>>>>>>>>>            Set peXmlTransferStatus to xtsNodata
79365>>>>>>>>>>>        End
79365>>>>>>>>>>>>
79365>>>>>>>>>>>        Function_Return aDataReceived
79366>>>>>>>>>>>   End_Procedure
79367>>>>>>>>>>>
79367>>>>>>>>>>>   Function HttpPostXmlAddrNoXlt  String sHost String sFilePath Address aXml Integer iLen Returns Integer
79369>>>>>>>>>>>        Boolean bOk
79369>>>>>>>>>>>        Integer iError
79369>>>>>>>>>>>        Send ClearDataReceived  // this should be zero, just in case it is not
79370>>>>>>>>>>>        Set psRemoteHost to sHost
79371>>>>>>>>>>>        // You need to clear headers between posts. If you need to set custom headers you should
79371>>>>>>>>>>>        // set pbClearHeaders to false and then manually send ClearHeaders and AddHeaders in your code
79371>>>>>>>>>>>        If (pbClearHeaders(Self)) ;            Send ClearHeaders
79374>>>>>>>>>>>        Get AddHeader "CONTENT-TYPE" (psContentTypeSent(Self)) to bok
79375>>>>>>>>>>>        Get HttpPostAddrRequest sFilePath aXml iLen False to bOK
79376>>>>>>>>>>>        Function_Return bOk
79377>>>>>>>>>>>   End_Procedure
79378>>>>>>>>>>>
79378>>>>>>>>>>>
79378>>>>>>>>>>>   Function HttpGetXmlNode  String sHost String sFilePath Returns Handle
79380>>>>>>>>>>>       Address aXml
79380>>>>>>>>>>>       Integer iVoid iLen
79380>>>>>>>>>>>       Handle hoXml
79380>>>>>>>>>>>       Variant vXml
79380>>>>>>>>>>>       Handle hoCharTranslate
79380>>>>>>>>>>>       Boolean bUseVariant
79380>>>>>>>>>>>
79380>>>>>>>>>>>       Get pbUseVariantXfer to bUseVariant
79381>>>>>>>>>>>       
79381>>>>>>>>>>>       If not bUseVariant Begin 
79383>>>>>>>>>>>           Get HttpGetXmlAddr sHost sFilePath to aXml
79384>>>>>>>>>>>           // if data is returned (aXML) it is non-zero and content type is correct.
79384>>>>>>>>>>>           // if no data, an error has been registered or no data is an ok condition
79384>>>>>>>>>>>           If (aXml<>0) Begin
79386>>>>>>>>>>>               Get DatatoXml aXml to hoXml
79387>>>>>>>>>>>               If (hoXml=0) Begin
79389>>>>>>>>>>>                   // this indicates that data was returned but it could not be loaded as XML
79389>>>>>>>>>>>                   Set peXmlTransferStatus to xtsNotXml
79390>>>>>>>>>>>                   // store the bad data for debugging purposes
79390>>>>>>>>>>>                   Set paDataReceived to aXml
79391>>>>>>>>>>>                   Set piDataReceivedLength to (CStringLength(aXml))
79392>>>>>>>>>>>                   //Set piDataReceivedLength to (Length(aXml))
79392>>>>>>>>>>>               End
79392>>>>>>>>>>>>
79392>>>>>>>>>>>               Else Begin
79393>>>>>>>>>>>                   Move (Free(aXml)) to iVoid
79394>>>>>>>>>>>               End
79394>>>>>>>>>>>>
79394>>>>>>>>>>>           End
79394>>>>>>>>>>>>
79394>>>>>>>>>>>           Else Begin
79395>>>>>>>>>>>              Move 0 to hoXml
79396>>>>>>>>>>>           End
79396>>>>>>>>>>>>
79396>>>>>>>>>>>       End
79396>>>>>>>>>>>>
79396>>>>>>>>>>>       Else Begin
79397>>>>>>>>>>>           Get phoCharTranslate to hoCharTranslate
79398>>>>>>>>>>>           Get HttpGetXmlVar sHost sFilePath to vXml
79399>>>>>>>>>>>           // if data is returned (aXML) it is non-zero and content type is correct.
79399>>>>>>>>>>>           // if no data, an error has been registered or no data is an ok condition
79399>>>>>>>>>>>           If (vXml<>"") Begin
79401>>>>>>>>>>>               Get VarianttoXML vXml to hoXml
79402>>>>>>>>>>>               If (hoXml=0) Begin
79404>>>>>>>>>>>                   // this indicates that data was returned but it could not be loaded as XML
79404>>>>>>>>>>>                   Set peXmlTransferStatus to xtsNotXml
79405>>>>>>>>>>>                   // store the bad data for debugging purposes
79405>>>>>>>>>>>                   Get VariantStrToBuffer of hoCharTranslate vXml CP_OEMCP to aXml
79406>>>>>>>>>>>                   Set paDataReceived to aXml
79407>>>>>>>>>>>                   Set piDataReceivedLength to (VariantStringLength(vXml))
79408>>>>>>>>>>>               End
79408>>>>>>>>>>>>
79408>>>>>>>>>>>           End
79408>>>>>>>>>>>>
79408>>>>>>>>>>>           Else Begin
79409>>>>>>>>>>>              Move 0 to hoXml
79410>>>>>>>>>>>           End
79410>>>>>>>>>>>>
79410>>>>>>>>>>>       End
79410>>>>>>>>>>>>
79410>>>>>>>>>>>       Function_Return hoXml
79411>>>>>>>>>>>   End_Function
79412>>>>>>>>>>>
79412>>>>>>>>>>>   Function HttpGetXmlString String sHost String sFilePath Returns String
79414>>>>>>>>>>>       Address aXml
79414>>>>>>>>>>>       String  sXml
79414>>>>>>>>>>>       Integer iVoid
79414>>>>>>>>>>>       Get HttpGetXmlAddr sHost sFilePath to aXml
79415>>>>>>>>>>>       If (aXml<>0) Begin
79417>>>>>>>>>>>          Move aXml to sXml           // if data returned, assign to string
79418>>>>>>>>>>>          Move (Free(aXml)) to iVoid  // and free data
79419>>>>>>>>>>>       End
79419>>>>>>>>>>>>
79419>>>>>>>>>>>       Else ;          Move '' to sXml
79421>>>>>>>>>>>       Function_Return sXml
79422>>>>>>>>>>>   End_Function
79423>>>>>>>>>>>
79423>>>>>>>>>>>   Function HttpGetXmlVar String sHost String sFilePath Returns Variant
79425>>>>>>>>>>>        Address aXml
79425>>>>>>>>>>>        Variant vXml
79425>>>>>>>>>>>        Integer iVoid
79425>>>>>>>>>>>        Integer eTranslateReceived
79425>>>>>>>>>>>        Handle hoCharTranslate
79425>>>>>>>>>>>        
79425>>>>>>>>>>>        Get peTranslateReceived to eTranslateReceived
79426>>>>>>>>>>>        
79426>>>>>>>>>>>        Set peTranslateReceived to xtNoTranslate
79427>>>>>>>>>>>        
79427>>>>>>>>>>>        // we do our own translate: 
79427>>>>>>>>>>>        // Rec: UTF8 -> UTF16
79427>>>>>>>>>>>        Get HttpGetXmlAddr sHost sFilePath to aXml
79428>>>>>>>>>>>        
79428>>>>>>>>>>>        If (aXml<>0) Begin
79430>>>>>>>>>>>            Get phoCharTranslate to hoCharTranslate
79431>>>>>>>>>>>            Get VariantStrFromBuffer of hoCharTranslate aXML CP_UTF8 to vXML
79432>>>>>>>>>>>            Move (Free(aXml)) to iVoid  // and free data
79433>>>>>>>>>>>       End
79433>>>>>>>>>>>>
79433>>>>>>>>>>>       Else ;          Move '' to vXml
79435>>>>>>>>>>>          
79435>>>>>>>>>>>       Set peTranslateReceived to eTranslateReceived
79436>>>>>>>>>>>       Function_Return vXml
79437>>>>>>>>>>>   End_Function
79438>>>>>>>>>>>
79438>>>>>>>>>>>   Function HttpGetXmlAddr  String sHost String sFilePath Returns Address
79440>>>>>>>>>>>        Integer bOk iVoid
79440>>>>>>>>>>>        Address aDataReceived
79440>>>>>>>>>>>        Boolean bDataRequiredReceived
79440>>>>>>>>>>>        String sContentTypeReceived sContentTypeExpected
79440>>>>>>>>>>>
79440>>>>>>>>>>>        Get pbDataRequiredReceived to bDataRequiredReceived
79441>>>>>>>>>>>
79441>>>>>>>>>>>        Get HttpGetXmlNoXlt sHost sFilepath to bOk
79442>>>>>>>>>>>        If bOk Begin
79444>>>>>>>>>>>           Set peXmlTransferStatus to xtsOk
79445>>>>>>>>>>>           Get TranslateDataReceived to aDataReceived   // current pointer to data (is returned)
79446>>>>>>>>>>>        End
79446>>>>>>>>>>>>
79446>>>>>>>>>>>        Else Begin
79447>>>>>>>>>>>            Set peXmlTransferStatus to xtsHttpRequestFailed
79448>>>>>>>>>>>            Send ClearDataReceived               // if error, clear data
79449>>>>>>>>>>>            Move 0 to aDataReceived              // and return 0
79450>>>>>>>>>>>            Function_Return 0
79451>>>>>>>>>>>        End
79451>>>>>>>>>>>>
79451>>>>>>>>>>>
79451>>>>>>>>>>>        // I am not sure this could ever happen. But if length is 0, we have no data
79451>>>>>>>>>>>        //If (aDataReceived and Length(aDataReceived)=0) Begin
79451>>>>>>>>>>>        If (aDataReceived and CStringLength(aDataReceived)=0) Begin
79453>>>>>>>>>>>            Move (Free(aDataReceived)) to iVoid
79454>>>>>>>>>>>            Move 0 to aDataReceived
79455>>>>>>>>>>>        End
79455>>>>>>>>>>>>
79455>>>>>>>>>>>
79455>>>>>>>>>>>        If aDataReceived Begin
79457>>>>>>>>>>>            // we have data, check that the content type is ok. This is as far
79457>>>>>>>>>>>            // as we can go here.
79457>>>>>>>>>>>            Get psContentTypeReceived to sContentTypeReceived
79458>>>>>>>>>>>            Get psContentTypeExpected to sContentTypeExpected
79459>>>>>>>>>>>            // If contentType expected is empty, we allow anything
79459>>>>>>>>>>>            If (sContentTypeExpected<>"" and pos(sContentTypeExpected,sContentTypeReceived)=0) Begin
79461>>>>>>>>>>>                 Set peXmlTransferStatus to xtsInvalidContentType
79462>>>>>>>>>>>                 // store the bad data for debugging purposes
79462>>>>>>>>>>>                 Set paDataReceived to aDataReceived
79463>>>>>>>>>>>                 Set piDataReceivedLength to (CStringLength(aDataReceived))
79464>>>>>>>>>>>                 //Set piDataReceivedLength to (Length(aDataReceived))
79464>>>>>>>>>>>                 Move 0 to aDataReceived
79465>>>>>>>>>>>            End
79465>>>>>>>>>>>>
79465>>>>>>>>>>>        End
79465>>>>>>>>>>>>
79465>>>>>>>>>>>        Else If (bDataRequiredReceived) Begin // data is zero but required
79468>>>>>>>>>>>            Set peXmlTransferStatus to xtsNodata
79469>>>>>>>>>>>        End
79469>>>>>>>>>>>>
79469>>>>>>>>>>>        Function_Return aDataReceived
79470>>>>>>>>>>>   End_Procedure
79471>>>>>>>>>>>
79471>>>>>>>>>>>   // low level get - no translation of data. returns received data in paDataReceived
79471>>>>>>>>>>>   //
79471>>>>>>>>>>>   Function HttpGetXmlNoXlt  String sHost String sFilePath Returns Integer
79473>>>>>>>>>>>        Integer bOk
79473>>>>>>>>>>>        Send ClearDataReceived  // this should be zero, just in case it is not
79474>>>>>>>>>>>        Set psRemoteHost to sHost
79475>>>>>>>>>>>        Get HttpGetRequest sFilePath to bOK
79476>>>>>>>>>>>        Function_Return bOk
79477>>>>>>>>>>>   End_Procedure
79478>>>>>>>>>>>
79478>>>>>>>>>>>   // After an XML xfer request this message can be sent to display an error message if one occurred.
79478>>>>>>>>>>>   // Normally you would first check peXmlTransferStatus to see if it is not xtsOk. If not, send
79478>>>>>>>>>>>   // LastError to see the error
79478>>>>>>>>>>>
79478>>>>>>>>>>>   // return last xml transfer error text
79478>>>>>>>>>>>   Function TransferErrorDescription Returns String
79480>>>>>>>>>>>        String  sError sFaultCode sFaultString sText sType
79480>>>>>>>>>>>        Integer eXmlTransferStatus
79480>>>>>>>>>>>        Get peXmlTransferStatus to eXmlTransferStatus
79481>>>>>>>>>>>        Case Begin
79481>>>>>>>>>>>            Case (eXmlTransferStatus=xtsOk)                 Move ''                             to sError
79484>>>>>>>>>>>            Case (eXmlTransferStatus=xtsHttpRequestFailed)  Move C_$HttpRequestFailed           to sError
79488>>>>>>>>>>>            Case (eXmlTransferStatus=xtsBadRequest)         Move C_$BadOrMissingDataSent        to sError
79492>>>>>>>>>>>            Case (eXmlTransferStatus=xtsInvalidContentType) Move (SFormat(C_$InvalidContentTypeReceived,psContentTypeReceived(Self))) to sError
79496>>>>>>>>>>>            Case (eXmlTransferStatus=xtsNoData)             Move C_$NoDataWasReceived           to sError
79500>>>>>>>>>>>            Case (eXmlTransferStatus=xtsNotXml)             Move C_$ReceivedDataNotInXMLFormat  to sError
79504>>>>>>>>>>>            Case Else                                       Move C_$ReceivedDataIsBad           to sError
79506>>>>>>>>>>>        Case End
79506>>>>>>>>>>>        Function_Return sError
79507>>>>>>>>>>>    End_Function
79508>>>>>>>>>>>
79508>>>>>>>>>>>
79508>>>>>>>>>>>   Procedure LastError
79510>>>>>>>>>>>        Integer eXmlTransferStatus
79510>>>>>>>>>>>        String sError
79510>>>>>>>>>>>
79510>>>>>>>>>>>        Get peXmlTransferStatus to eXmlTransferStatus
79511>>>>>>>>>>>        If (eXmlTransferStatus<>xtsOk) Begin
79513>>>>>>>>>>>            Get TransferErrorDescription to sError
79514>>>>>>>>>>>            Error DFERR_XML_HTTP sError
79515>>>>>>>>>>>>
79515>>>>>>>>>>>        End
79515>>>>>>>>>>>>
79515>>>>>>>>>>>   End_Procedure
79516>>>>>>>>>>>
79516>>>>>>>>>>>End_Class
79517>>>>>>>>>>>
79517>>>>>>>>>>>
79517>>>>>>>>>Use SoapConstants.pkg
Including file: SoapConstants.pkg    (C:\Program Files (x86)\DataFlex 18.1\Pkg\SoapConstants.pkg)
79517>>>>>>>>>>>// SoapConstants.pkg
79517>>>>>>>>>>>// constants used by soap
79517>>>>>>>>>>>
79517>>>>>>>>>>>// DataFlex datatypes that we support in soap.
79517>>>>>>>>>>>// These MUST match the dataflex definitions as provided in fmac
79517>>>>>>>>>>>Enum_list
79517>>>>>>>>>>>    Define xsString    for 0
79517>>>>>>>>>>>    Define xsNumber    for 1
79517>>>>>>>>>>>    Define xsDate      for 2
79517>>>>>>>>>>>    Define xsInteger   for 3
79517>>>>>>>>>>>    Define xsBigint    for 4
79517>>>>>>>>>>>    Define xsReal      for 5
79517>>>>>>>>>>>    Define xsBoolean   for 6
79517>>>>>>>>>>>    Define xsTime      for 8
79517>>>>>>>>>>>    Define xsDatetime  for 9
79517>>>>>>>>>>>    Define xsFloat     for 10
79517>>>>>>>>>>>    Define xsChar      for 11
79517>>>>>>>>>>>    Define xsUchar     for 12
79517>>>>>>>>>>>    Define xsShort     for 13
79517>>>>>>>>>>>    Define xsUShort    for 14
79517>>>>>>>>>>>    Define xsUinteger  for 15
79517>>>>>>>>>>>    Define xsUbigint   for 17
79517>>>>>>>>>>>    Define xsCurrency  for 18
79517>>>>>>>>>>>    Define xsStruct    for 19
79517>>>>>>>>>>>    Define xsDecimal   for 22
79517>>>>>>>>>>>
79517>>>>>>>>>>>    Define xsEmpty     for  -1  // not a real datatype. Used with return types when nothing is returned. We must use -1 (the runtime message InterfaceMessageParamType returns this)
79517>>>>>>>>>>>    Define xsAnyType    for 127  // not a real type (represent as XML within a wrapper document)
79517>>>>>>>>>>>    Define xsXmlElement for 128  // not a real type (represent as an xml document. <any /> type in schema)
79517>>>>>>>>>>>    Define xsAnyTypeStr    for 129  // not a real type (represent as XML serialized stringwithin a wrapper document). Can be used in struct/array definitions.
79517>>>>>>>>>>>    Define xsXmlElementStr for 130  // not a real type (represent as an xml serialized stringdocument. <any /> type in schema). Can be used in struct/array definitions.
79517>>>>>>>>>>>    Define xsBase64Binary for 131 //  not a real type (represent as a base64binary serialized stringdocument. Can be used in struct/array definitions.
79517>>>>>>>>>>>
79517>>>>>>>>>>>End_Enum_list
79517>>>>>>>>>>>
79517>>>>>>>>>>>// soap style
79517>>>>>>>>>>>Enum_list
79517>>>>>>>>>>>   define ssDocument
79517>>>>>>>>>>>   define ssRPC
79517>>>>>>>>>>>End_Enum_list
79517>>>>>>>>>>>
79517>>>>>>>>>>>// soap encoding
79517>>>>>>>>>>>Enum_list
79517>>>>>>>>>>>   define seLiteral
79517>>>>>>>>>>>   define seEncoded
79517>>>>>>>>>>>End_Enum_list
79517>>>>>>>>>>>
79517>>>>>>>>>>>// service/port-types. Currently we only support soap
79517>>>>>>>>>>>Enum_list
79517>>>>>>>>>>>   define ptUnKnown
79517>>>>>>>>>>>   define ptSOAP
79517>>>>>>>>>>>   define ptHttp
79517>>>>>>>>>>>End_Enum_list
79517>>>>>>>>>>>
79517>>>>>>>>>>>Define C_UnBounded            for -1 // used when maxOccurs=Unbounded
79517>>>>>>>>>>>
79517>>>>>>>>>>>Define svSOAP11 for 1
79517>>>>>>>>>>>Define svSOAP12 for 2
79517>>>>>>>>>>>
79517>>>>>>>>>>>// SOAP URI constants (SOAP1.1)
79517>>>>>>>>>>>define C_WSDLURI              for "http://schemas.xmlsoap.org/wsdl/"
79517>>>>>>>>>>>define C_SOAPURI              for "http://schemas.xmlsoap.org/wsdl/soap/"
79517>>>>>>>>>>>define C_XMLSCHEMAURI         for "http://www.w3.org/2001/XMLSchema"
79517>>>>>>>>>>>define C_XMLSCHEMAXSIURI      for "http://www.w3.org/2001/XMLSchema-instance"
79517>>>>>>>>>>>define C_SOAPENVELOPEURI      for "http://schemas.xmlsoap.org/soap/envelope/"
79517>>>>>>>>>>>define C_SOAPENCODINGURI      for "http://schemas.xmlsoap.org/soap/encoding/"
79517>>>>>>>>>>>Define C_ContentTypeSOAP      for "text/xml"
79517>>>>>>>>>>>Define C_SOAPHREF             for "href" // 1.1 uses href while 1.2 uses ref
79517>>>>>>>>>>>
79517>>>>>>>>>>>// SOAP1.2 constants
79517>>>>>>>>>>>Define C_SOAPURI12            for "http://schemas.xmlsoap.org/wsdl/soap12/"
79517>>>>>>>>>>>Define C_SOAPENVELOPEURI12    for "http://www.w3.org/2003/05/soap-envelope"
79517>>>>>>>>>>>Define C_SOAPENCODINGURI12    for "http://www.w3.org/2003/05/soap-encoding"
79517>>>>>>>>>>>Define C_SOAPRPC12            for "http://www.w3.org/2003/05/soap-rpc"
79517>>>>>>>>>>>Define C_ContentTypeSOAP12    for "application/soap+xml"
79517>>>>>>>>>>>Define C_SOAPHREF12 for "ref"
79517>>>>>>>>>>>
79517>>>>>>>>>>>Define C_MTOMMimeMarker for "dfMimeContent"
79517>>>>>>>>>>>
79517>>>>>>>>>Use Variant.pkg
79517>>>>>>>>>Use tValueTreeEx.pkg
Including file: tValueTreeEx.pkg    (C:\Program Files (x86)\DataFlex 18.1\Pkg\tValueTreeEx.pkg)
79517>>>>>>>>>>>Struct tValueTreeEx            // ValueTreeExr uses variant as its value. This is used to shuttle data between our variables and XML soap documents
79517>>>>>>>>>>>    Variant      sValue        // data value. Value only exists if there are no children. We use Variant/BSTR as the storage type.
79517>>>>>>>>>>>    tValueTreeEx[] children    // child values. If a struct or array, we have children and no value
79517>>>>>>>>>>>    tValueTreeEx[] children    // child values. If a struct or array, we have children and no value
79517>>>>>>>>>>>End_Struct
79517>>>>>>>>>>>
79517>>>>>>>>>Use tSimpleNullTypes.pkg
Including file: tSimpleNullTypes.pkg    (C:\Program Files (x86)\DataFlex 18.1\Pkg\tSimpleNullTypes.pkg)
79517>>>>>>>>>>>// These define nullable simple types for Web-services. 
79517>>>>>>>>>>>// These are defined as structs where the first member is Value, which is the value
79517>>>>>>>>>>>// and second member is bNull. When bNull is set true, it means this should be treated as null.
79517>>>>>>>>>>>// The structs are named by appending tN to the simple type name.
79517>>>>>>>>>>>// These are just structs and there is nothing special in the runtime to support this.
79517>>>>>>>>>>>// This is required because web-services use minOccurs=0 and maxOccurs=1 to indicate that no
79517>>>>>>>>>>>// value should be passed when the value is null. Passing "" or 0, does not do the same thing.
79517>>>>>>>>>>>
79517>>>>>>>>>>>// make sure all simple nullable structs adhere to this
79517>>>>>>>>>>>Define C_SimpleDataMember for 1
79517>>>>>>>>>>>Define C_SimpleNullMember for 0
79517>>>>>>>>>>>
79517>>>>>>>>>>>Struct tNString
79517>>>>>>>>>>>    Boolean bNull
79517>>>>>>>>>>>    String Value
79517>>>>>>>>>>>End_Struct
79517>>>>>>>>>>>
79517>>>>>>>>>>>Struct tNNumber
79517>>>>>>>>>>>    Boolean bNull
79517>>>>>>>>>>>    Number Value
79517>>>>>>>>>>>End_Struct
79517>>>>>>>>>>>
79517>>>>>>>>>>>Struct tNDate
79517>>>>>>>>>>>    Boolean bNull
79517>>>>>>>>>>>    Date Value
79517>>>>>>>>>>>End_Struct
79517>>>>>>>>>>>
79517>>>>>>>>>>>Struct tNInteger
79517>>>>>>>>>>>    Boolean bNull
79517>>>>>>>>>>>    Integer Value
79517>>>>>>>>>>>End_Struct
79517>>>>>>>>>>>
79517>>>>>>>>>>>Struct tNBigInt
79517>>>>>>>>>>>    Boolean bNull
79517>>>>>>>>>>>    BigInt Value
79517>>>>>>>>>>>End_Struct
79517>>>>>>>>>>>
79517>>>>>>>>>>>Struct tNReal
79517>>>>>>>>>>>    Boolean bNull
79517>>>>>>>>>>>    Real Value
79517>>>>>>>>>>>End_Struct
79517>>>>>>>>>>>
79517>>>>>>>>>>>Struct tNBoolean
79517>>>>>>>>>>>    Boolean bNull
79517>>>>>>>>>>>    Boolean Value
79517>>>>>>>>>>>End_Struct
79517>>>>>>>>>>>
79517>>>>>>>>>>>Struct tNTime
79517>>>>>>>>>>>    Boolean bNull
79517>>>>>>>>>>>    Time Value
79517>>>>>>>>>>>End_Struct
79517>>>>>>>>>>>
79517>>>>>>>>>>>Struct tNDateTime
79517>>>>>>>>>>>    Boolean bNull
79517>>>>>>>>>>>    DateTime Value
79517>>>>>>>>>>>End_Struct
79517>>>>>>>>>>>
79517>>>>>>>>>>>Struct tNFloat
79517>>>>>>>>>>>    Boolean bNull
79517>>>>>>>>>>>    Float Value
79517>>>>>>>>>>>End_Struct
79517>>>>>>>>>>>
79517>>>>>>>>>>>Struct tNChar
79517>>>>>>>>>>>    Boolean bNull
79517>>>>>>>>>>>    Char Value
79517>>>>>>>>>>>End_Struct
79517>>>>>>>>>>>
79517>>>>>>>>>>>Struct tNUChar
79517>>>>>>>>>>>    Boolean bNull
79517>>>>>>>>>>>    UChar Value
79517>>>>>>>>>>>End_Struct
79517>>>>>>>>>>>
79517>>>>>>>>>>>Struct tNShort
79517>>>>>>>>>>>    Boolean bNull
79517>>>>>>>>>>>    Short Value
79517>>>>>>>>>>>End_Struct
79517>>>>>>>>>>>
79517>>>>>>>>>>>Struct tNUShort
79517>>>>>>>>>>>    Boolean bNull
79517>>>>>>>>>>>    UShort Value
79517>>>>>>>>>>>End_Struct
79517>>>>>>>>>>>
79517>>>>>>>>>>>Struct tNUInteger
79517>>>>>>>>>>>    Boolean bNull
79517>>>>>>>>>>>    UInteger Value
79517>>>>>>>>>>>End_Struct
79517>>>>>>>>>>>
79517>>>>>>>>>>>Struct tNUBigInt
79517>>>>>>>>>>>    Boolean bNull
79517>>>>>>>>>>>    UBigInt Value
79517>>>>>>>>>>>End_Struct
79517>>>>>>>>>>>
79517>>>>>>>>>>>Struct tNCurrency
79517>>>>>>>>>>>    Boolean bNull
79517>>>>>>>>>>>    Currency Value
79517>>>>>>>>>>>End_Struct
79517>>>>>>>>>>>
79517>>>>>>>>>>>Struct tNDecimal
79517>>>>>>>>>>>    Boolean bNull
79517>>>>>>>>>>>    Decimal Value
79517>>>>>>>>>>>End_Struct
79517>>>>>>>>>>>
79517>>>>>>>>>
79517>>>>>>>>>
79517>>>>>>>>>
79517>>>>>>>>>// new rules
79517>>>>>>>>>//
79517>>>>>>>>>// 1. Structs with null members are identified via defineIsNullMember
79517>>>>>>>>>// 2. Nullable simple types must use predefined structs such as tNBoolean and tNString. These can only
79517>>>>>>>>>//    only be two member, last must be null flag. Must be declared using DefineSimpleNullableParameter instead of DefineParameter.
79517>>>>>>>>>// 3. To set a data-type to null its bNull member must be set True by the developer. By default it is false
79517>>>>>>>>>// 4. Arrays that are null (all types) are automatically Null detected by having no children, so no need for the above
79517>>>>>>>>>// 5. Choice type structs use same null logic as before. If no choice is made, it is null, so no need for above
79517>>>>>>>>>// 6. If minOccurs=0 ( and maxOccurs=1) and the parameter or member is Nullable
79517>>>>>>>>>//       If request, no node will be sent,
79517>>>>>>>>>//       If response is empty null flag is Set
79517>>>>>>>>>// 7. If minOccurs=C_Nillable (a new setting) and the param or member is nillable (defined with min/max=1 and nillible=true). 
79517>>>>>>>>>//       If request empty node with nill="true" is sent,
79517>>>>>>>>>//       If response has nill attribute, null flag is Set
79517>>>>>>>>>// 8. The data type must be nullable and have the proper minOccurs for any special action, else it works as before
79517>>>>>>>>>// 8. Simple datatypes not based on nullable structs will work exactly as before.
79517>>>>>>>>>// 9. DF zero dates and datetime will be null as needed as before. Nillable support also added.
79517>>>>>>>>>// 10. We have an option where all simple types and struct types can be made nullable. This means that there could be
79517>>>>>>>>>//     nullable settings for elements that do not support this. This is still WIP to figure out what is eaiest.
79517>>>>>>>>>
79517>>>>>>>>>
79517>>>>>>>>>// Parser Issues:
79517>>>>>>>>>//    * Probably want way to disable new null feature (done)
79517>>>>>>>>>//    * Should have ability to force requests and responses as bare (done)
79517>>>>>>>>>//    * might not want to allow nulls with RPC - just avoid the confusion
79517>>>>>>>>>
79517>>>>>>>>>// Parser changes for 18.0
79517>>>>>>>>>// * Better support to abstract types (create a XML str)
79517>>>>>>>>>// * FindStruct seems to have bug of only searching for name not namespace
79517>>>>>>>>>// * Support arrays (maxOccurs) in parameter defintions. Doesn't work properly with requests
79517>>>>>>>>>//   and responses treat this as a bare type. Also requires cClientWebService changes
79517>>>>>>>>>// * use this to improve bare detection. Also make bare req/res settable
79517>>>>>>>>>// * Support for minOccurs=0 and nillable types (simple and struct)
79517>>>>>>>>>// *
79517>>>>>>>>>
79517>>>>>>>>>// still todo
79517>>>>>>>>>// ----------
79517>>>>>>>>>// verify that choice works properly with all of this
79517>>>>>>>>>// double check that arrays work properly
79517>>>>>>>>>// create all of the Null simple data-type structs (done tSimpleNullTypes.pkg)
79517>>>>>>>>>// Add Parser support for null simple types (s/b done)
79517>>>>>>>>>// Parser should have struct nullable types (s/b done)
79517>>>>>>>>>// check names for null members and make parser consistent (used bNull).
79517>>>>>>>>>// Consider simple Dataype Struct <-> ValueTree <->XML conversion methods where a single
79517>>>>>>>>>// node is required (not really related to any of this)
79517>>>>>>>>>// Move valuetree and valuetreeex out of this class (done)
79517>>>>>>>>>// Make names better. Run extra pass to remove mangling when not needed (done)
79517>>>>>>>>>// Lots of options to disable various new stuff (done, will change)
79517>>>>>>>>>
79517>>>>>>>>>//
79517>>>>>>>>>//// will need one of these for each simple type
79517>>>>>>>>>//Struct tNString
79517>>>>>>>>>//    String Value
79517>>>>>>>>>//    Boolean bNull
79517>>>>>>>>>//End_Struct
79517>>>>>>>>>//
79517>>>>>>>>>//Struct tNBoolean
79517>>>>>>>>>//    Boolean Value
79517>>>>>>>>>//    Boolean bNull
79517>>>>>>>>>//End_Struct
79517>>>>>>>>>
79517>>>>>>>>>
79517>>>>>>>>>
79517>>>>>>>>>Define xsIsNullMember for -2 // type used to indicate this is a null value
79517>>>>>>>>>Define C_Nillable for -1 // used when minOccurs is 1 but Nillable="true" is set for the type or element
79517>>>>>>>>>
79517>>>>>>>>>
79517>>>>>>>>>
79517>>>>>>>>>Enum_List
79517>>>>>>>>>    Define C_atNone            for 0 // type is a normal struct
79517>>>>>>>>>    Define C_atArray           for 1 // type is used to represent document style array
79517>>>>>>>>>    Define C_atSoapEncArray    for 2 // type is used to represent soap encoded array
79517>>>>>>>>>End_Enum_List
79517>>>>>>>>>
79517>>>>>>>>>//Struct tValueTreeEx           // ValueTreeVar uses variant as its value. This is used to shuttle data between our variables and XML soap documents
79517>>>>>>>>>//    Variant      sValue        // data value. Value only exists if there are no children. We use Variant/BSTR as the storage type.
79517>>>>>>>>>//    tValueTreeEx[] children      // child values. If a struct or array, we have children and no value
79517>>>>>>>>>//End_Struct
79517>>>>>>>>>//
79517>>>>>>>>>//// this is no longer used by this class but it is maintained as is in case a developer is using this for other purposes. This has been
79517>>>>>>>>>//// replaced with the tValueTreeEx
79517>>>>>>>>>//Struct tValueTree              // The infamous ValueTree. This is used to shuttle data between our variables and XML soap documents
79517>>>>>>>>>//    String       sValue        // data value. Value only exists if there are no children
79517>>>>>>>>>//    tValueTree[] children      // child values. If a struct or array, we have children and no value
79517>>>>>>>>>//End_Struct
79517>>>>>>>>>
79517>>>>>>>>>
79517>>>>>>>>>Struct tSoapParamDef
79517>>>>>>>>>    String           sName      // param name used by xml
79517>>>>>>>>>    String           sNamespace // param namespace URI used by xml
79517>>>>>>>>>    Integer          eType      // including struct & soap-encoded array
79517>>>>>>>>>    Handle           hoStruct   // if Type=xsstruct pointer to object cSoapMetaStruct that defines the struct
79517>>>>>>>>>    Integer          iMin       // min occurs (or C_Nillable)
79517>>>>>>>>>    Integer          iMax       // max occurs 
79517>>>>>>>>>    Boolean          bAttribute // is this an attribute
79517>>>>>>>>>    String           sDefaultAttr // if an attribute, the default
79517>>>>>>>>>    Boolean          bSimpleNullable  // if simple, does it use a null member struct
79517>>>>>>>>>    String           sMimeData   // if base64, mime data used to determine if this is MTOMable 
79517>>>>>>>>>End_Struct
79517>>>>>>>>>
79517>>>>>>>>>Struct tSoapParameter           // each parameter is defined via this stuct. It contains the data definition and the actual value tree data
79517>>>>>>>>>    tSoapParamDef SoapParamDef
79517>>>>>>>>>    tSoapParamDef SoapParamDef
79517>>>>>>>>>    tValueTreeEx    ValueTree
79517>>>>>>>>>    tValueTreeEx    ValueTree
79517>>>>>>>>>End_Struct
79517>>>>>>>>>
79517>>>>>>>>>
79517>>>>>>>>>Enum_List
79517>>>>>>>>>
79517>>>>>>>>>    // define webServiceStatus
79517>>>>>>>>>    Define wssOk
79517>>>>>>>>>
79517>>>>>>>>>    // request related errors
79517>>>>>>>>>    Define wssHttpRequestFailed   // the post/get http request returned an error
79517>>>>>>>>>    Define wssBadRequest          // Request data is bad or missing
79517>>>>>>>>>
79517>>>>>>>>>    // response related errors
79517>>>>>>>>>    Define wssInvalidContentType  // response content type not xml
79517>>>>>>>>>    Define wssNoData              // return has no data
79517>>>>>>>>>    Define wssNotXml              // return value not XML (could not load in object)
79517>>>>>>>>>    Define wssNotSoap             // returned xml data.. but its not correct a correct soap document
79517>>>>>>>>>    Define wssInvalidSoap         // returned xml data.. but its not correct according to wsdl
79517>>>>>>>>>    Define wssSoapFault           // returned xml data.. with a soap fault error
79517>>>>>>>>>    Define wssError               // unspecified
79517>>>>>>>>>    Define wssInvalidDataForType  // Attempt to move data from XML to ValueTree (to Struct) failed.
79517>>>>>>>>>    Define wssCouldNotResolveHRef // we had an href and we could not find the Id data for it
79517>>>>>>>>>End_Enum_List
79517>>>>>>>>>
79517>>>>>>>>>Define C_ChoiceStructNone for -1 // for choice structs that have no selection
79517>>>>>>>>>
79517>>>>>>>>>
79517>>>>>>>>>// modes for sending request a mime mtom/xop.
79517>>>>>>>>>Enum_List
79517>>>>>>>>>    Define mxDefault
79517>>>>>>>>>    Define mxNever
79517>>>>>>>>>    Define mxAlways
79517>>>>>>>>>End_Enum_List
79517>>>>>>>>>
79517>>>>>>>>>// used to represent a soap struct. This contains the additional information needed to serialize adn deserialize the xml data.
79517>>>>>>>>>// each datatype object is created once. If a struct uses another struct it is done through a pointer to the new object. This
79517>>>>>>>>>// allows for recursive structures
79517>>>>>>>>>Class cSoapMetaStruct is a cObject
79518>>>>>>>>>
79518>>>>>>>>>    Procedure Construct_object
79520>>>>>>>>>        Forward Send Construct_object
79522>>>>>>>>>        Property String psNameSpace              // we assume all struct members are within this namespace
79523>>>>>>>>>        Property Integer peArrayType C_atNone    // C_atNone C_atArray C_atSoapEncArray
79524>>>>>>>>>        Property Integer pbSchemaAllGroup False  // used to handle the unpleasant case of <all> instead of <sequence>
79525>>>>>>>>>        Property String  psDataType ''           // This is used only by soapencoded arrays.
79526>>>>>>>>>                                                 // If a struct, the name of the schema Struct datatype (without our tWS prefix).
79526>>>>>>>>>                                                 // If an array and a non-struct, name of soap xs datatype (e.g. int)
79526>>>>>>>>>        Property String  psDataTypeNamespace ''  // This is used only by soapencoded arrays. This is the datatype's namespace
79527>>>>>>>>>                                                 // If a struct, the name of the schema Struct namespace.
79527>>>>>>>>>                                                 // If an array and a non-struct, empty (we know its namespace)
79527>>>>>>>>>                                                 // This was added in 14.0 and is generated by that version's class generator
79527>>>>>>>>>        Property Integer piDimensions 0          // if C_atArray or C_atSoapEncArray, this contains number of dimensions
79528>>>>>>>>>        
79528>>>>>>>>>        Property Boolean pbSimpleContent False   // if true the first element is an element value and all other values are attributes
79529>>>>>>>>>        
79529>>>>>>>>>        Property Boolean pbChoice False          // if true this is a choice struct. The first member is the choice (numeric enumeration) and
79530>>>>>>>>>                                                 // the other members are the choice elements. Only one can be chosen
79530>>>>>>>>>        Property Integer piNullMember  -1
79531>>>>>>>>>        
79531>>>>>>>>>        Property tSoapParamDef[] pSoapParamDefs  // defintion of struct
79532>>>>>>>>>        
79532>>>>>>>>>        // this is a pseudo struct used for choice items that are <sequence> rather than <element>
79532>>>>>>>>>        Property Boolean pbChoiceSequenceStruct False
79533>>>>>>>>>        
79533>>>>>>>>>    End_Procedure
79534>>>>>>>>>
79534>>>>>>>>>    Procedure defineParam Integer eType Integer hoStruct Integer iMin Integer iMax String sName String sStypeInfo Boolean bSimpleNullable
79536>>>>>>>>>        tSoapParamDef[] SoapParams
79536>>>>>>>>>        tSoapParamDef[] SoapParams
79537>>>>>>>>>        tSoapParamDef   SoapParam
79537>>>>>>>>>        tSoapParamDef   SoapParam
79537>>>>>>>>>        Integer iCount
79537>>>>>>>>>        Move sName       to SoapParam.sName
79538>>>>>>>>>        Get  psNameSpace to SoapParam.sNameSpace
79539>>>>>>>>>        Move eType       to SoapParam.eType
79540>>>>>>>>>        Move hoStruct    to SoapParam.hoStruct
79541>>>>>>>>>        Move iMin        to SoapParam.iMin
79542>>>>>>>>>        Move iMax        to SoapParam.iMax
79543>>>>>>>>>        Move bSimpleNullable to SoapParam.bSimpleNullable
79544>>>>>>>>>        If (eType=xsBase64Binary) Begin
79546>>>>>>>>>            Move sStypeInfo to SoapParam.sMimeData
79547>>>>>>>>>        End
79547>>>>>>>>>>
79547>>>>>>>>>
79547>>>>>>>>>        Get pSoapParamDefs  to SoapParams
79548>>>>>>>>>        Move (SizeOfArray(SoapParams)) to iCount
79549>>>>>>>>>        Move SoapParam to SoapParams[iCount]
79550>>>>>>>>>        Set pSoapParamDefs to SoapParams
79551>>>>>>>>>
79551>>>>>>>>>        If (eType=xsIsNullMember) Begin
79553>>>>>>>>>            Set piNullMember to iCount
79554>>>>>>>>>        End
79554>>>>>>>>>>
79554>>>>>>>>>        
79554>>>>>>>>>    End_Procedure
79555>>>>>>>>>
79555>>>>>>>>>    Procedure defineParameter Integer eType Integer iMin Integer iMax String sName
79557>>>>>>>>>        Send defineParam eType 0 iMin iMax sName "" False
79558>>>>>>>>>    End_Procedure
79559>>>>>>>>>
79559>>>>>>>>>    Procedure defineStructParameter Handle hoStruct Integer iMin Integer iMax String sName
79561>>>>>>>>>        Send defineParam xsStruct hoStruct iMin iMax sName "" False
79562>>>>>>>>>    End_Procedure
79563>>>>>>>>>
79563>>>>>>>>>    Procedure defineQualParameter Integer eType Integer iMin Integer iMax String sName String sNS
79565>>>>>>>>>        String sOldNS
79565>>>>>>>>>        Get psNamespace to sOldNS
79566>>>>>>>>>        Set psNamespace to sNS
79567>>>>>>>>>        Send defineParam eType 0 iMin iMax sName "" False
79568>>>>>>>>>        Set psNamespace to sOldNS
79569>>>>>>>>>    End_Procedure
79570>>>>>>>>>
79570>>>>>>>>>    Procedure defineQualStructParameter Handle hoStruct Integer iMin Integer iMax String sName String sNs
79572>>>>>>>>>        String sOldNS
79572>>>>>>>>>        Get psNamespace to sOldNS
79573>>>>>>>>>        Set psNamespace to sNS
79574>>>>>>>>>        Send defineParam xsStruct hoStruct iMin iMax sName "" False
79575>>>>>>>>>        Set psNamespace to sOldNS
79576>>>>>>>>>    End_Procedure
79577>>>>>>>>>
79577>>>>>>>>>    // Used to define attribute parameters (i.e., struct members that are handled as attributes within the xml.
79577>>>>>>>>>    Procedure defineAttributeParameter Integer eType String sDefault String sName String sNS
79579>>>>>>>>>        tSoapParamDef[] SoapParams
79579>>>>>>>>>        tSoapParamDef[] SoapParams
79580>>>>>>>>>        tSoapParamDef   SoapParam
79580>>>>>>>>>        tSoapParamDef   SoapParam
79580>>>>>>>>>        Integer iCount
79580>>>>>>>>>        Move sName       to SoapParam.sName
79581>>>>>>>>>        Move sNS         to SoapParam.sNameSpace
79582>>>>>>>>>        Move eType       to SoapParam.eType
79583>>>>>>>>>        Move sDefault    to SoapParam.sDefaultAttr
79584>>>>>>>>>        Move True        to SoapParam.bAttribute
79585>>>>>>>>>
79585>>>>>>>>>        Get pSoapParamDefs  to SoapParams
79586>>>>>>>>>        Move (SizeOfArray(SoapParams)) to iCount
79587>>>>>>>>>        Move SoapParam to SoapParams[iCount]
79588>>>>>>>>>        Set pSoapParamDefs to SoapParams
79589>>>>>>>>>    End_Procedure
79590>>>>>>>>>
79590>>>>>>>>>
79590>>>>>>>>>    Procedure defineIsNullMember
79592>>>>>>>>>        Send defineParam xsIsNullMember 0 0 0 "" "" False
79593>>>>>>>>>    End_Procedure
79594>>>>>>>>>
79594>>>>>>>>>    Procedure defineSimpleNullableParameter Integer eType Integer iMin Integer iMax String sName
79596>>>>>>>>>        Send defineParam eType 0 iMin iMax sName "" True
79597>>>>>>>>>    End_Procedure
79598>>>>>>>>>    
79598>>>>>>>>>    Procedure defineBase64BinaryParameter Integer iMin Integer iMax String sName String sMimeData
79600>>>>>>>>>        Send defineParam xsBase64Binary 0 iMin iMax sName sMimeData False
79601>>>>>>>>>    End_Procedure
79602>>>>>>>>>
79602>>>>>>>>>    Procedure defineQualBase64BinaryParameter Integer iMin Integer iMax String sName String sNS String sMimeData
79604>>>>>>>>>        String sOldNS
79604>>>>>>>>>        Get psNamespace to sOldNS
79605>>>>>>>>>        Set psNamespace to sNS
79606>>>>>>>>>        Send defineBase64BinaryParameter iMin iMax sName sMimeData
79607>>>>>>>>>        Set psNamespace to sOldNS
79608>>>>>>>>>    End_Procedure
79609>>>>>>>>>
79609>>>>>>>>>End_Class
79610>>>>>>>>>
79610>>>>>>>>>
79610>>>>>>>>>// Generic class that any web-service is based on. Mostly Abstract. Used to
79610>>>>>>>>>// create actual classes but could be used to handle dynamic web-services
79610>>>>>>>>>
79610>>>>>>>>>Class cClientWebService is a cObject
79611>>>>>>>>>
79611>>>>>>>>>    Procedure Construct_Object
79613>>>>>>>>>        
79613>>>>>>>>>        Forward Send Construct_Object
79615>>>>>>>>>        Property String psWSDLLocation         ''
79616>>>>>>>>>        Property String psServiceLocation      ''
79617>>>>>>>>>
79617>>>>>>>>>        // xsd schema types
79617>>>>>>>>>        Property String  psSchemaNSPre         "xs"
79618>>>>>>>>>        Property String  psSchemaNSUri         C_XMLSCHEMAURI
79619>>>>>>>>>
79619>>>>>>>>>        // xsi schema instance
79619>>>>>>>>>        Property String  psSchemaInstanceNSPre "xsi"
79620>>>>>>>>>        Property String  psSchemaInstanceNSUri C_XMLSCHEMAXSIURI
79621>>>>>>>>>
79621>>>>>>>>>        // soap envelope
79621>>>>>>>>>        Property String  psSoapEnvNsPre        "soap"
79622>>>>>>>>>        Property String  psSoapEnvNsUri        C_SOAPENVELOPEURI
79623>>>>>>>>>
79623>>>>>>>>>        // soap encoding
79623>>>>>>>>>        Property String  psSoapEncodingNsPre   "soapenc"
79624>>>>>>>>>        Property String  psSoapEncodingNsUri   C_SOAPENCODINGURI
79625>>>>>>>>>
79625>>>>>>>>>        Property String  psMethodsNsPre        "m"
79626>>>>>>>>>
79626>>>>>>>>>        Property String  psXmlVersion          "1.0"
79627>>>>>>>>>        Property String  psXmlEncoding         "UTF-8"
79628>>>>>>>>>        Property Integer piPort                0 // dflt here is 0, which means it uses default values of http or ssl/http
79629>>>>>>>>>        // This is what most services expect. However, it is possible that this will
79629>>>>>>>>>        // need to be changed.
79629>>>>>>>>>        Property String  psContentType         (C_ContentTypeSOAP + "; charset=UTF-8")
79630>>>>>>>>>        Property String  psContentTypeExpected  C_ContentTypeSOAP
79631>>>>>>>>>        Property String  psHttpUserAgent       "DataFlex/17"
79632>>>>>>>>>
79632>>>>>>>>>        Property String psUserName ''          // passed through to http object
79633>>>>>>>>>        Property String psPassword ''          // passed through to http object
79634>>>>>>>>>
79634>>>>>>>>>        // if client certificate is needed it is defined here.
79634>>>>>>>>>        // The certificate must be installed on the machine. Note that most SSL does not require this.
79634>>>>>>>>>        Property String psCertificateStore   ''
79635>>>>>>>>>        Property String psCertificateSubject ''
79636>>>>>>>>>
79636>>>>>>>>>
79636>>>>>>>>>        // these get set by the methods that are created in the sub-class
79636>>>>>>>>>        Property String  psSOAPAction          ''
79637>>>>>>>>>        Property Integer peSoapStyle           ssDocument // ssDocument|ssRPC
79638>>>>>>>>>
79638>>>>>>>>>        Property String  psRequestNSURI        ''
79639>>>>>>>>>        Property Integer peSoapEncoding        seLiteral  // seLiteral|seEncoded
79640>>>>>>>>>        Property String  psMethodRequest       ''         // e.g. SayHello
79641>>>>>>>>>        Property Boolean pbRequestBare         False      // normally false, if True, document style does not have a wrapper
79642>>>>>>>>>
79642>>>>>>>>>        Property String  psResponseNSURI       ''
79643>>>>>>>>>        Property Integer peResponseSoapEncoding seLiteral // I am not sure we need this
79644>>>>>>>>>        Property String  psMethodResponse      ''         // e.g. SayHelloResponse
79645>>>>>>>>>        Property Boolean pbResponseBare        False      // normally false, if True, document style does not have a wrapper
79646>>>>>>>>>        
79646>>>>>>>>>        Property Boolean pbValidateResponse    True       // safety valve. If turned off, we don't check to see if the return data
79647>>>>>>>>>                                                          // is formatted as expected. This should be a last step to make a service work
79647>>>>>>>>>
79647>>>>>>>>>
79647>>>>>>>>>        Property Integer peTransferStatus      wssOk
79648>>>>>>>>>
79648>>>>>>>>>        Property tSoapParameter[] pspParameters
79649>>>>>>>>>        Property tSoapParameter[] pspReturnParameters // array of return parameters allows support for ByRef variables
79650>>>>>>>>>
79650>>>>>>>>>        // this will do the actual transfer
79650>>>>>>>>>        Object oHTTP is a cXmlHttpTransfer
79652>>>>>>>>>            Set pbClearHeaders to False
79653>>>>>>>>>            Set piBufferSize   to 16000
79654>>>>>>>>>        End_Object
79655>>>>>>>>>
79655>>>>>>>>>        // handle to http object -- exposed for advanced usage and normally never used by developer
79655>>>>>>>>>        Property Handle phoHttp (oHTTP)
79656>>>>>>>>>
79656>>>>>>>>>        Property Handle phoSoapRequest  0
79657>>>>>>>>>        Property Handle phoSoapResponse 0
79658>>>>>>>>>        Property Handle phoSoapHeaderResponse 0 // s/b maintained using SoapHeaderResponseNode
79659>>>>>>>>>        Property Handle phoSoapHeaderRequest 0  // s/b maintained using ClearSoapHeaders and AddSoapHeaderNode and SoapHeaderRequestNode
79660>>>>>>>>>        Property String psFaultCode ''
79661>>>>>>>>>        Property String psFaultString ''
79662>>>>>>>>>
79662>>>>>>>>>
79662>>>>>>>>>        // used and maintained internally for a short time while parsing the return XML
79662>>>>>>>>>        // this points to the body node which will be used to resolve hrefs
79662>>>>>>>>>        Property Handle phoReturnBody 0
79663>>>>>>>>>
79663>>>>>>>>>        // if True errors are not reported in LastError. It then becomes up to the
79663>>>>>>>>>        // developer to test if a web service succeeded by checking peTransferStatus and
79663>>>>>>>>>        // then reporting the error as needed, using WebServiceErrorDescription to get the error message
79663>>>>>>>>>        Property Boolean pbSuppressLastError False
79664>>>>>>>>>
79664>>>>>>>>>        // this is helpful in testing and debugging
79664>>>>>>>>>        Property Handle phoSoapClientHelper 0     // when set message OnSoapReceived is sent to this object
79665>>>>>>>>>
79665>>>>>>>>>        Property Boolean pbRequestOnly False // if true, a one way request only, must be set in per call. 
79666>>>>>>>>>        
79666>>>>>>>>>        Property String psRefToken C_SOAPHREF
79667>>>>>>>>>
79667>>>>>>>>>        // This class only supports 1.1, so version is read-only. This might be changed
79667>>>>>>>>>        // in a superclass that supports SOAP1.2
79667>>>>>>>>>        Property Integer peSOAPVersion svSOAP11
79668>>>>>>>>>        
79668>>>>>>>>>        // determines how this service should be MTOM mime encoded.  
79668>>>>>>>>>        // keep private until MTOM is supported.
79668>>>>>>>>>        Property Integer peMtomXopRequest mxNever
79669>>>>>>>>>
79669>>>>>>>>>        // determines attribute name to be used as the mine marker. Unlikely to change
79669>>>>>>>>>        Property String psBase64MimeMarker C_MTOMMimeMarker
79670>>>>>>>>>
79670>>>>>>>>>        // maintained during service call and set true if there are any MTOM encodable nodes
79670>>>>>>>>>        Property Boolean pbRequestHasBase64Binary
79671>>>>>>>>>        
79671>>>>>>>>>    End_Procedure
79672>>>>>>>>>
79672>>>>>>>>>
79672>>>>>>>>>    // Defines a simple datatype parameter.
79672>>>>>>>>>    Function DefineParameter Integer eDataType Integer iMin Integer iMax String sName String sNS Returns tSoapParamDef
79674>>>>>>>>>        tSoapParamDef spParam
79674>>>>>>>>>        tSoapParamDef spParam
79674>>>>>>>>>        Move sName          to spParam.sName
79675>>>>>>>>>        Move sNS            to spParam.sNamespace
79676>>>>>>>>>        Move eDataType      to spParam.eType
79677>>>>>>>>>        Move iMin           to spParam.iMin
79678>>>>>>>>>        Move iMax           to spParam.iMax
79679>>>>>>>>>        Move False           to spParam.bSimpleNullable
79680>>>>>>>>>        Function_Return spParam
79681>>>>>>>>>    End_Function
79682>>>>>>>>>
79682>>>>>>>>>    // Defines a simple datatype parameter with nullable/nillable member
79682>>>>>>>>>    Function DefineSimpleNullableParameter Integer eDataType Integer iMin Integer iMax String sName String sNS Returns tSoapParamDef
79684>>>>>>>>>        tSoapParamDef spParam
79684>>>>>>>>>        tSoapParamDef spParam
79684>>>>>>>>>        Get DefineParameter eDataType iMin iMax sName sNS to spParam
79685>>>>>>>>>        Move True           to spParam.bSimpleNullable
79686>>>>>>>>>        Function_Return spParam
79687>>>>>>>>>    End_Function
79688>>>>>>>>>
79688>>>>>>>>>    // Defines a simple base64 parameter
79688>>>>>>>>>    Function DefineBase64BinaryParameter Integer iMin Integer iMax String sName String sNS String sMimeData Returns tSoapParamDef
79690>>>>>>>>>        tSoapParamDef spParam
79690>>>>>>>>>        tSoapParamDef spParam
79690>>>>>>>>>        Get DefineParameter xsBase64Binary iMin iMax sName sNS to spParam
79691>>>>>>>>>        Move sMimeData      to spParam.sMimeData
79692>>>>>>>>>        Function_Return spParam
79693>>>>>>>>>    End_Function
79694>>>>>>>>>    
79694>>>>>>>>>    Function DefineStructParameter Handle hoStruct Integer iMin Integer iMax String sName String sNS Returns tSoapParamDef
79696>>>>>>>>>        tSoapParamDef spParam
79696>>>>>>>>>        tSoapParamDef spParam
79696>>>>>>>>>        Move sName          to spParam.sName
79697>>>>>>>>>        Move sNS            to spParam.sNamespace
79698>>>>>>>>>        Move xsStruct       to spParam.eType
79699>>>>>>>>>        Move hoStruct       to spParam.hoStruct
79700>>>>>>>>>        Move iMin           to spParam.iMin
79701>>>>>>>>>        Move iMax           to spParam.iMax
79702>>>>>>>>>        Move False          to spParam.bSimpleNullable
79703>>>>>>>>>        Function_Return spParam
79704>>>>>>>>>    End_Function
79705>>>>>>>>>
79705>>>>>>>>>
79705>>>>>>>>>
79705>>>>>>>>>    // Structs are Arrays are created using the above two methods
79705>>>>>>>>>
79705>>>>>>>>>    // reset everything for a new call
79705>>>>>>>>>    Procedure Reset
79707>>>>>>>>>        Handle hoXml
79707>>>>>>>>>        tSoapParameter[] EmptySoapParams
79707>>>>>>>>>        tSoapParameter[] EmptySoapParams
79708>>>>>>>>>
79708>>>>>>>>>        Get phoSoapRequest to hoXml
79709>>>>>>>>>        Set phoSoapRequest to 0
79710>>>>>>>>>        If hoXML Send destroy of hoXml
79713>>>>>>>>>
79713>>>>>>>>>        Get phoSoapResponse to hoXml
79714>>>>>>>>>        Set phoSoapResponse to 0
79715>>>>>>>>>        If hoXML Send destroy of hoXml
79718>>>>>>>>>        
79718>>>>>>>>>        Get phoSoapHeaderResponse to hoXml
79719>>>>>>>>>        Set phoSoapHeaderResponse to 0
79720>>>>>>>>>        If hoXML Send destroy of hoXml
79723>>>>>>>>>        
79723>>>>>>>>>        // note we don't clear soap request headers. A developer must do that manually
79723>>>>>>>>>        // by sending ClearSoapHeaders
79723>>>>>>>>>
79723>>>>>>>>>        Send ClearHeaders of (phoHttp(Self))
79724>>>>>>>>>
79724>>>>>>>>>        Set psRequestNSURI      to ''
79725>>>>>>>>>        Set psSOAPAction        to ''
79726>>>>>>>>>        Set peSoapStyle         to ''
79727>>>>>>>>>        Set psResponseNSURI     to ssDocument
79728>>>>>>>>>        Set peSoapEncoding      to seLiteral
79729>>>>>>>>>        Set peResponseSoapEncoding to seLiteral
79730>>>>>>>>>        Set psMethodRequest     to ''
79731>>>>>>>>>        Set psMethodResponse    to ''
79732>>>>>>>>>        Set peTransferStatus    to wssOk
79733>>>>>>>>>        Set psFaultCode         to ''
79734>>>>>>>>>        Set psFaultString       to ''
79735>>>>>>>>>        Set pspParameters       to EmptySoapParams  // clear input params
79736>>>>>>>>>        Set pspReturnParameters to EmptySoapParams  // clear return params
79737>>>>>>>>>        
79737>>>>>>>>>        Set pbRequestOnly to False // default to normal request/response
79738>>>>>>>>>        Set pbRequestHasBase64Binary to False // will get reset if we have one
79739>>>>>>>>>    End_Procedure
79740>>>>>>>>>    
79740>>>>>>>>>    // Clear all Soap headers. Should be called before invoking a web-service call if the object
79740>>>>>>>>>    // use soap headers.
79740>>>>>>>>>    Procedure ClearSoapHeaders
79742>>>>>>>>>        Handle hoXml
79742>>>>>>>>>        Get phoSoapHeaderRequest to hoXml
79743>>>>>>>>>        If hoXML Send destroy of hoXml
79746>>>>>>>>>        Set phoSoapHeaderRequest to 0
79747>>>>>>>>>    End_Procedure
79748>>>>>>>>>
79748>>>>>>>>>    // Adds a new soap header which gets added to any soap request sent by this object. 
79748>>>>>>>>>    // it is the programmers responsibilty to send a valid element node
79748>>>>>>>>>    // if the data is bad or missing an error is generated and nothing is added.
79748>>>>>>>>>    // such an error would be considered to a programing error  
79748>>>>>>>>>    Procedure AddSoapHeaderNode Handle hoNode
79750>>>>>>>>>        Handle hoHeader hoRoot hoNew hoNew1
79750>>>>>>>>>        String sSoapNs sSoapNSPre
79750>>>>>>>>>        
79750>>>>>>>>>        // if node is not passed or it is not an element, this is an error
79750>>>>>>>>>        If (hoNode=0 or piNodeType(hoNode)<>NODE_ELEMENT) Begin
79752>>>>>>>>>            Error  DFERR_CLIENT_SOAP_TRANSFER C_$CannotAddSOAPRequestHeader
79753>>>>>>>>>>
79753>>>>>>>>>            Procedure_Return
79754>>>>>>>>>        End
79754>>>>>>>>>>
79754>>>>>>>>>
79754>>>>>>>>>        Get phoSoapHeaderRequest to hoHeader
79755>>>>>>>>>        // if no header yet, create it, either wat get the root element
79755>>>>>>>>>        If not hoHeader Begin
79757>>>>>>>>>            Get psSoapEnvNsUri to sSoapNS
79758>>>>>>>>>            Get psSoapEnvNsPre to sSoapNSPre
79759>>>>>>>>>            Get Create U_cXmlDomDocument to hoHeader
79760>>>>>>>>>            Get CreateDocumentElementNS of hoHeader sSoapNS (sSoapNSPre + ":Header") to hoRoot
79761>>>>>>>>>            Set phoSoapHeaderRequest to hoHeader
79762>>>>>>>>>        End
79762>>>>>>>>>>
79762>>>>>>>>>        Else Begin
79763>>>>>>>>>            Get DocumentElement of hoHeader to hoRoot
79764>>>>>>>>>        End
79764>>>>>>>>>>
79764>>>>>>>>>
79764>>>>>>>>>        If hoRoot Begin
79766>>>>>>>>>            Get CloneNode of hoNode True to hoNew
79767>>>>>>>>>            If hoNew Begin
79769>>>>>>>>>                Get AppendNode of hoRoot hoNew to hoNew1 // if hoNew1, the append failed. 
79770>>>>>>>>>                Send Destroy of hoNew
79771>>>>>>>>>            End    
79771>>>>>>>>>>
79771>>>>>>>>>            Send Destroy of hoRoot
79772>>>>>>>>>        End
79772>>>>>>>>>>
79772>>>>>>>>>    End_Procedure
79773>>>>>>>>>    
79773>>>>>>>>>    Function CopyXMLDocument Handle hoXML Returns Handle
79775>>>>>>>>>        Handle hoRoot hoNew
79775>>>>>>>>>        Handle hoNewXml hoNewRoot
79775>>>>>>>>>        Boolean bOk
79775>>>>>>>>>        // passing a 0 handle is allowed. It means there is no document. return 0
79775>>>>>>>>>        If hoXml Begin
79777>>>>>>>>>            // we use desktop so that this object persists
79777>>>>>>>>>            Get Create of desktop U_cXmlDomDocument to hoNewXml  // create new xml at desktop
79778>>>>>>>>>            Get CopyXMLtoXML hoXML hoNewXml to bOk
79779>>>>>>>>>            If not bOk Begin
79781>>>>>>>>>                // this is an error and the append never happened
79781>>>>>>>>>                Send Destroy of hoNewXml // for now return no object at all
79782>>>>>>>>>                Move 0 to hoNewXml
79783>>>>>>>>>            End
79783>>>>>>>>>>
79783>>>>>>>>>        End
79783>>>>>>>>>>
79783>>>>>>>>>        Function_Return hoNewXml
79784>>>>>>>>>    End_Function
79785>>>>>>>>>
79785>>>>>>>>>    // copy from xml to NewXML. hoXML must exist and hoNewXML must exist and be empty
79785>>>>>>>>>    Function CopyXMLToXML Handle hoXML Handle hoNewXml Returns Boolean
79787>>>>>>>>>        Handle hoRoot hoNew
79787>>>>>>>>>        Handle hoNewRoot hoNewRoot1
79787>>>>>>>>>        Get DocumentElement of hoXml to hoRoot
79788>>>>>>>>>        If hoRoot Begin
79790>>>>>>>>>            Get CloneNode of hoRoot True to hoNewRoot         // make a copy at the root 
79791>>>>>>>>>            If hoNewRoot Begin
79793>>>>>>>>>                Get AppendNode of hoNewXml hoNewRoot to hoNewRoot1 // add the copied node to this object
79794>>>>>>>>>                Send Destroy of hoNewRoot
79795>>>>>>>>>            End
79795>>>>>>>>>>
79795>>>>>>>>>            Send Destroy of hoRoot
79796>>>>>>>>>        End
79796>>>>>>>>>>
79796>>>>>>>>>        Else Begin
79797>>>>>>>>>            // this should not happen. We will return false, but it means we have a bad source xml document
79797>>>>>>>>>        End
79797>>>>>>>>>>
79797>>>>>>>>>        Function_Return (hoNewRoot1<>0)
79798>>>>>>>>>    End_Function
79799>>>>>>>>>
79799>>>>>>>>>    // Return an xml document of the soap header from the request. 
79799>>>>>>>>>    // It is the reponsibility of the calling method to dispose of this xml node (i.e., destroy it)
79799>>>>>>>>>    Function SoapHeaderRequestNode Returns Handle
79801>>>>>>>>>        Handle hoHeader hoXmlNode
79801>>>>>>>>>        Get phoSoapHeaderRequest to hoHeader
79802>>>>>>>>>        Get CopyXMLDocument hoHeader to hoXmlNode
79803>>>>>>>>>        Function_Return hoXmlNode
79804>>>>>>>>>    End_Function
79805>>>>>>>>>
79805>>>>>>>>>    // Return an xml document of the soap header from the response. 
79805>>>>>>>>>    // It is the reponsibility of the calling method to dispose of this xml node (i.e., destroy it)
79805>>>>>>>>>    Function SoapHeaderResponseNode Returns Handle
79807>>>>>>>>>        Handle hoHeader hoXmlNode
79807>>>>>>>>>        Get phoSoapHeaderResponse to hoHeader
79808>>>>>>>>>        Get CopyXMLDocument hoHeader to hoXmlNode
79809>>>>>>>>>        Function_Return hoXmlNode
79810>>>>>>>>>    End_Function
79811>>>>>>>>>
79811>>>>>>>>>    Procedure SetSoapAction
79813>>>>>>>>>        String sSOAPAction sContentType
79813>>>>>>>>>        Handle hoHttp
79813>>>>>>>>>        Boolean bOk
79813>>>>>>>>>        Get psSOAPAction to sSOAPAction
79814>>>>>>>>>        // according to soap specs, the SOAPAction should be enclosed in quotes. We assume that the
79814>>>>>>>>>        // quote is not in the property and add them here.
79814>>>>>>>>>        Get phoHttp to hoHttp
79815>>>>>>>>>        Get AddHeader     of hoHttp "SOAPAction" ('"' - sSOAPAction - '"') to bOk
79816>>>>>>>>>    End_Procedure
79817>>>>>>>>>
79817>>>>>>>>>    Function DoInvokeService Returns Integer
79819>>>>>>>>>        Handle hoXml hoXmlResponse hoSoapResponse
79819>>>>>>>>>        Integer eStatus iPort iRemotePort eTransferFlags
79819>>>>>>>>>        Boolean bIsHttps bRequestOnly
79819>>>>>>>>>        String sServiceHost sServiceFilePath sSOAPAction sServiceLocation
79819>>>>>>>>>        String sCertificateStore sCertificateSubject
79819>>>>>>>>>
79819>>>>>>>>>        Integer iPos
79819>>>>>>>>>        Boolean bOk
79819>>>>>>>>>        Handle hoHttp
79819>>>>>>>>>
79819>>>>>>>>>        Get phoHttp to hoHttp
79820>>>>>>>>>        Get pbRequestOnly to bRequestOnly
79821>>>>>>>>>
79821>>>>>>>>>        Get CreateSoapRequest to hoXml
79822>>>>>>>>>        If not hoXML Begin
79824>>>>>>>>>           Set peTransferStatus to wssBadRequest
79825>>>>>>>>>           Send OnSoapReceived
79826>>>>>>>>>           Function_Return wssBadRequest
79827>>>>>>>>>        End
79827>>>>>>>>>>
79827>>>>>>>>>
79827>>>>>>>>>        Set phoSoapRequest to hoXML
79828>>>>>>>>>
79828>>>>>>>>>        Send SetSoapAction
79829>>>>>>>>>
79829>>>>>>>>>        // Set up HTTP object
79829>>>>>>>>>        Set psAcceptTypes of hoHttp to "text/*"
79830>>>>>>>>>        // content type is set by the http object via this property
79830>>>>>>>>>        Set psContentTypeSent of hoHttp to (psContentType(Self))
79831>>>>>>>>>        Set psContentTypeExpected of hoHttp to (psContentTypeExpected(Self))
79832>>>>>>>>>
79832>>>>>>>>>
79832>>>>>>>>>        // Make SOAP call via XMLHTTP POST
79832>>>>>>>>>        Get psServiceLocation to sServiceLocation
79833>>>>>>>>>        //
79833>>>>>>>>>        Send CrackUrl sServiceLocation (&iPort) (&bIsHttps) (&sServiceHost) (&sServiceFilePath)
79834>>>>>>>>>        // for assigning ports. If port is passed in URL, always use it, Else if piPort is set, use it, else
79834>>>>>>>>>        // use dflt http and http/ssl ports
79834>>>>>>>>>        Get piPort to iRemotePort // see if we are forcing a value
79835>>>>>>>>>        If (iRemotePort=0) Begin
79837>>>>>>>>>            Move (If(bIsHttps, rpHttpSSL, rpHttp)) to iRemotePort
79838>>>>>>>>>        End
79838>>>>>>>>>>
79838>>>>>>>>>        Set piRemotePort of hoHttp to (If(iPort=0,iRemotePort,iPort))
79839>>>>>>>>>
79839>>>>>>>>>        // set/clear secure bit in transfer flags. Developer might need to set other flags by setting peTransferFlags in phoHttp.
79839>>>>>>>>>        // For example a client certificate might require IfIgnoreCertDateInvalid + IfIgnoreCertCnInvalid.
79839>>>>>>>>>        Get peTransferFlags of hoHttp to eTransferFlags
79840>>>>>>>>>        If bIsHttps Begin
79842>>>>>>>>>            Set peTransferFlags of hoHttp to  (AddBitValue(ifSecure, eTransferFlags)) // if secure we must set this flag
79843>>>>>>>>>        End
79843>>>>>>>>>>
79843>>>>>>>>>        Else Begin
79844>>>>>>>>>            Set peTransferFlags of hoHttp to  (RemoveBitValue(ifSecure, eTransferFlags)) // if secure we must unset this flag
79845>>>>>>>>>        End
79845>>>>>>>>>>
79845>>>>>>>>>
79845>>>>>>>>>        Set psUserName of hoHttp to (psUserName(Self))
79846>>>>>>>>>        Set psPassword of hoHttp to (psPassword(Self))
79847>>>>>>>>>
79847>>>>>>>>>        Get psCertificateStore   to sCertificateStore
79848>>>>>>>>>        Get psCertificateSubject to sCertificateSubject
79849>>>>>>>>>        If (sCertificateStore<>"" or sCertificateSubject<>"") Begin
79851>>>>>>>>>            Get SelectClientCertificate of hoHttp sCertificateStore sCertificateSubject to bOk
79852>>>>>>>>>        End
79852>>>>>>>>>>
79852>>>>>>>>>
79852>>>>>>>>>        Set pbDataRequiredReceived of hoHttp to (not(bRequestOnly))
79853>>>>>>>>>
79853>>>>>>>>>        Get HttpPostXmlNode of hoHttp sServiceHost sServiceFilePath hoXML to hoXMLResponse
79854>>>>>>>>>
79854>>>>>>>>>        //Loop test
79854>>>>>>>>>        //Move hoXml to hoXmlResponse    
79854>>>>>>>>>
79854>>>>>>>>>
79854>>>>>>>>>        // we have an error or no response expected, return status code as needed
79854>>>>>>>>>        If (hoXmlResponse=0) Begin
79856>>>>>>>>>            Get peXmlTransferStatus of hoHttp to eStatus
79857>>>>>>>>>            Case Begin
79857>>>>>>>>>
79857>>>>>>>>>                // If Ok and no request needed, we are ok
79857>>>>>>>>>                Case (eStatus=xtsOk and bRequestOnly) Move wssOk to eStatus
79860>>>>>>>>>                
79860>>>>>>>>>                Case (eStatus=xtsHttpRequestFailed)  Move wssHttpRequestFailed to eStatus
79864>>>>>>>>>                Case (eStatus=xtsBadRequest)         Move wssBadRequest to eStatus
79868>>>>>>>>>                Case (eStatus=xtsInvalidContentType) Move wssInvalidContentType to eStatus
79872>>>>>>>>>                Case (eStatus=xtsNoData)             Move wssNoData to eStatus
79876>>>>>>>>>                Case (eStatus=xtsNotXml)             Move wssNotXml to eStatus
79880>>>>>>>>>                Case Else                            Move wssError to eStatus
79882>>>>>>>>>            Case End
79882>>>>>>>>>        End
79882>>>>>>>>>>
79882>>>>>>>>>        Else Begin
79883>>>>>>>>>            // If we have a good response we want to save it in phoSoapRespone.
79883>>>>>>>>>            // The XML response is at the desktop so we must first copy it to
79883>>>>>>>>>            // this object so it will get destroyed if the object is dynamically
79883>>>>>>>>>            // destroyed.
79883>>>>>>>>>            
79883>>>>>>>>>            // If this was a one-way SOAP that had a response we will assume this is a "robust in-only" service where the only
79883>>>>>>>>>            // allowed response is either nothing (and we will not be here) or a fault. Therefore the status should be a fault. Any other
79883>>>>>>>>>            // XML should return some other kind of error. It is not clear if robust in-only is supported in soap1.1, but if it is there
79883>>>>>>>>>            // we can use it. 
79883>>>>>>>>>            
79883>>>>>>>>>            Get Create U_cXmlDomDocument to hoSoapResponse       // create within this object
79884>>>>>>>>>            Get CopyXMLToXML hoXmlResponse hoSoapResponse to bOk // copy to new object
79885>>>>>>>>>            If bOk Begin
79887>>>>>>>>>                // save the new local XML resposne node and process
79887>>>>>>>>>                Set phoSoapResponse to hoSoapResponse
79888>>>>>>>>>                Get DoSetSoapReturn to eStatus
79889>>>>>>>>>            End
79889>>>>>>>>>>
79889>>>>>>>>>            Else Begin
79890>>>>>>>>>                // this should not happen. It means that the returned XML could not
79890>>>>>>>>>                // be copied, which implies it was not XML.
79890>>>>>>>>>                Send Destroy of hoSoapResponse
79891>>>>>>>>>                Move wssNotXml to eStatus
79892>>>>>>>>>            End
79892>>>>>>>>>>
79892>>>>>>>>>        End
79892>>>>>>>>>>
79892>>>>>>>>>        
79892>>>>>>>>>        If hoXmlResponse Begin
79894>>>>>>>>>            // remove the desktop XML node.
79894>>>>>>>>>            Send Destroy of hoXmlResponse
79895>>>>>>>>>        End
79895>>>>>>>>>>
79895>>>>>>>>>        
79895>>>>>>>>>        Set peTransferStatus to eStatus
79896>>>>>>>>>        Send OnSoapReceived
79897>>>>>>>>>        Function_Return eStatus
79898>>>>>>>>>    End_Function
79899>>>>>>>>>
79899>>>>>>>>>    // Take sUrl and move to components
79899>>>>>>>>>    Procedure CrackUrl String sUrl Integer ByRef iPort Boolean ByRef bIsHttps String ByRef sHost String ByRef sFilepath
79901>>>>>>>>>        Integer iPos iPosEnd
79901>>>>>>>>>        String sTemp
79901>>>>>>>>>
79901>>>>>>>>>        Move 0 to iPort
79902>>>>>>>>>        Move False to bIsHttps
79903>>>>>>>>>
79903>>>>>>>>>        Move (trim(sUrl)) to sUrl
79904>>>>>>>>>
79904>>>>>>>>>        Move (lowercase(sUrl)) to sTemp
79905>>>>>>>>>        If (left(sTemp,8)="https://") Begin
79907>>>>>>>>>            Move True to bIsHttps
79908>>>>>>>>>            Move (Remove(sUrl,1,8)) to sUrl
79909>>>>>>>>>        End
79909>>>>>>>>>>
79909>>>>>>>>>        Else If (left(sTemp,7)="http://") Begin
79912>>>>>>>>>            Move (Remove(sUrl,1,7)) to sUrl
79913>>>>>>>>>        End
79913>>>>>>>>>>
79913>>>>>>>>>        // see if port is provded
79913>>>>>>>>>        Move (pos(":",sUrl)) to iPos
79914>>>>>>>>>        If iPos Begin
79916>>>>>>>>>            Move (pos("/",sUrl)) to iPosEnd
79917>>>>>>>>>            If (iPosEnd>iPos) Begin
79919>>>>>>>>>                Move (mid(sUrl,iPosEnd-iPos-1,iPos+1)) to iPort
79920>>>>>>>>>                Move (Remove(sUrl,iPos,iPosEnd-iPos)) to sUrl
79921>>>>>>>>>            End
79921>>>>>>>>>>
79921>>>>>>>>>        End
79921>>>>>>>>>>
79921>>>>>>>>>        Move (pos("/",sUrl)) to iPos
79922>>>>>>>>>        If iPos Begin
79924>>>>>>>>>            Move (left(sUrl,iPos-1)) to sHost
79925>>>>>>>>>            Move (Remove(sUrl,1,iPos)) to sFilePath
79926>>>>>>>>>        End
79926>>>>>>>>>>
79926>>>>>>>>>        Else Begin
79927>>>>>>>>>            Move sUrl to sHost
79928>>>>>>>>>            Move '' to sFilePath
79929>>>>>>>>>        End
79929>>>>>>>>>>
79929>>>>>>>>>    End_Procedure
79930>>>>>>>>>    
79930>>>>>>>>>    Function NextNonCommentNode Handle hoNode Returns Handle
79932>>>>>>>>>        Integer eType
79932>>>>>>>>>        Get NextNode of hoNode to hoNode
79933>>>>>>>>>        While (hoNode)
79937>>>>>>>>>            Get piNodeType of hoNode to eType
79938>>>>>>>>>            If (eType<>NODE_COMMENT) Begin
79940>>>>>>>>>                Function_Return hoNode
79941>>>>>>>>>            End
79941>>>>>>>>>>
79941>>>>>>>>>            Get NextNode of hoNode to hoNode
79942>>>>>>>>>        Loop
79943>>>>>>>>>>
79943>>>>>>>>>        Function_Return 0
79944>>>>>>>>>    End_Function
79945>>>>>>>>>
79945>>>>>>>>>    Function FirstNonCommentChild Handle hoNode Returns Handle
79947>>>>>>>>>        Integer eType
79947>>>>>>>>>        Handle hoChild
79947>>>>>>>>>        Get FirstChild of hoNode to hoChild
79948>>>>>>>>>        If (hoChild) Begin
79950>>>>>>>>>            Get piNodeType of hoChild to eType
79951>>>>>>>>>            If (eType=NODE_COMMENT) Begin
79953>>>>>>>>>                Get NextNonCommentNode hoChild to hoChild
79954>>>>>>>>>            End
79954>>>>>>>>>>
79954>>>>>>>>>        End
79954>>>>>>>>>>
79954>>>>>>>>>        Function_Return hoChild
79955>>>>>>>>>    End_Function
79956>>>>>>>>>
79956>>>>>>>>>    Function DoSetSoapReturn Returns Integer
79958>>>>>>>>>        Handle hoXml hoRoot hoParam hoBody hoParam2 hoParam3 hoReturn
79958>>>>>>>>>        Handle hoHeader hoNewRoot
79958>>>>>>>>>        String sReturn sSoapEnvNSUri sResponseNSURI sMethodResponse sNameSpace
79958>>>>>>>>>        Integer eSoapStyle eStatus iError
79958>>>>>>>>>        Boolean bResponseBare bValidateResponse
79958>>>>>>>>>        tSoapParameter[] ReturnParameters
79958>>>>>>>>>        tSoapParameter[] ReturnParameters
79959>>>>>>>>>        Integer iReturnParameters iParam
79959>>>>>>>>>        // it is possible to have multiple return values in the case of a ByRef web-service. At this level we don't know where
79959>>>>>>>>>        // the return values will get assigned (the sub class does this). We just parse all the return variables and place them
79959>>>>>>>>>        // in the return array.
79959>>>>>>>>>        Get pspReturnParameters to ReturnParameters
79960>>>>>>>>>
79960>>>>>>>>>        Get psSoapEnvNSUri   to sSoapEnvNSUri
79961>>>>>>>>>        Get psResponseNSURI  to sResponseNSURI
79962>>>>>>>>>        Get psMethodResponse to sMethodResponse
79963>>>>>>>>>        Get peSoapStyle      to eSoapStyle
79964>>>>>>>>>        Get pbResponseBare   to bResponseBare
79965>>>>>>>>>        Get pbValidateResponse to bValidateResponse
79966>>>>>>>>>        Move wssNotXml to eStatus
79967>>>>>>>>>
79967>>>>>>>>>        Get phoSoapResponse  to hoXML
79968>>>>>>>>>        If (hoXML=0) Function_Return eStatus
79971>>>>>>>>>
79971>>>>>>>>>        Get DocumentElement of hoXML to hoRoot
79972>>>>>>>>>        If hoRoot Begin // s/b soap:Envelope
79974>>>>>>>>>            If (IsElementNS(hoRoot,sSoapEnvNSUri,"Envelope")) Begin
79976>>>>>>>>>                Get FirstNonCommentChild hoRoot to hoBody // s/b soap:Header or soap:Body
79977>>>>>>>>>
79977>>>>>>>>>                If (hoBody and IsElementNS(hoBody,sSoapEnvNSUri,"Header")) Begin
79979>>>>>>>>>                    
79979>>>>>>>>>                    // handle a soap header response. Just save the soapheader as an xml document
79979>>>>>>>>>                    
79979>>>>>>>>>                    // create a header xml document as child of web-service object
79979>>>>>>>>>                    Get CloneNode of hoBody True to hoNewRoot
79980>>>>>>>>>                    Get Create U_cXmlDomDocument to hoHeader
79981>>>>>>>>>                    Get AppendNode of hoHeader hoNewRoot to hoNewRoot // add the copied node to this object
79982>>>>>>>>>                    Send destroy of hoNewRoot
79983>>>>>>>>>                    Set phoSoapHeaderResponse to hoHeader
79984>>>>>>>>>                    
79984>>>>>>>>>                    Get NextNonCommentNode hoBody to hoBody // and now get the real body   
79985>>>>>>>>>                End
79985>>>>>>>>>>
79985>>>>>>>>>                   
79985>>>>>>>>>                If hoBody Begin
79987>>>>>>>>>                   Set phoReturnBody to hoBody
79988>>>>>>>>>                   If (IsElementNS(hoBody,sSoapEnvNSUri,"Body")) Begin
79990>>>>>>>>>                       Get FirstNonCommentChild hoBody to hoParam // should be ResponseURI:MethodResposne or Soap:Fault
79991>>>>>>>>>                       If hoParam Begin
79993>>>>>>>>>                           If (IsElementNS(hoParam,sSoapEnvNSUri,"Fault")) Begin
79995>>>>>>>>>                               Get HandleSoapFault hoParam to eStatus
79996>>>>>>>>>                           End
79996>>>>>>>>>>
79996>>>>>>>>>                           Else Begin
79997>>>>>>>>>                               Move wssInvalidSoap to eStatus // next most likely error
79998>>>>>>>>>                               // we would expect the return struct and its child return value to adhere to
79998>>>>>>>>>                               // the expected MethodResponse and MethodReturn names as defined in the WSDL.
79998>>>>>>>>>                               // However, if the style is RPC this is not required (the names of these do not
79998>>>>>>>>>                               // matter) and we will allow any element name.
79998>>>>>>>>>                               // We also allow bare style through. It will get error checked further below
79998>>>>>>>>>                               If (eSoapStyle=ssRPC or bResponseBare or not(bValidateResponse) or IsElementNS(hoParam,sResponseNSURI,sMethodResponse)) Begin
80000>>>>>>>>>                                   Move (SizeOfArray(ReturnParameters)) to iReturnParameters
80001>>>>>>>>>                                   If (iReturnParameters=0) Begin
80003>>>>>>>>>                                       // There are no expected return parameters.
80003>>>>>>>>>                                       // If we are this far we've recieved a valid response and we are done
80003>>>>>>>>>                                       Move wssOk to eStatus
80004>>>>>>>>>                                   End
80004>>>>>>>>>>
80004>>>>>>>>>                                   Else Begin
80005>>>>>>>>>
80005>>>>>>>>>                                       // get the first return parameter
80005>>>>>>>>>                                       If bResponseBare Begin
80007>>>>>>>>>                                           // if bare, there is no outer wrapper. So the current element is the inner
80007>>>>>>>>>                                           // wrapper. Create a copy of this and use it.
80007>>>>>>>>>                                           Get CloneNode of hoParam True to hoParam2
80008>>>>>>>>>                                           // if bare we must have only one return parameter
80008>>>>>>>>>                                           Move (If(iReturnParameters<>1,wssSoapFault,0)) to iError
80009>>>>>>>>>                                       End
80009>>>>>>>>>>
80009>>>>>>>>>                                       Else Begin
80010>>>>>>>>>                                           // if wrapped which is the more normal case, hoParam is the wrapper. The first child will be the 1st return param
80010>>>>>>>>>                                           Get FirstNonCommentChild hoParam to hoParam2
80011>>>>>>>>>                                           Move 0 to iError
80012>>>>>>>>>                                       End
80012>>>>>>>>>>
80012>>>>>>>>>
80012>>>>>>>>>                                       // process all return parameters. At the moment we only support multiple return variables if the
80012>>>>>>>>>                                       // schema defined them as <sequence>. We will support minOccurs 0 return values.
80012>>>>>>>>>                                       Move 0 to iParam
80013>>>>>>>>>//                                       While ( iError=0 and iParam<iReturnParameters)
80013>>>>>>>>>//                                           If hoParam2 Begin
80013>>>>>>>>>//                                               // if rpc, this should be in the global ws, if doc use respons NS
80013>>>>>>>>>//                                               Move (If(eSoapStyle=ssRpc,"",sResponseNSURI)) to sNamespace
80013>>>>>>>>>//                                               If (eSoapStyle=ssRPC or not(bValidateResponse) or ;
80013>>>>>>>>>//                                                     IsElementNS(hoParam2,ReturnParameters[iParam].SoapParamDef.sNamespace,ReturnParameters[iParam].SoapParamDef.sName)) Begin
80013>>>>>>>>>//                                                   // if any or xmlelement, we handle this with a special function.
80013>>>>>>>>>//                                                   If (ReturnParameters[iParam].SoapParamDef.eType=xsAnyType or ReturnParameters[iParam].SoapParamDef.eType=xsXmlElement) Begin
80013>>>>>>>>>//                                                      Get XmlHandleToValueTree ReturnParameters[iParam].SoapParamDef hoParam2 to ReturnParameters[iParam].ValueTree
80013>>>>>>>>>//                                                   End
80013>>>>>>>>>//                                                   Else Begin
80013>>>>>>>>>//                                                      // convert XML data to Value Tree data
80013>>>>>>>>>//                                                      Get XmlToValueTree ReturnParameters[iParam].SoapParamDef hoParam2 (&iError) to ReturnParameters[iParam].ValueTree
80013>>>>>>>>>//                                                   End
80013>>>>>>>>>//                                                   Get NextNonCommentNode hoParam2 to hoParam2
80013>>>>>>>>>//                                               End
80013>>>>>>>>>//                                               // if the param has the wrong name and it is a minOccurs=0, we assume we are skipping the param and the next will be ok
80013>>>>>>>>>//                                               Else If (ReturnParameters[iParam].SoapParamDef.iMin<>0) Begin
80013>>>>>>>>>//                                                   Move wssInvalidSoap to iError
80013>>>>>>>>>//                                               End
80013>>>>>>>>>//                                               Else Begin
80013>>>>>>>>>//                                                   // a iMin=0 with no items. We may want to mark this as null
80013>>>>>>>>>//                                                   Get CreateNullValueTree ReturnParameters[iParam].SoapParamDef to ReturnParameters[iParam].ValueTree
80013>>>>>>>>>//                                               End
80013>>>>>>>>>//                                           End
80013>>>>>>>>>//                                           // if no param it is possible it is a minOccurs=0, if so, skip the param. If not, this is anerror
80013>>>>>>>>>//                                           Else If (ReturnParameters[iParam].SoapParamDef.iMin<>0) Begin
80013>>>>>>>>>//                                               Move wssInvalidSoap to iError
80013>>>>>>>>>//                                           End
80013>>>>>>>>>//                                           Else Begin
80013>>>>>>>>>//                                               // a iMin=0 with no items. We may want to mark this as null
80013>>>>>>>>>//                                               Get CreateNullValueTree ReturnParameters[iParam].SoapParamDef to ReturnParameters[iParam].ValueTree
80013>>>>>>>>>//                                           End
80013>>>>>>>>>//                                           
80013>>>>>>>>>//                                           Increment iParam
80013>>>>>>>>>//                                       End
80013>>>>>>>>>                                       // process all return parameters. At the moment we only support multiple return variables if the
80013>>>>>>>>>                                       // schema defined them as <sequence>. We will support minOccurs 0 return values.
80013>>>>>>>>>                                       Move 0 to iParam
80014>>>>>>>>>                                       While ( iError=0 and iParam<iReturnParameters)
80018>>>>>>>>>                                           Get HandleReturnParameter ReturnParameters[iParam].SoapParamDef (&hoParam2) (&iError) to ReturnParameters[iParam].ValueTree 
80019>>>>>>>>>                                           Increment iParam
80020>>>>>>>>>                                       End
80021>>>>>>>>>>
80021>>>>>>>>>                                       Move (If(iError=0, wssOk, iError)) to eStatus
80022>>>>>>>>>                                   End
80022>>>>>>>>>>
80022>>>>>>>>>                                   If hoParam2 Begin
80024>>>>>>>>>                                       Send Destroy of hoParam2
80025>>>>>>>>>                                   End
80025>>>>>>>>>>
80025>>>>>>>>>                               End
80025>>>>>>>>>>
80025>>>>>>>>>                           End
80025>>>>>>>>>>
80025>>>>>>>>>                           Send destroy of hoParam
80026>>>>>>>>>                       End
80026>>>>>>>>>>
80026>>>>>>>>>                   End
80026>>>>>>>>>>
80026>>>>>>>>>                   Set phoReturnBody to 0
80027>>>>>>>>>                   Send destroy of hoBody
80028>>>>>>>>>                End
80028>>>>>>>>>>
80028>>>>>>>>>            End
80028>>>>>>>>>>
80028>>>>>>>>>            Send destroy of hoRoot
80029>>>>>>>>>        End
80029>>>>>>>>>>
80029>>>>>>>>>        Set pspReturnParameters to ReturnParameters
80030>>>>>>>>>        Function_Return eStatus
80031>>>>>>>>>    End_Function
80032>>>>>>>>>
80032>>>>>>>>>    Function HandleReturnParameter tSoapParamDef SoapParamDef Handle ByRef hoParam2 Integer ByRef iError Returns tValueTreeEx
80034>>>>>>>>>        tValueTreeEx ValueTree
80034>>>>>>>>>        tValueTreeEx ValueTree
80034>>>>>>>>>        Boolean bArray
80034>>>>>>>>>        Boolean bKeepGoing
80034>>>>>>>>>        Integer i
80034>>>>>>>>>        Integer eSoapStyle 
80034>>>>>>>>>        Boolean bResponseBare bValidateResponse
80034>>>>>>>>>        Get pbResponseBare to bResponseBare
80035>>>>>>>>>        Get pbValidateResponse to bValidateResponse
80036>>>>>>>>>                          
80036>>>>>>>>>    
80036>>>>>>>>>        Move (SoapParamDef.iMax=C_UnBounded or SoapParamDef.iMax>1) to bArray
80037>>>>>>>>>    
80037>>>>>>>>>        If (bArray and bResponseBare) Begin
80039>>>>>>>>>            Error DFERR_PROGRAM ("Assert: return array is bare array. no no")                        
80040>>>>>>>>>>
80040>>>>>>>>>        End
80040>>>>>>>>>>
80040>>>>>>>>>    
80040>>>>>>>>>        If (bArray and eSoapStyle=ssRPC) Begin
80042>>>>>>>>>            Error DFERR_PROGRAM ("Assert: we don't support RPC array return params")                        
80043>>>>>>>>>>
80043>>>>>>>>>        End
80043>>>>>>>>>>
80043>>>>>>>>>            
80043>>>>>>>>>        If hoParam2 Begin
80045>>>>>>>>>           If (not(barray)) Begin    
80047>>>>>>>>>            
80047>>>>>>>>>               If (eSoapStyle=ssRPC or not(bValidateResponse) or ;                     IsElementNS(hoParam2,SoapParamDef.sNamespace,SoapParamDef.sName)) Begin
80049>>>>>>>>>                   // if any or xmlelement, we handle this with a special function.
80049>>>>>>>>>                   If (SoapParamDef.eType=xsAnyType or SoapParamDef.eType=xsXmlElement) Begin
80051>>>>>>>>>                      Get XmlHandleToValueTree SoapParamDef hoParam2 to ValueTree
80052>>>>>>>>>                   End
80052>>>>>>>>>>
80052>>>>>>>>>                   Else Begin
80053>>>>>>>>>                      // convert XML data to Value Tree data
80053>>>>>>>>>                      Get XmlToValueTree SoapParamDef hoParam2 (&iError) to ValueTree
80054>>>>>>>>>                   End
80054>>>>>>>>>>
80054>>>>>>>>>                   Get NextNonCommentNode hoParam2 to hoParam2
80055>>>>>>>>>               End
80055>>>>>>>>>>
80055>>>>>>>>>               // if the param has the wrong name and it is a minOccurs=0, we assume we are skipping the param and the next will be ok
80055>>>>>>>>>               Else If (SoapParamDef.iMin<>0) Begin
80058>>>>>>>>>                   Move wssInvalidSoap to iError
80059>>>>>>>>>               End
80059>>>>>>>>>>
80059>>>>>>>>>               Else Begin
80060>>>>>>>>>                   // a iMin=0 with no items. We may want to mark this as null
80060>>>>>>>>>                   Get CreateNullValueTree SoapParamDef to ValueTree
80061>>>>>>>>>               End
80061>>>>>>>>>>
80061>>>>>>>>>           End
80061>>>>>>>>>>
80061>>>>>>>>>           Else Begin
80062>>>>>>>>>               Move True to bKeepGoing
80063>>>>>>>>>               Move 0 to iError
80064>>>>>>>>>               Move 0 to i
80065>>>>>>>>>                   
80065>>>>>>>>>               While (hoParam2 and bKeepGoing)
80069>>>>>>>>>                   
80069>>>>>>>>>                   Move False to bKeepGoing 
80070>>>>>>>>>                   
80070>>>>>>>>>                   If (IsElementNS(hoParam2,SoapParamDef.sNamespace,SoapParamDef.sName)) Begin
80072>>>>>>>>>                       Move True to bKeepGoing
80073>>>>>>>>>                       // if any or xmlelement, we handle this with a special function.
80073>>>>>>>>>                       If (SoapParamDef.eType=xsAnyType or SoapParamDef.eType=xsXmlElement) Begin
80075>>>>>>>>>                          Get XmlHandleToValueTree SoapParamDef hoParam2 to ValueTree.children[i]
80076>>>>>>>>>                       End
80076>>>>>>>>>>
80076>>>>>>>>>                       Else Begin
80077>>>>>>>>>                          // convert XML data to Value Tree data
80077>>>>>>>>>                          Get XmlToValueTree SoapParamDef hoParam2 (&iError) to ValueTree.children[i]
80078>>>>>>>>>                       End
80078>>>>>>>>>>
80078>>>>>>>>>                       If (iError=0) Begin
80080>>>>>>>>>                           Increment i
80081>>>>>>>>>                       End
80081>>>>>>>>>>
80081>>>>>>>>>                       Get NextNonCommentNode hoParam2 to hoParam2
80082>>>>>>>>>                   End
80082>>>>>>>>>>
80082>>>>>>>>>               End
80083>>>>>>>>>>
80083>>>>>>>>>               
80083>>>>>>>>>               // if the param has the wrong name and it is a minOccurs=0, we assume we are skipping the param and the next will be ok
80083>>>>>>>>>               If (iError=0 and i=0) Begin
80085>>>>>>>>>                  If (SoapParamDef.iMin<>0) Begin
80087>>>>>>>>>                      Move wssInvalidSoap to iError
80088>>>>>>>>>                  End
80088>>>>>>>>>>
80088>>>>>>>>>                  Else Begin
80089>>>>>>>>>                      // a iMin=0 with no items. We may want to mark this as null
80089>>>>>>>>>                      Get CreateNullValueTree SoapParamDef to ValueTree
80090>>>>>>>>>                  End
80090>>>>>>>>>>
80090>>>>>>>>>               End
80090>>>>>>>>>>
80090>>>>>>>>>           End
80090>>>>>>>>>>
80090>>>>>>>>>       End
80090>>>>>>>>>>
80090>>>>>>>>>       // if no param it is possible it is a minOccurs=0, if so, skip the param. If not, this is anerror
80090>>>>>>>>>       Else If (SoapParamDef.iMin<>0) Begin
80093>>>>>>>>>           Move wssInvalidSoap to iError
80094>>>>>>>>>       End
80094>>>>>>>>>>
80094>>>>>>>>>       Else Begin
80095>>>>>>>>>           // a iMin=0 with no items. We may want to mark this as null
80095>>>>>>>>>           Get CreateNullValueTree SoapParamDef to ValueTree
80096>>>>>>>>>       End
80096>>>>>>>>>>
80096>>>>>>>>>       Function_Return ValueTree
80097>>>>>>>>>        
80097>>>>>>>>>    End_Function
80098>>>>>>>>>
80098>>>>>>>>>
80098>>>>>>>>>    
80098>>>>>>>>>//    Function SoapReturnParameter tSoapParamDef SoapParamDef Handle hoParam2 Integer ByRef iError Returns tValueTreeEx
80098>>>>>>>>>//       tValueTreeEx ValueTree 
80098>>>>>>>>>//       Integer eSoapStyle
80098>>>>>>>>>//       Boolean bValidateResponse 
80098>>>>>>>>>//       Get peSoapStyle to eSoapStyle
80098>>>>>>>>>//       Get pbValidateResponse to bValidateResponse
80098>>>>>>>>>//       If (hoParam2 and ;
80098>>>>>>>>>//             (eSoapStyle=ssRPC or not(bValidateResponse) or ;
80098>>>>>>>>>//                IsElementNS(hoParam2,SoapParamDef.sNamespace,SoapParamDef.sName))) Begin
80098>>>>>>>>>//
80098>>>>>>>>>//           // if any or xmlelement, we handle this with a special function.
80098>>>>>>>>>//           If (SoapParamDef.eType=xsAnyType or SoapParamDef.eType=xsXmlElement) Begin
80098>>>>>>>>>//              Get XmlHandleToValueTree SoapParamDef hoParam2 to ValueTree
80098>>>>>>>>>//           End
80098>>>>>>>>>//           Else Begin
80098>>>>>>>>>//              // convert XML data to Value Tree data
80098>>>>>>>>>//              Get XmlToValueTree SoapParamDef hoParam2 (&iError) to ValueTree
80098>>>>>>>>>//           End
80098>>>>>>>>>//
80098>>>>>>>>>//       End
80098>>>>>>>>>//       // if the param has the wrong name and it is a minOccurs=0, we assume we are skipping the param and the next will be ok
80098>>>>>>>>>//       Else If (SoapParamDef.iMin<>0) Begin
80098>>>>>>>>>//           Move wssInvalidSoap to iError
80098>>>>>>>>>//       End
80098>>>>>>>>>//       Else Begin
80098>>>>>>>>>//           // a iMin=0 with no items. We may want to mark this as null
80098>>>>>>>>>//           Get CreateNullValueTree SoapParamDef to ValueTree
80098>>>>>>>>>//       End
80098>>>>>>>>>//       Function_Return ValueTree
80098>>>>>>>>>//    End_Function
80098>>>>>>>>>    
80098>>>>>>>>>
80098>>>>>>>>>    // handle a soap fault, pass the XML Fault node. Set Fault strings etc and Return appropriate Status
80098>>>>>>>>>    Function HandleSoapFault Handle hoParam Returns Integer
80100>>>>>>>>>        Handle hoParam2
80100>>>>>>>>>        Get FirstNonCommentChild hoParam to hoParam2 // should be faultcode
80101>>>>>>>>>        If hoParam2 Begin
80103>>>>>>>>>            If (IsElementNS(hoParam2,"","faultcode")) Begin
80105>>>>>>>>>                Set psFaultCode to (psText(hoParam2))
80106>>>>>>>>>            End
80106>>>>>>>>>>
80106>>>>>>>>>            Get NextNonCommentNode hoParam2 to hoParam2 // should be faultstring
80107>>>>>>>>>            If hoParam2 Begin
80109>>>>>>>>>                If (IsElementNS(hoParam2,"","faultstring")) Begin
80111>>>>>>>>>                    Set psFaultString to (psText(hoParam2))
80112>>>>>>>>>                End
80112>>>>>>>>>>
80112>>>>>>>>>                Send destroy of hoParam2
80113>>>>>>>>>            End
80113>>>>>>>>>>
80113>>>>>>>>>        End
80113>>>>>>>>>>
80113>>>>>>>>>        Function_Return wssSoapFault
80114>>>>>>>>>    End_Function
80115>>>>>>>>>
80115>>>>>>>>>    Function CreateSoapRequest Returns Handle
80117>>>>>>>>>        String sSoapNs sSoapNSPre
80117>>>>>>>>>        String sPiInf sXMLVersion sXmlEncoding
80117>>>>>>>>>        Handle hoXml hoEnv hoPI
80117>>>>>>>>>        Boolean bOK
80117>>>>>>>>>
80117>>>>>>>>>        Get psSoapEnvNsUri to sSoapNS
80118>>>>>>>>>        Get psSoapEnvNsPre to sSoapNSPre
80119>>>>>>>>>        Get psXmlVersion   to sXmlVersion
80120>>>>>>>>>        Get psXmlEncoding  to sXmlEncoding
80121>>>>>>>>>
80121>>>>>>>>>        Get Create U_cXMLDOMDocument to hoXML
80122>>>>>>>>>
80122>>>>>>>>>        // Create the SOAP Envelope as the document root:
80122>>>>>>>>>        Get CreateDocumentElementNS of hoXML sSoapNS (sSoapNSPre + ":Envelope") to hoEnv
80123>>>>>>>>>
80123>>>>>>>>>        // Add the XML processing instruction *ahead* of it:
80123>>>>>>>>>        Move ("version='" - sXmlVersion - "'" * "encoding='" - sXmlEncoding - "'") to sPiInf
80124>>>>>>>>>        Get CreateChildProcessingInstruction of hoEnv "xml" sPiInf to hoPI
80125>>>>>>>>>        Get InsertBeforeNode of hoXML hoPI hoEnv to hoPI
80126>>>>>>>>>        Send Destroy of hoPI
80127>>>>>>>>>        //
80127>>>>>>>>>        Get CreateSoapHeader hoEnv to bOk
80128>>>>>>>>>        If bOk Begin
80130>>>>>>>>>            Get CreateSoapBody hoEnv to bOk
80131>>>>>>>>>        End
80131>>>>>>>>>>
80131>>>>>>>>>        Send destroy of hoEnv
80132>>>>>>>>>        If not bOk Begin
80134>>>>>>>>>            Send destroy of hoXML
80135>>>>>>>>>            Move 0 to hoXML
80136>>>>>>>>>        End
80136>>>>>>>>>>
80136>>>>>>>>>        Function_Return hoXML
80137>>>>>>>>>    End_Function
80138>>>>>>>>>
80138>>>>>>>>>    Function CreateSoapHeader Integer hoEnv Returns Boolean
80140>>>>>>>>>        Handle hoHeader hoNew hoRoot hoNew1
80140>>>>>>>>>        Boolean bOk
80140>>>>>>>>>        Move True to bOk
80141>>>>>>>>>        Get phoSoapHeaderRequest to hoHeader
80142>>>>>>>>>        // we allow either no header or any empty document (no root), which is less likely
80142>>>>>>>>>        If hoHeader Begin
80144>>>>>>>>>            Get DocumentElement of hoHeader to hoRoot
80145>>>>>>>>>            If hoRoot Begin
80147>>>>>>>>>                Get CloneNode of hoRoot True to hoNew
80148>>>>>>>>>                Move (hoNew<>0) to bOk // if hoNew=0, the clone failed.
80149>>>>>>>>>                If bOk Begin
80151>>>>>>>>>                    Get AppendNode of hoEnv hoNew to hoNew1
80152>>>>>>>>>                    Move (hoNew1<>0) to bOk // if hoNew1=0, the append failed.
80153>>>>>>>>>                    Send Destroy of hoNew
80154>>>>>>>>>                End
80154>>>>>>>>>>
80154>>>>>>>>>                Send Destroy of hoRoot
80155>>>>>>>>>            End
80155>>>>>>>>>>
80155>>>>>>>>>        End
80155>>>>>>>>>>
80155>>>>>>>>>        Function_Return bOk
80156>>>>>>>>>    End_Function
80157>>>>>>>>>    
80157>>>>>>>>>    Function CreateSoapBody Integer hoEnv Returns Boolean
80159>>>>>>>>>        Handle hoBody
80159>>>>>>>>>        String sSoapEnvNsURI sSoapEnvNsPre sSoapEncodingNsUri sSoapEncodingNsPre
80159>>>>>>>>>        Integer eSoapEncoding
80159>>>>>>>>>        Boolean bOk
80159>>>>>>>>>        Get peSoapEncoding to eSoapEncoding
80160>>>>>>>>>        Get psSoapEnvNsURI to sSoapEnvNsURI
80161>>>>>>>>>        Get psSoapEnvNsPre to sSoapEnvNsPre
80162>>>>>>>>>        Get AddElementNS of hoEnv sSoapEnvNsURI (sSoapEnvNsPRE - ":Body") "" to hoBody
80163>>>>>>>>>        If not hoBody Function_Return 0
80166>>>>>>>>>        // if encoding, must add soap encoding style attribute
80166>>>>>>>>>        If (eSoapEncoding=seEncoded) Begin
80168>>>>>>>>>            Get psSoapEncodingNsUri to sSoapEncodingNsUri
80169>>>>>>>>>            Get psSoapEncodingNsPre to sSoapEncodingNsPre
80170>>>>>>>>>            // add encodingStyle attribute
80170>>>>>>>>>            Send AddAttributeNS of hoEnv sSoapEnvNsURI (sSoapEnvNsPRE - ":encodingStyle") sSoapEncodingNsUri
80171>>>>>>>>>            // define attribute
80171>>>>>>>>>            Send AddAttribute   of hoEnv ("xmlns:"+sSoapEncodingNsPre) sSoapEncodingNsUri
80172>>>>>>>>>        End
80172>>>>>>>>>>
80172>>>>>>>>>        Get CreateSoapMethod hoBody to bOk
80173>>>>>>>>>        Send Destroy of hoBody
80174>>>>>>>>>        Function_Return boK
80175>>>>>>>>>   End_Function
80176>>>>>>>>>
80176>>>>>>>>>    Function CreateSoapMethod Integer hoBody Returns Boolean
80178>>>>>>>>>        Handle  hoMethod
80178>>>>>>>>>        String  sMethod sNameSpace sPre
80178>>>>>>>>>        Integer eSoapEncoding
80178>>>>>>>>>        Boolean bOk bRequestBare
80178>>>>>>>>>        Get peSoapEncoding  to eSoapEncoding
80179>>>>>>>>>        Get psMethodRequest to sMethod
80180>>>>>>>>>        Get psRequestNSURI  to sNameSpace
80181>>>>>>>>>        Get pbRequestBare to bRequestBare
80182>>>>>>>>>        // Soap-encoded Methods should be qualified. However, if there is no namespace we cannot force it.
80182>>>>>>>>>        If (eSoapEncoding=seEncoded and sNameSpace<>"") Begin
80184>>>>>>>>>            Get psMethodsNsPre to sPre
80185>>>>>>>>>            Move (sPre + ":" + sMethod) to sMethod
80186>>>>>>>>>        End
80186>>>>>>>>>>
80186>>>>>>>>>        If (bRequestBare) Begin
80188>>>>>>>>>            // if bare, we don't create the method wrapper. We add the parameters directly
80188>>>>>>>>>            // under the body.
80188>>>>>>>>>            Get CreateParameters hoBody to bOk
80189>>>>>>>>>        End
80189>>>>>>>>>>
80189>>>>>>>>>        Else Begin
80190>>>>>>>>>            // when wrapped (normal) we create a wrapper element and add the params under that
80190>>>>>>>>>            Get AddElementNS of hoBody sNameSpace sMethod "" to hoMethod
80191>>>>>>>>>            If (hoMethod=0) Function_Return 0
80194>>>>>>>>>            Get CreateParameters hoMethod to bOk
80195>>>>>>>>>            Send destroy of hoMethod
80196>>>>>>>>>        End
80196>>>>>>>>>>
80196>>>>>>>>>        Function_Return bOk
80197>>>>>>>>>    End_Function
80198>>>>>>>>>
80198>>>>>>>>>    Function CreateParameters Integer hoMethod Returns Boolean
80200>>>>>>>>>        Integer iParam iParams
80200>>>>>>>>>        Boolean bOk
80200>>>>>>>>>        tSoapParameter[] SoapParameters
80200>>>>>>>>>        tSoapParameter[] SoapParameters
80201>>>>>>>>>        Get pspParameters to SoapParameters
80202>>>>>>>>>        Move (SizeOfArray(SoapParameters)) to iParams
80203>>>>>>>>>
80203>>>>>>>>>        For iParam from 0 to (iParams-1)
80209>>>>>>>>>>
80209>>>>>>>>>            Get CreateParameter SoapParameters[iParam].SoapParamDef SoapParameters[iParam].ValueTree hoMethod to bOk
80210>>>>>>>>>        Loop
80211>>>>>>>>>>
80211>>>>>>>>>        Function_Return True
80212>>>>>>>>>    End_Function
80213>>>>>>>>>    
80213>>>>>>>>>    // Convert ValueTree to XML node or nodes as a child of hoParam
80213>>>>>>>>>    // If the parameter is an array this can Add multiple nodes
80213>>>>>>>>>    Function CreateParameter tSoapParamDef SoapParamDef tValueTreeEx ValueTree Handle hoParam Returns Boolean
80215>>>>>>>>>        Boolean bOk bArray
80215>>>>>>>>>        Integer i
80215>>>>>>>>>
80215>>>>>>>>>        Move (SoapParamDef.iMax=C_UnBounded or SoapParamDef.iMax>1) to bArray
80216>>>>>>>>>        
80216>>>>>>>>>        // if xsAnyType or xsXmlElement the entire param is treated as single piece of xml
80216>>>>>>>>>        If (SoapParamDef.eType=xsAnyType or SoapParamDef.eType=xsXmlElement) Begin
80218>>>>>>>>>            If (bArray) Begin
80220>>>>>>>>>               For i from 0 to (SizeOfArray( ValueTree.children )-1)
80226>>>>>>>>>>
80226>>>>>>>>>                   Get ValueTreeXmlParamToXml SoapParamDef ValueTree.children[i] hoParam to bOk
80227>>>>>>>>>               Loop 
80228>>>>>>>>>>
80228>>>>>>>>>            End
80228>>>>>>>>>>
80228>>>>>>>>>            Else Begin
80229>>>>>>>>>                Get ValueTreeXmlParamToXml SoapParamDef ValueTree hoParam to bOk
80230>>>>>>>>>            End
80230>>>>>>>>>>
80230>>>>>>>>>        End
80230>>>>>>>>>>
80230>>>>>>>>>        // either a known type/struct or serialized XML
80230>>>>>>>>>        Else Begin
80231>>>>>>>>>            If (bArray) Begin
80233>>>>>>>>>               For i from 0 to (SizeOfArray( ValueTree.children )-1)
80239>>>>>>>>>>
80239>>>>>>>>>                    Get ValueTreeToXml SoapParamDef ValueTree.children[i] hoParam to bOk
80240>>>>>>>>>               Loop 
80241>>>>>>>>>>
80241>>>>>>>>>            End
80241>>>>>>>>>>
80241>>>>>>>>>            Else Begin
80242>>>>>>>>>                Get ValueTreeToXml SoapParamDef ValueTree hoParam to bOk
80243>>>>>>>>>            End
80243>>>>>>>>>>
80243>>>>>>>>>        End
80243>>>>>>>>>>
80243>>>>>>>>>        Function_Return bOk
80244>>>>>>>>>    End_Function
80245>>>>>>>>>
80245>>>>>>>>>    Function TransferErrorFaultDescription Returns String
80247>>>>>>>>>        String  sError sFaultCode sFaultString
80247>>>>>>>>>        Move C_$SoapFault to sError
80248>>>>>>>>>        Get psFaultCode   to sFaultCode
80249>>>>>>>>>        Get psFaultstring to sFaultString
80250>>>>>>>>>        Move (sError + "\n" + C_$SoapFaultCode * sFaultCode + ;                       "\n" + C_$SoapFaultString * sFaultString) to sError
80251>>>>>>>>>        Function_Return sError               
80252>>>>>>>>>    End_Function
80253>>>>>>>>>
80253>>>>>>>>>
80253>>>>>>>>>    Function TransferErrorDescription Returns String
80255>>>>>>>>>        String  sError sText sType
80255>>>>>>>>>        Integer eXmlTransferStatus
80255>>>>>>>>>        Handle  hoHttp
80255>>>>>>>>>        Get peTransferStatus to eXmlTransferStatus
80256>>>>>>>>>        Case Begin
80256>>>>>>>>>            Case (eXmlTransferStatus=wssOk)                  Move "" to sError
80259>>>>>>>>>            Case (eXmlTransferStatus=wssHttpRequestFailed)   Move C_$HttpRequestFailed          to sError
80263>>>>>>>>>            Case (eXmlTransferStatus=wssBadRequest)          Move C_$BadOrMissingDataSent       to sError
80267>>>>>>>>>            Case (eXmlTransferStatus=wssNoData)              Move C_$NoDataWasReceived          to sError
80271>>>>>>>>>            Case (eXmlTransferStatus=wssNotXml)              Move C_$ReceivedDataNotInXMLFormat to sError
80275>>>>>>>>>            Case (eXmlTransferStatus=wssNotSoap)             Move C_$XmlDataNotInSoapFormat     to sError
80279>>>>>>>>>            Case (eXmlTransferStatus=wssInvalidSoap)         Move C_$SoapDataNotAsWSDL          to sError
80283>>>>>>>>>            Case (eXmlTransferStatus=wssInvalidDataForType)  Move C_$ReceivedDataTypeIsBad      to sError
80287>>>>>>>>>            Case (eXmlTransferStatus=wssCouldNotResolveHRef) Move C_$CouldNotFindHRefedData     to sError
80291>>>>>>>>>            Case (eXmlTransferStatus=wssInvalidContentType) Begin
80294>>>>>>>>>                Get phoHttp to hoHttp
80295>>>>>>>>>                // if the content is html, let's show what we got in the error
80295>>>>>>>>>                Get psContentTypeReceived of hoHttp to sType
80296>>>>>>>>>                Move (SFormat(C_$InvalidContentTypeReceived,sType))  to sError
80297>>>>>>>>>                If (pos("html",Lowercase(sType))) Begin
80299>>>>>>>>>                     Get paDataReceived of hoHttp to sText
80300>>>>>>>>>                     Move (sError + "\n" + sText) to sError
80301>>>>>>>>>                End
80301>>>>>>>>>>
80301>>>>>>>>>            End
80301>>>>>>>>>>
80301>>>>>>>>>            Case (eXmlTransferStatus=wssSoapFault) Begin
80304>>>>>>>>>                Get TransferErrorFaultDescription to sError
80305>>>>>>>>>            End
80305>>>>>>>>>>
80305>>>>>>>>>            Case Else Move C_$ReceivedDataIsBad to sError
80307>>>>>>>>>        Case End
80307>>>>>>>>>        Function_Return sError
80308>>>>>>>>>    End_Function
80309>>>>>>>>>
80309>>>>>>>>>    Procedure LastError
80311>>>>>>>>>        Integer eTransferStatus
80311>>>>>>>>>        String sError
80311>>>>>>>>>        Boolean bSuppressLastError
80311>>>>>>>>>        Get pbSuppressLastError to bSuppressLastError
80312>>>>>>>>>        If not (bSuppressLastError) Begin
80314>>>>>>>>>            Get peTransferStatus to eTransferStatus
80315>>>>>>>>>            If (eTransferStatus<>wssOk) Begin
80317>>>>>>>>>                Get TransferErrorDescription to sError
80318>>>>>>>>>                // we differentiate between a soap-fault and a general error.
80318>>>>>>>>>                Error (If(eTransferStatus=wssSoapFault, DFERR_CLIENT_SOAP_FAULT, DFERR_CLIENT_SOAP_TRANSFER)) sError
80319>>>>>>>>>>
80319>>>>>>>>>            End
80319>>>>>>>>>>
80319>>>>>>>>>        End
80319>>>>>>>>>>
80319>>>>>>>>>    End_Procedure
80320>>>>>>>>>
80320>>>>>>>>>    Procedure OnSoapReceived
80322>>>>>>>>>        Handle hoSoapClientHelper
80322>>>>>>>>>        Get phoSoapClientHelper to hoSoapClientHelper
80323>>>>>>>>>        If hoSoapClientHelper Begin
80325>>>>>>>>>            Send OnSoapReceived of hoSoapClientHelper Self
80326>>>>>>>>>        End
80326>>>>>>>>>>
80326>>>>>>>>>    End_Procedure
80327>>>>>>>>>
80327>>>>>>>>>    // special case when parameter is xsAnyType or xsXmlElement. Only occurs at outer paramter level.
80327>>>>>>>>>    Function ValueTreeXmlParamToXml tSoapParamDef SoapParamDef tValueTreeEx ValueTree Handle hoParam Returns Boolean
80329>>>>>>>>>
80329>>>>>>>>>        Handle hoNode hoDataRoot hoData hoNode1
80329>>>>>>>>>        Boolean bRpc
80329>>>>>>>>>
80329>>>>>>>>>        Move (peSoapStyle(Self)=ssRpc) to bRpc
80330>>>>>>>>>
80330>>>>>>>>>        // if xmlElement simply add the param to an xml document wrapper
80330>>>>>>>>>        Move ValueTree.sValue to hoData // data is pointer to XML Node
80331>>>>>>>>>        // take the xml document we have and add it to the param
80331>>>>>>>>>        Get DocumentElement of hoData to hoDataRoot
80332>>>>>>>>>        If (SoapParamDef.eType=xsAnyType) Begin
80334>>>>>>>>>            // if any, pass as entire param plus wrapper. The wrapper MUST be correct.
80334>>>>>>>>>            Get CloneNode  of hoDataRoot True to hoNode
80335>>>>>>>>>            Get AppendNode of hoParam hoNode to hoNode
80336>>>>>>>>>        End
80336>>>>>>>>>>
80336>>>>>>>>>        Else Begin
80337>>>>>>>>>            Get AddElementNS of hoParam (If(bRpc,"",SoapParamDef.sNamespace)) SoapParamDef.sName '' to hoNode
80338>>>>>>>>>            // if xmlElement, pass the entire document as a child of the wrapper
80338>>>>>>>>>            Get CloneNode of hoDataRoot True to hoNode1
80339>>>>>>>>>            Get AppendNode of hoNode hoNode1 to hoNode1
80340>>>>>>>>>            Send Destroy of hoNode1
80341>>>>>>>>>        End
80341>>>>>>>>>>
80341>>>>>>>>>        Send destroy of hoDataRoot
80342>>>>>>>>>        Send destroy of hoNode
80343>>>>>>>>>        Function_Return True
80344>>>>>>>>>    End_Function
80345>>>>>>>>>    
80345>>>>>>>>>    // Returns the simple data value from the value tree as a string. This can be used with both real simple types
80345>>>>>>>>>    // and nullable simple types (which are really structs). SoapParamDef determines what type of simple value this is.
80345>>>>>>>>>    Function ValueTreeToSimpleValue tSoapParamDef SoapParamDef tValueTreeEx ValueTree Returns String
80347>>>>>>>>>        String sValue
80347>>>>>>>>>        
80347>>>>>>>>>        If ( (SoapParamDef.hoStruct<>0 and not(pbSimpleContent(SoapParamDef.hoStruct))) or (SoapParamDef.bSimpleNullable and SizeOfArray(ValueTree.children)<>2) or (not(SoapParamDef.bSimpleNullable) and SizeOfArray(ValueTree.children)<>0)) Begin
80349>>>>>>>>>            Error DFERR_PROGRAM "Assert: ValueTreeToSimpleValue has invalid ValueTree for type"           
80350>>>>>>>>>>
80350>>>>>>>>>        End
80350>>>>>>>>>>
80350>>>>>>>>>        
80350>>>>>>>>>        // this is simple data-create an element.
80350>>>>>>>>>        If (SoapParamDef.bSimpleNullable) Begin
80352>>>>>>>>>            Move ValueTree.children[C_SimpleDataMember].sValue to sValue
80353>>>>>>>>>        End
80353>>>>>>>>>>
80353>>>>>>>>>        Else Begin
80354>>>>>>>>>            Move ValueTree.sValue to sValue
80355>>>>>>>>>        End
80355>>>>>>>>>>
80355>>>>>>>>>        Function_Return sValue
80356>>>>>>>>>    End_Function
80357>>>>>>>>>    
80357>>>>>>>>>    // determines if simple nullable datatype in ValueTree instance is null
80357>>>>>>>>>    Function ValueTreeSimpleIsNull tSoapParamDef SoapParamDef tValueTreeEx ValueTree Returns Boolean
80359>>>>>>>>>        Boolean bNull
80359>>>>>>>>>        If ( SoapParamDef.hoStruct<>0 or not(SoapParamDef.bSimpleNullable) or SizeOfArray(ValueTree.children)<>2) Begin
80361>>>>>>>>>            Error DFERR_PROGRAM "Assert: ValueTreeSimpleIsNull has invalid ValueTree for type"           
80362>>>>>>>>>>
80362>>>>>>>>>        End
80362>>>>>>>>>>
80362>>>>>>>>>
80362>>>>>>>>>        Move (ValueTree.children[C_SimpleNullMember].sValue="true") to bNull
80363>>>>>>>>>        
80363>>>>>>>>>        Function_Return bNull
80364>>>>>>>>>    End_Function
80365>>>>>>>>>    
80365>>>>>>>>>    Function BadNullTest tSoapParamDef SoapParamDef tValueTreeEx ValueTree Returns Boolean
80367>>>>>>>>>        Integer iNullMember
80367>>>>>>>>>        Boolean bNull
80367>>>>>>>>>        If (SoapParamDef.hoStruct) Begin
80369>>>>>>>>>            Get piNullMember of SoapParamDef.hoStruct to iNullMember
80370>>>>>>>>>            If ( iNullMember>=0 and not(SoapParamDef.iMin=C_Nillable or SoapParamDef.iMin=0)) Begin
80372>>>>>>>>>                Move (ValueTree.children[iNullMember].sValue="true") to bNull
80373>>>>>>>>>                If bNull Begin
80375>>>>>>>>>                    Error DFERR_PROGRAM ("Struct member cannot be a null member for " + SoapParamDef.sName)
80376>>>>>>>>>>
80376>>>>>>>>>                    Function_Return True
80377>>>>>>>>>                End
80377>>>>>>>>>>
80377>>>>>>>>>            End
80377>>>>>>>>>>
80377>>>>>>>>>        End
80377>>>>>>>>>>
80377>>>>>>>>>        Else Begin
80378>>>>>>>>>            If (SoapParamDef.bSimpleNullable and not(SoapParamDef.iMin=C_Nillable or SoapParamDef.iMin=0)) Begin
80380>>>>>>>>>                Get ValueTreeSimpleIsNull SoapParamDef ValueTree to bNull
80381>>>>>>>>>                If bNull Begin
80383>>>>>>>>>                    Error DFERR_PROGRAM ("Simple variable cannot be a null for " + SoapParamDef.sName)
80384>>>>>>>>>>
80384>>>>>>>>>                    Function_Return True
80385>>>>>>>>>                End
80385>>>>>>>>>>
80385>>>>>>>>>            End
80385>>>>>>>>>>
80385>>>>>>>>>        End
80385>>>>>>>>>>
80385>>>>>>>>>    End_Function
80386>>>>>>>>>    
80386>>>>>>>>>    // Value Tree ---> XML
80386>>>>>>>>>    //
80386>>>>>>>>>    // Create XML based on contents of ValueTree data add as child node of passed hoParam
80386>>>>>>>>>    // (this doesn't support SoapEncArray yet
80386>>>>>>>>>    //
80386>>>>>>>>>    Function ValueTreeToXml tSoapParamDef SoapParamDef tValueTreeEx ValueTree Handle hoParam Returns Boolean
80388>>>>>>>>>
80388>>>>>>>>>        Handle   hoNode hoChildNode hoArrayChildNode
80388>>>>>>>>>        Integer  iChildren i iItems j eArrayType iDimensions iChoice iValueNum
80388>>>>>>>>>        Boolean  bOk bRpc bSimpleContent bChoice
80388>>>>>>>>>        String   sSchemaNSPre sSchemaNSURI sType sDims
80388>>>>>>>>>        Boolean bSkipMinZero
80388>>>>>>>>>        DateTime dtDatetimeValue
80388>>>>>>>>>        tSoapParamDef   ChildSoapParamDef
80388>>>>>>>>>        tSoapParamDef   ChildSoapParamDef
80388>>>>>>>>>        tSoapParamDef[] SoapParamDefs
80388>>>>>>>>>        tSoapParamDef[] SoapParamDefs
80389>>>>>>>>>        tValueTreeEx ChildValueTree ArrayChildValueTree
80389>>>>>>>>>        tValueTreeEx ChildValueTree ArrayChildValueTree
80389>>>>>>>>>        String sSimpleValue
80389>>>>>>>>>        Integer iNullMember
80389>>>>>>>>>        Boolean bNull
80389>>>>>>>>>        Integer iArrayItem iArrayItems
80389>>>>>>>>>        Boolean  bChoiceSequenceStruct
80389>>>>>>>>>        tSoapParamDef[] ChildSoapParamDefs
80389>>>>>>>>>        tSoapParamDef[] ChildSoapParamDefs
80390>>>>>>>>>        
80390>>>>>>>>>        // AnyType or XmlElement should never be passed as a member, this is a programming error
80390>>>>>>>>>        If (SoapParamDef.eType=xsAnyType or SoapParamDef.eType=xsXmlElement) Begin
80392>>>>>>>>>            Error DFERR_PROGRAM ("Assert: ValueTreeToXml passed xsAnyType or xsXmlElement member for" * SoapParamDef.sName) 
80393>>>>>>>>>>
80393>>>>>>>>>            Function_Return False
80394>>>>>>>>>        End
80394>>>>>>>>>>
80394>>>>>>>>>        
80394>>>>>>>>>        // AnyTypeStr or XmlElementStr are seralized XML strings and can be passed as a member, handle
80394>>>>>>>>>        // also check for xsbase64Binary
80394>>>>>>>>>        If (SoapParamDef.eType=xsAnyTypeStr or SoapParamDef.eType=xsXmlElementStr or SoapParamDef.eType=xsBase64Binary) Begin
80396>>>>>>>>>            Get ValueTreeXmlStrToXml SoapParamDef ValueTree hoParam to bOk
80397>>>>>>>>>            Function_Return bOk
80398>>>>>>>>>        End
80398>>>>>>>>>>
80398>>>>>>>>>        
80398>>>>>>>>>        Move (peSoapStyle(Self)=ssRpc) to bRpc
80399>>>>>>>>>
80399>>>>>>>>>        // case of a regular datatype or a struct/array
80399>>>>>>>>>
80399>>>>>>>>>        // if an attribute, add as a child of the current node. There can be no other children under this
80399>>>>>>>>>        If (SoapParamDef.bAttribute) Begin
80401>>>>>>>>>            // note we always add attributes. There is no way to do this optionally but it should not matter
80401>>>>>>>>>            Send AddAttributeNS of hoParam SoapParamDef.sNamespace SoapParamDef.sName ValueTree.sValue
80402>>>>>>>>>            Function_Return True
80403>>>>>>>>>        End
80403>>>>>>>>>>
80403>>>>>>>>>        
80403>>>>>>>>>        If (SoapParamDef.hoStruct) Begin
80405>>>>>>>>>            Get pbChoice of SoapParamDef.hoStruct to bChoice
80406>>>>>>>>>        End
80406>>>>>>>>>>
80406>>>>>>>>>        
80406>>>>>>>>>        If bChoice Begin
80408>>>>>>>>>            
80408>>>>>>>>>             // if a struct with choice, this is special. The valuetree child structure is the value-1 and the following
80408>>>>>>>>>             // members are choices, which are zero based. So if first value is "2" (third enum), the 2+1 item will be choice.
80408>>>>>>>>>             // Note this must be added to the current xml node and not a level in.
80408>>>>>>>>>             //
80408>>>>>>>>>             // so if simplecontent the value tree will be:
80408>>>>>>>>>             //
80408>>>>>>>>>             // ValueTree[x].Children 
80408>>>>>>>>>             //   ValueTree[0].sValue = Value1
80408>>>>>>>>>             //   ValueTree[1].Children              <--- this is the choice node struct
80408>>>>>>>>>             //        ValueTree[0].sValue = eChoice <---first node is the choice offset.
80408>>>>>>>>>             //        ValueTree[1].sValue = sVal1   <---remaining nodes are the choices
80408>>>>>>>>>             //        ValueTree[2].sValue = sVal2
80408>>>>>>>>>             //   ValueTree[2].sValue = Value3
80408>>>>>>>>>             //
80408>>>>>>>>>             // and xml will be:
80408>>>>>>>>>             //
80408>>>>>>>>>             //    <m:FooEle1>Value1<mFooEle1/>
80408>>>>>>>>>             //    <m:FooEle2>Val1<mFooEle2/> <---stuct becomes choice if eChoice was 0
80408>>>>>>>>>             //    <m:FooEle3>Value3<mFooEle3/>
80408>>>>>>>>>
80408>>>>>>>>>             Get pSoapParamDefs of SoapParamDef.hoStruct to SoapParamDefs // get struct object params
80409>>>>>>>>>             Move (SizeofArray(SoapParamDefs)) to iChildren
80410>>>>>>>>>             If (iChildren) Begin
80412>>>>>>>>>                Move ValueTree.Children[0].sValue to iChoice
80413>>>>>>>>>                // if set to none it means that none of the choices are selected, which may or may not
80413>>>>>>>>>                // be allowed at the server. If not, don't do it.
80413>>>>>>>>>                If (iChoice<>C_ChoiceStructNone) Begin
80415>>>>>>>>>                    Increment iChoice
80416>>>>>>>>>                    If (iChoice>0 and iChoice<iChildren) Begin
80418>>>>>>>>>                        
80418>>>>>>>>>                        Move ValueTree.Children[iChoice] to ChildValueTree
80419>>>>>>>>>                        
80419>>>>>>>>>                        // If an array
80419>>>>>>>>>                        If (SoapParamDefs[iChoice].iMax>1 or SoapParamDefs[iChoice].iMax=C_Unbounded) Begin
80421>>>>>>>>>                            // if an array we go in one more level of the value tree and handle all array items for
80421>>>>>>>>>                            // the one choice child SoapParamDef
80421>>>>>>>>>                            Move (SizeOfArray(ChildValueTree.Children)) to iItems
80422>>>>>>>>>                            For j from 0 to (iItems-1)
80428>>>>>>>>>>
80428>>>>>>>>>                                // if array, the valueTree children are the array values
80428>>>>>>>>>                                Get ValueTreeToXml SoapParamDefs[iChoice] ChildValueTree.Children[j] hoParam to bOk
80429>>>>>>>>>                            Loop
80430>>>>>>>>>>
80430>>>>>>>>>                        End
80430>>>>>>>>>>
80430>>>>>>>>>                        // not an array
80430>>>>>>>>>                        Else Begin
80431>>>>>>>>>                            If (SoapParamDefs[iChoice].hoStruct) Begin
80433>>>>>>>>>                                Get pbChoiceSequenceStruct of SoapParamDefs[iChoice].hoStruct to bChoiceSequenceStruct
80434>>>>>>>>>                            End
80434>>>>>>>>>>
80434>>>>>>>>>                            If bChoiceSequenceStruct Begin
80436>>>>>>>>>                                // this is a special and hopefully quite unusual case where the choice item was
80436>>>>>>>>>                                // not an <element> but a <sequence> of <elements>. The XML needs to insert that 
80436>>>>>>>>>                                // whole sequence as the single choice. This is going to be much easier to write
80436>>>>>>>>>                                // then to read back in.
80436>>>>>>>>>                                
80436>>>>>>>>>                                // Get the child soapparamdefs of this pseudo struct and use those.
80436>>>>>>>>>                                // these are the items that comprise each element within the sequence. We
80436>>>>>>>>>                                // are basically just pushing everything in the valuetree in one level.
80436>>>>>>>>>
80436>>>>>>>>>                                Get pSoapParamDefs of SoapParamDefs[iChoice].hoStruct to ChildSoapParamDefs
80437>>>>>>>>>                                Move (SizeOfArray(ChildValueTree.Children)) to iItems
80438>>>>>>>>>                                For j from 0 to (iItems-1)
80444>>>>>>>>>>
80444>>>>>>>>>                                    
80444>>>>>>>>>                                    If (ChildSoapParamDefs[j].iMax>1 or ChildSoapParamDefs[j].iMax=C_Unbounded) Begin
80446>>>>>>>>>                                        // if an array we go in one more level of the value tree and handle all array items for
80446>>>>>>>>>                                        // the one childSoapParamDef
80446>>>>>>>>>                                        // if non declared array-type, we bump in one more level of the value tree
80446>>>>>>>>>                                        Move ChildValueTree.children[j] to ArrayChildValueTree
80447>>>>>>>>>                                        Move (SizeOfArray(ArrayChildValueTree.children)) to iArrayItems
80448>>>>>>>>>                                        For iArrayItem from 0 to (iArrayItems-1)
80454>>>>>>>>>>
80454>>>>>>>>>                                            Get ValueTreeToXml ChildSoapParamDefs[j] ArrayChildValueTree.children[iArrayItem] hoParam to bOk
80455>>>>>>>>>                                        Loop
80456>>>>>>>>>>
80456>>>>>>>>>                                    End
80456>>>>>>>>>>
80456>>>>>>>>>                                    Else Begin
80457>>>>>>>>>                                        // if non array, we just add the element
80457>>>>>>>>>                                        Get ValueTreeToXml ChildSoapParamDefs[j] ChildValueTree.Children[j] hoParam to bOk
80458>>>>>>>>>                                    End
80458>>>>>>>>>>
80458>>>>>>>>>                                Loop
80459>>>>>>>>>>
80459>>>>>>>>>                            End
80459>>>>>>>>>>
80459>>>>>>>>>                            Else Begin
80460>>>>>>>>>                                // this is <choice><element> condition
80460>>>>>>>>>                                Get ValueTreeToXml SoapParamDefs[iChoice] ChildValueTree hoParam to bOk
80461>>>>>>>>>                            End
80461>>>>>>>>>>
80461>>>>>>>>>                            
80461>>>>>>>>>                        End
80461>>>>>>>>>>
80461>>>>>>>>>                    End
80461>>>>>>>>>>
80461>>>>>>>>>                    Else Begin
80462>>>>>>>>>                        // this is most likely a programming error
80462>>>>>>>>>                        Error DFERR_PROGRAM ("Invalid value ("+ String(iChoice-1) + ") for choice member in struct for" * SoapParamDef.sName) 
80463>>>>>>>>>>
80463>>>>>>>>>                        Function_Return False
80464>>>>>>>>>                    End
80464>>>>>>>>>>
80464>>>>>>>>>                End
80464>>>>>>>>>>
80464>>>>>>>>>             End
80464>>>>>>>>>>
80464>>>>>>>>>             Function_Return bOk
80465>>>>>>>>>        End
80465>>>>>>>>>>
80465>>>>>>>>>        
80465>>>>>>>>>
80465>>>>>>>>>        // a simple type or a simple null type
80465>>>>>>>>>
80465>>>>>>>>>        If (SoapParamDef.hoStruct=0) Begin
80467>>>>>>>>>            Get ValueTreeToSimpleValue SoapParamDef ValueTree to sSimpleValue
80468>>>>>>>>>            
80468>>>>>>>>>            Move False to bSkipMinZero
80469>>>>>>>>>            Move False to bNull
80470>>>>>>>>>            If ((SoapParamDef.iMin=C_Nillable or SoapParamDef.iMin=0) and SoapParamDef.bSimpleNullable) Begin
80472>>>>>>>>>                Get ValueTreeSimpleIsNull SoapParamDef ValueTree to bNull
80473>>>>>>>>>                If (bNull and SoapParamDef.iMin=0) Begin
80475>>>>>>>>>                    Move True to bSkipMinZero
80476>>>>>>>>>                End
80476>>>>>>>>>>
80476>>>>>>>>>            End
80476>>>>>>>>>>
80476>>>>>>>>>            
80476>>>>>>>>>            If (not(bSkipMinZero) and not(bNull)) Begin
80478>>>>>>>>>
80478>>>>>>>>>                // if this is date or datetime and the value is null and minOccurs=0 is allowed we will not pass the data as the service
80478>>>>>>>>>                // may not be able to handle a zero datetime value. We can only safely do this with dates and datetimes because a zero date
80478>>>>>>>>>                // is a null value. We can't do this with strings or numbers because a "" or 0, may be Null or may be a real value.
80478>>>>>>>>>                If ((SoapParamDef.iMin=C_Nillable or SoapParamDef.iMin=0) and (SoapParamDef.eType=xsDate or SoapParamDef.eType=xsDatetime)) Begin
80480>>>>>>>>>                    ConvertFromXML  SoapParamDef.eType sSimpleValue to dtDatetimeValue
80481>>>>>>>>>                    Move (IsNullDateTime(dtDatetimeValue)) to bNull
80482>>>>>>>>>                    If (bNull and SoapParamDef.iMin=0) Begin
80484>>>>>>>>>                        Move True to bSkipMinZero
80485>>>>>>>>>                    End
80485>>>>>>>>>>
80485>>>>>>>>>                End
80485>>>>>>>>>>
80485>>>>>>>>>            End    
80485>>>>>>>>>>
80485>>>>>>>>>                
80485>>>>>>>>>            If not bSkipMinZero Begin
80487>>>>>>>>>                Get AddElementNS of hoParam (If(bRpc,"", SoapParamDef.sNamespace)) SoapParamDef.sName '' to hoNode
80488>>>>>>>>>                If bNull Begin
80490>>>>>>>>>                    Send SetElementNil hoNode
80491>>>>>>>>>                End
80491>>>>>>>>>>
80491>>>>>>>>>                Else Begin
80492>>>>>>>>>                    // simple datatype. Just set the value in the xml node
80492>>>>>>>>>                    Set psText of hoNode to sSimpleValue
80493>>>>>>>>>                End
80493>>>>>>>>>>
80493>>>>>>>>>            End
80493>>>>>>>>>>
80493>>>>>>>>>            Move True to bOk
80494>>>>>>>>>        End
80494>>>>>>>>>>
80494>>>>>>>>>        Else Begin
80495>>>>>>>>>            
80495>>>>>>>>>            
80495>>>>>>>>>            Get pbSimpleContent of SoapParamDef.hoStruct to bSimpleContent
80496>>>>>>>>>
80496>>>>>>>>>            If bSimpleContent Begin
80498>>>>>>>>>                
80498>>>>>>>>>                 // if a struct with simple content, this is special. The valuetree child structure must be one element value followed by attributes
80498>>>>>>>>>                 // we want the element node added here and all of the remaining children to be attributes of this element
80498>>>>>>>>>                 //
80498>>>>>>>>>                 // so if simplecontent the value tree will be:
80498>>>>>>>>>                 //
80498>>>>>>>>>                 // ValueTree[x].Children 
80498>>>>>>>>>                 //   ValueTree[0].sValue = Value1
80498>>>>>>>>>                 //   ValueTree[1].Children             <--- this is the simplecontent node struct
80498>>>>>>>>>                 //        ValueTree[0].sValue = Value2 <---first node must be element
80498>>>>>>>>>                 //        ValueTree[1].sValue = attr1  <---remaining nodes are attributes
80498>>>>>>>>>                 //        ValueTree[2].sValue = attr2
80498>>>>>>>>>                 //   ValueTree[2].sValue = Value3
80498>>>>>>>>>                 //
80498>>>>>>>>>                 // and xml will be:
80498>>>>>>>>>                 //
80498>>>>>>>>>                 //    <m:FooEle1>Value1<m"FooEle1/>
80498>>>>>>>>>                 //    <m:FooEle2 Fooattr1="attr1" Fooattr2="attr2">Value2<m:FooEle2/> <---stuct becomes element w/ attrs
80498>>>>>>>>>                 //    <m:FooEle3>Value3<m:FooEle3/>
80498>>>>>>>>>                 //
80498>>>>>>>>>                 // Note we will use the SoapParamDef from the parent for the ns and name of the XML element. This first child value
80498>>>>>>>>>                 // found in SoapParamDefs[0] has no real meaning here.
80498>>>>>>>>>                 //
80498>>>>>>>>>                 // If this is a nullable struct in addition to be a simpletype struct, then the 1st valuetree child will not
80498>>>>>>>>>                 // be the simpletype, it will probably (if null member is first member) be the IsNull member. 
80498>>>>>>>>>                 //
80498>>>>>>>>>                 // ValueTree[x].Children 
80498>>>>>>>>>                 //   ValueTree[0].sValue = Value1
80498>>>>>>>>>                 //   ValueTree[1].Children             <--- this is the simplecontent node struct
80498>>>>>>>>>                 //        ValueTree[0].sValue = IsNull <--- if nullable, first node (probably) is the IsNull member
80498>>>>>>>>>                 //        ValueTree[1].sValue = Value2 <--- and next node will be element
80498>>>>>>>>>                 //        ValueTree[2].sValue = attr1  <---remaining nodes are attributes
80498>>>>>>>>>                 //        ValueTree[3].sValue = attr2
80498>>>>>>>>>                 //   ValueTree[2].sValue = Value3
80498>>>>>>>>>                 // Also If the simple type value is actually a "tN" nullable simple type, the value may be in one more level 
80498>>>>>>>>>                 // however the isnull member for this struct is ignored and must be false.
80498>>>>>>>>>                 Get piNullMember of SoapParamDef.hoStruct to iNullMember // -1 is none
80499>>>>>>>>>                 Get pSoapParamDefs of SoapParamDef.hoStruct to SoapParamDefs // get struct object params
80500>>>>>>>>>                 Move (SizeofArray(SoapParamDefs)) to iChildren
80501>>>>>>>>>                 // there should be at least one child. If this has a nullable param s/b at least 2
80501>>>>>>>>>                 If (iChildren > If(iNullMember>=0, 1, 0) ) Begin
80503>>>>>>>>>
80503>>>>>>>>>                    // if this has a null member and it's 0 next item (1) is the data
80503>>>>>>>>>                    Move (If(iNullMember=0, 1, 0)) to iValueNum
80504>>>>>>>>>
80504>>>>>>>>>                    // this is the element simple value
80504>>>>>>>>>                    Move ValueTree.Children[iValueNum] to ChildValueTree
80505>>>>>>>>>                    
80505>>>>>>>>>                    // If the simple type is nullable type (e.g., tNString) we need to get the value
80505>>>>>>>>>                    // in the struct. If it is set to null, let's raise an error as that should be done
80505>>>>>>>>>                    // in the struct struct that defines the simple value and the attribute members
80505>>>>>>>>>                    If (SoapParamDefs[iValueNum].bSimpleNullable) Begin
80507>>>>>>>>>                        Move ChildValueTree.children[C_SimpleDataMember].sValue to sSimpleValue
80508>>>>>>>>>                        If (ChildValueTree.children[C_SimpleNullMember].sValue = "true") Begin
80510>>>>>>>>>                            Error DFERR_PROGRAM "Don't set this nullable in the 'tN' type, use it's parent struct"
80511>>>>>>>>>>
80511>>>>>>>>>                        End
80511>>>>>>>>>>
80511>>>>>>>>>                    End
80511>>>>>>>>>>
80511>>>>>>>>>                    Else Begin
80512>>>>>>>>>                        Move ChildValueTree.sValue to sSimpleValue
80513>>>>>>>>>                    End
80513>>>>>>>>>>
80513>>>>>>>>>
80513>>>>>>>>>                    Move False to bSkipMinZero
80514>>>>>>>>>                    Move False to bNull
80515>>>>>>>>>                    If (iNullMember>=0 and (SoapParamDef.iMin=C_Nillable or SoapParamDef.iMin=0)) Begin
80517>>>>>>>>>                        Move (ValueTree.children[iNullMember].sValue="true") to bNull
80518>>>>>>>>>                        If (bNull and SoapParamDef.iMin=0) Begin
80520>>>>>>>>>                            Move True to bSkipMinZero
80521>>>>>>>>>                        End
80521>>>>>>>>>>
80521>>>>>>>>>                    End
80521>>>>>>>>>>
80521>>>>>>>>>                    If not bSkipMinZero Begin
80523>>>>>>>>>                        // we must use the element ns/name from the parent SoapParamDef for the xml tag.
80523>>>>>>>>>                        Get AddElementNS of hoParam (If(bRpc,"", SoapParamDef.sNamespace)) SoapParamDef.sName '' to hoNode
80524>>>>>>>>>                        // set the element text which is the first child
80524>>>>>>>>>                        
80524>>>>>>>>>                        If bNull Begin
80526>>>>>>>>>                            Send SetElementNil hoNode
80527>>>>>>>>>                        End
80527>>>>>>>>>>
80527>>>>>>>>>                        Else Begin
80528>>>>>>>>>                            Set psText of hoNode to sSimpleValue
80529>>>>>>>>>                        End
80529>>>>>>>>>>
80529>>>>>>>>>                        
80529>>>>>>>>>                        // all remaining children should be attributes. These are sent 
80529>>>>>>>>>                        // if this is a nil element node we still create other attributes as required. 
80529>>>>>>>>>                        // if a Null minOccurs=0 node, we will skip the entire element (rules are fuzzy here)
80529>>>>>>>>>                        // if a Nill minOccurs node, we will set the nil value and the other attributes
80529>>>>>>>>>                        For i from (iValueNum+1) to (iChildren-1)
80535>>>>>>>>>>
80535>>>>>>>>>                            // we must skip the null members
80535>>>>>>>>>                            If (iNullMember<>i) Begin
80537>>>>>>>>>                                Move ValueTree.Children[i] to ChildValueTree
80538>>>>>>>>>                                Get ValueTreeToXml SoapParamDefs[i] ChildValueTree hoNode to bOk
80539>>>>>>>>>                            End
80539>>>>>>>>>>
80539>>>>>>>>>                        Loop
80540>>>>>>>>>>
80540>>>>>>>>>                    End
80540>>>>>>>>>>
80540>>>>>>>>>
80540>>>>>>>>>                 End
80540>>>>>>>>>>
80540>>>>>>>>>                 Else Begin
80541>>>>>>>>>                    // this is actually an invalid defintion and should never happen
80541>>>>>>>>>                    Move False to bOk
80542>>>>>>>>>                 End
80542>>>>>>>>>>
80542>>>>>>>>>            End
80542>>>>>>>>>>
80542>>>>>>>>>            
80542>>>>>>>>>            Else Begin
80543>>>>>>>>>
80543>>>>>>>>>                 // Complex. Either an Array or a Struct
80543>>>>>>>>>                 
80543>>>>>>>>>                 Get pSoapParamDefs of SoapParamDef.hoStruct to SoapParamDefs // get struct object params
80544>>>>>>>>>                 Get peArrayType    of SoapParamDef.hoStruct to eArrayType
80545>>>>>>>>>                 Move (SizeofArray(SoapParamDefs)) to iChildren
80546>>>>>>>>>                 If (eArrayType=C_atNone and iChildren=0 and SoapParamDef.iMin=0) Begin
80548>>>>>>>>>                     // this is a special case where we do not pass the data at all. If this is a struct with no children, this is one of those
80548>>>>>>>>>                     // strange complexType that have no content. If minOccurs=0, there is no need to pass the parameter at all.
80548>>>>>>>>>                 End
80548>>>>>>>>>>
80548>>>>>>>>>                 Else Begin
80549>>>>>>>>>
80549>>>>>>>>>                    Move False to bNull
80550>>>>>>>>>                    Get piNullMember of SoapParamDef.hoStruct to iNullMember
80551>>>>>>>>>                    If ( (iNullMember>=0 or eArrayType=C_atArray) and (SoapParamDef.iMin=C_Nillable or SoapParamDef.iMin=0)) Begin
80553>>>>>>>>>                        If (eArrayType=C_atArray) Begin
80555>>>>>>>>>                            Move (SizeOfArray(ValueTree.children)=0) to bNull
80556>>>>>>>>>                        End
80556>>>>>>>>>>
80556>>>>>>>>>                        Else Begin
80557>>>>>>>>>                            Move (ValueTree.children[iNullMember].sValue="true") to bNull
80558>>>>>>>>>                        End
80558>>>>>>>>>>
80558>>>>>>>>>                    End
80558>>>>>>>>>>
80558>>>>>>>>>
80558>>>>>>>>>
80558>>>>>>>>>                    If (bNull) Begin
80560>>>>>>>>>                        If (SoapParamDef.iMin=C_Nillable) Begin
80562>>>>>>>>>                             Get AddElementNS of hoParam (If(bRpc,"", SoapParamDef.sNamespace)) SoapParamDef.sName '' to hoNode
80563>>>>>>>>>                             Send SetElementNil hoNode
80564>>>>>>>>>                        End
80564>>>>>>>>>>
80564>>>>>>>>>                    End
80564>>>>>>>>>>
80564>>>>>>>>>                    Else Begin
80565>>>>>>>>>
80565>>>>>>>>>    
80565>>>>>>>>>                         Get AddElementNS of hoParam (If(bRpc,"", SoapParamDef.sNamespace)) SoapParamDef.sName '' to hoNode
80566>>>>>>>>>            
80566>>>>>>>>>            
80566>>>>>>>>>                         // if arrayType is C_atArray or C_atSoapEncArray then we know that we only have a single element and that this
80566>>>>>>>>>                         // describes the array. We also don't want to treat this as a Struct with an array member in the value tree. That would
80566>>>>>>>>>                         // create two levels and we only want one. In addition, soap-enc arrays are special. If multi-dimensional the XML
80566>>>>>>>>>                         // should provide the information needed about the size of dimensions and the dimensional data is all presented flat.
80566>>>>>>>>>                         If (eArrayType=C_atSoapEncArray) Begin
80568>>>>>>>>>                             //to do
80568>>>>>>>>>                         End
80568>>>>>>>>>>
80568>>>>>>>>>            
80568>>>>>>>>>                         
80568>>>>>>>>>                         For i from 0 to (iChildren-1)
80574>>>>>>>>>>
80574>>>>>>>>>                            
80574>>>>>>>>>                            If (iNullMember<>i) Begin
80576>>>>>>>>>                                
80576>>>>>>>>>                                // must always be a 1 to 1 between child param def and value tree
80576>>>>>>>>>                                Move SoapParamDefs[i]      to ChildSoapParamDef
80577>>>>>>>>>                
80577>>>>>>>>>                                // If an array of some sort.
80577>>>>>>>>>                                If (ChildSoapParamDef.iMax>1 or ChildSoapParamDef.iMax=C_Unbounded) Begin
80579>>>>>>>>>                                    // if an array we go in one more level of the value tree and handle all array items for
80579>>>>>>>>>                                    // the one childSoapParamDef
80579>>>>>>>>>                
80579>>>>>>>>>                                    // if non declared array-type, we bump in one more level of the value tree
80579>>>>>>>>>                                    If (eArrayType=C_atNone) Begin
80581>>>>>>>>>                                        Move ValueTree.Children[i] to ChildValueTree
80582>>>>>>>>>                                        Move (SizeOfArray(ChildValueTree.Children)) to iItems
80583>>>>>>>>>                                        For j from 0 to (iItems-1)
80589>>>>>>>>>>
80589>>>>>>>>>                                            // if array, the valueTree children are the array values
80589>>>>>>>>>                                            Move ChildValueTree.Children[j] to ArrayChildValueTree
80590>>>>>>>>>                                            Get ValueTreeToXml ChildSoapParamDef ArrayChildValueTree hoNode to bOk
80591>>>>>>>>>                                        Loop
80592>>>>>>>>>>
80592>>>>>>>>>                                    End
80592>>>>>>>>>>
80592>>>>>>>>>                                    // if array-type, the value tree has the children (we've already processed one level in because it has an extra struct)
80592>>>>>>>>>                                    Else Begin
80593>>>>>>>>>                                        Move (SizeOfArray(ValueTree.Children)) to iItems
80594>>>>>>>>>                
80594>>>>>>>>>                                        If (eArrayType=C_atSoapEncArray) Begin
80596>>>>>>>>>                                            Get piDimensions    of SoapParamDef.hoStruct to iDimensions
80597>>>>>>>>>                                            Get psDataType of SoapParamDef.hoStruct to sType
80598>>>>>>>>>                
80598>>>>>>>>>                                            If (ChildSoapParamDef.eType<>xsStruct) Begin
80600>>>>>>>>>                                                Get psSchemaNSPre to sSchemaNSPre
80601>>>>>>>>>                                                Get psSchemaNSUri to sSchemaNSUri
80602>>>>>>>>>                                            End
80602>>>>>>>>>>
80602>>>>>>>>>                                            Else Begin
80603>>>>>>>>>                                                // if a struct, the namespace for the struct is defined in the array struct 
80603>>>>>>>>>                                                // We can't just use psNameSpace because it will be "" if not qualified. With
80603>>>>>>>>>                                                // soap encoded array we must now this to define arrayType. If this package is
80603>>>>>>>>>                                                // used on a web client sub-class defined with a pre 14.0 class generator this will
80603>>>>>>>>>                                                // always be blank (which may be wrong but is no better or no worse that it already was).
80603>>>>>>>>>                                                Get psDataTypeNamespace of SoapParamDef.hoStruct to sSchemaNSURI
80604>>>>>>>>>                                                //Get psNameSpace  of ChildSoapParamDef.hoStruct to sSchemaNSUri // pre 14.0
80604>>>>>>>>>                                                Move "n" to sSchemaNSPre
80605>>>>>>>>>                                            End
80605>>>>>>>>>>
80605>>>>>>>>>                                            Send CreateSoapEncodedArrayAttributes hoNode sType sSchemaNSPre sSchemaNSURI iDimensions iItems
80606>>>>>>>>>                                        End
80606>>>>>>>>>>
80606>>>>>>>>>                
80606>>>>>>>>>                                        For j from 0 to (iItems-1)
80612>>>>>>>>>>
80612>>>>>>>>>                                            // if array, the valueTree children are the array values
80612>>>>>>>>>                                            Move ValueTree.Children[j] to ArrayChildValueTree
80613>>>>>>>>>                                            Get ValueTreeToXml ChildSoapParamDef ArrayChildValueTree hoNode to bOk
80614>>>>>>>>>                                        Loop
80615>>>>>>>>>>
80615>>>>>>>>>                                    End
80615>>>>>>>>>>
80615>>>>>>>>>                                End
80615>>>>>>>>>>
80615>>>>>>>>>                                // if a struct, just recurse and handle struct members
80615>>>>>>>>>                                Else Begin
80616>>>>>>>>>                                    Move ValueTree.Children[i] to ChildValueTree
80617>>>>>>>>>                                    Get ValueTreeToXml ChildSoapParamDef ChildValueTree hoNode to bOk
80618>>>>>>>>>                                End
80618>>>>>>>>>>
80618>>>>>>>>>                            End
80618>>>>>>>>>>
80618>>>>>>>>>            
80618>>>>>>>>>                         Loop
80619>>>>>>>>>>
80619>>>>>>>>>                    End
80619>>>>>>>>>>
80619>>>>>>>>>                 End
80619>>>>>>>>>>
80619>>>>>>>>>            End
80619>>>>>>>>>>
80619>>>>>>>>>        End
80619>>>>>>>>>>
80619>>>>>>>>>        
80619>>>>>>>>>        If hoNode Begin
80621>>>>>>>>>            Send destroy of hoNode
80622>>>>>>>>>         End
80622>>>>>>>>>>
80622>>>>>>>>>         Function_Return bOK
80623>>>>>>>>>    End_Function
80624>>>>>>>>>
80624>>>>>>>>>    Procedure CreateSoapEncodedArrayAttributes Handle hoNode String sType String sSchemaNSPre String sSchemaNSURI Integer iDimensions Integer iItems
80626>>>>>>>>>        String sSoapEncodingNsPre sSoapEncodingNsURI
80626>>>>>>>>>        String sDims sArrayType
80626>>>>>>>>>        Get psSoapEncodingNsUri to sSoapEncodingNsUri
80627>>>>>>>>>        Get psSoapEncodingNsPre to sSoapEncodingNsPre
80628>>>>>>>>>        Move (Repeat("[]",iDimensions-1)+"["+String(iItems)+"]") to sDims
80629>>>>>>>>>        Move (sSchemaNSPre+":"+sType+sDims) to sArrayType
80630>>>>>>>>>        Send AddAttributeNS of hoNode sSoapEncodingNsUri (sSoapEncodingNsPre - ":arrayType") sArrayType
80631>>>>>>>>>        Send AddAttribute of hoNode ("xmlns:"+sSchemaNSPre) sSchemaNSUri
80632>>>>>>>>>    End_Procedure
80633>>>>>>>>>
80633>>>>>>>>>
80633>>>>>>>>>
80633>>>>>>>>>    // look for an id="xxxx" at the body level and return this node.
80633>>>>>>>>>    Function ResolveHRef Handle hoNode String sHRef Returns Handle
80635>>>>>>>>>        Handle hoBody hoId
80635>>>>>>>>>        // we assume that all multi-reference values are stored as direct children of the body section. This is how .net does it.
80635>>>>>>>>>        Get phoReturnBody to hoBody
80636>>>>>>>>>        // strip first characer in sHRef, it is a "#" and it not part of the ID
80636>>>>>>>>>        // Look for any element with an attribute of id="xxx". e.g. *[@id="id-27"] looks for <anyelement id="id-27" ...>
80636>>>>>>>>>        Get FindNode of hoBody ('*[@id = "'+remove(sHRef,1,1)+'"]') to hoId
80637>>>>>>>>>        Function_Return hoId
80638>>>>>>>>>    End_Procedure
80639>>>>>>>>>
80639>>>>>>>>>
80639>>>>>>>>>    // this is an xsAnyType or xsXmlElement. This is only supported at the outer (return level). Create the
80639>>>>>>>>>    // needed XML node and add the value to the valuetee.
80639>>>>>>>>>    Function XMLHandleToValueTree tSoapParamDef SoapParamDef Handle hoNode Returns tValueTreeEx
80641>>>>>>>>>        Handle     hoChildNode hoReturnNode hoReturnObj
80641>>>>>>>>>        tValueTreeEx ValueTree
80641>>>>>>>>>        tValueTreeEx ValueTree
80641>>>>>>>>>        Boolean bRpc
80641>>>>>>>>>        Move (peSoapStyle(Self)=ssRpc) to bRpc
80642>>>>>>>>>
80642>>>>>>>>>        // if any type we use the entire parameter including the wrapper. This is the "give me the whole thing mode"
80642>>>>>>>>>        If (SoapParamDef.eType=xsAnyType) Begin
80644>>>>>>>>>            Get CloneNode of hoNode True to hoReturnNode
80645>>>>>>>>>        End
80645>>>>>>>>>>
80645>>>>>>>>>        Else Begin
80646>>>>>>>>>            // if xmlElement we are saying there is a single xml parameter passed. Remove the wrapper and get the document
80646>>>>>>>>>            Get FirstNonCommentChild hoNode to hoChildNode
80647>>>>>>>>>            Get CloneNode of hoChildNode True to hoReturnNode
80648>>>>>>>>>            Send Destroy of hoChildNode
80649>>>>>>>>>        End
80649>>>>>>>>>>
80649>>>>>>>>>        // we are not handling hrefs here. If there are hrefs the developer will need handle this themselves by looking at the
80649>>>>>>>>>        // entire soap response.
80649>>>>>>>>>
80649>>>>>>>>>        // return desktop XML object
80649>>>>>>>>>        Get Create  of desktop U_cXmlDomDocument to hoReturnObj
80650>>>>>>>>>        Get AppendNode of hoReturnObj hoReturnNode to hoReturnNode
80651>>>>>>>>>        Send destroy of hoReturnNode
80652>>>>>>>>>        Move hoReturnObj to ValueTree.sValue // return ob is an handle to a desktop XML object
80653>>>>>>>>>        Function_Return ValueTree
80654>>>>>>>>>   End_Function
80655>>>>>>>>>
80655>>>>>>>>>   // Marks a ValueTree as being null if the datatype in SoapParamDef is actually nullable
80655>>>>>>>>>   // With structs this requires that oen of the struct members is a nullable flag.
80655>>>>>>>>>   // With simple data this requires that simple type is simple nullable (using our special predefined null structs)
80655>>>>>>>>>   // In either case we make sure thatValueTree array is filled out as the deserialze command expects this.
80655>>>>>>>>>   Function CreateNullValueTree tSoapParamDef SoapParamDef Returns tValueTreeEx
80657>>>>>>>>>       tValueTreeEx ValueTree
80657>>>>>>>>>       tValueTreeEx ValueTree
80657>>>>>>>>>       Integer iNullMember iMembers
80657>>>>>>>>>       // a iMin=0 with no items. We may want to mark this as null
80657>>>>>>>>>       If (SoapParamDef.hoStruct) Begin
80659>>>>>>>>>           Get piNullMember of SoapParamDef.hoStruct to iNullMember
80660>>>>>>>>>           If (iNullMember>=0) Begin
80662>>>>>>>>>               Move (SizeOfArray(pSoapParamDefs(SoapParamDef.hoStruct))) to iMembers
80663>>>>>>>>>               Move "" to ValueTree.children[iMembers-1].sValue // put something in the last member array slot
80664>>>>>>>>>               Move "true" to ValueTree.children[iNullMember].sValue
80665>>>>>>>>>           End
80665>>>>>>>>>>
80665>>>>>>>>>       End
80665>>>>>>>>>>
80665>>>>>>>>>       Else Begin
80666>>>>>>>>>           If (SoapParamDef.bSimpleNullable) Begin
80668>>>>>>>>>               Move "" to ValueTree.children[C_SimpleDataMember].sValue
80669>>>>>>>>>               Move "true" to ValueTree.children[C_SimpleNullMember].sValue
80670>>>>>>>>>           End
80670>>>>>>>>>>
80670>>>>>>>>>       End
80670>>>>>>>>>>
80670>>>>>>>>>       Function_Return ValueTree
80671>>>>>>>>>   End_Function
80672>>>>>>>>>
80672>>>>>>>>>   // Move XML value to simple Value Tree. We use SoapParamDef to determine how value tree is set up.
80672>>>>>>>>>   // If a true simple type, just set ValyyeTree.sValue . If a nullable type (actually a struct) we
80672>>>>>>>>>   // set child sValues
80672>>>>>>>>>   Function XMLToSimpleValueTree tSoapParamDef SoapParamDef Handle hoNode Returns tValueTreeEx
80674>>>>>>>>>       tValueTreeEx ValueTree
80674>>>>>>>>>       tValueTreeEx ValueTree
80674>>>>>>>>>       String sValue
80674>>>>>>>>>
80674>>>>>>>>>        If ( SoapParamDef.hoStruct<>0 and not(pbSimpleContent(SoapParamDef.hoStruct))) Begin
80676>>>>>>>>>            Error DFERR_PROGRAM "Assert: XMLToSimpleValueTree is not passed a simple type definition"
80677>>>>>>>>>>
80677>>>>>>>>>        End
80677>>>>>>>>>>
80677>>>>>>>>>
80677>>>>>>>>>       // simple datatype. Just set the xml value in the value node
80677>>>>>>>>>       Get psText of hoNode to sValue
80678>>>>>>>>>       If (SoapParamDef.bSimpleNullable) Begin
80680>>>>>>>>>           Move sValue to ValueTree.children[C_SimpleDataMember].sValue
80681>>>>>>>>>           Move "false" to ValueTree.children[C_SimpleNullMember].sValue
80682>>>>>>>>>       End
80682>>>>>>>>>>
80682>>>>>>>>>       Else Begin
80683>>>>>>>>>           Move sValue to ValueTree.sValue
80684>>>>>>>>>       End
80684>>>>>>>>>>
80684>>>>>>>>>       Function_Return ValueTree
80685>>>>>>>>>   End_Function
80686>>>>>>>>>   
80686>>>>>>>>>   // mark this node as xsi:nil="true"
80686>>>>>>>>>   Procedure SetElementNil Handle hoNode
80688>>>>>>>>>        String sPre sNs
80688>>>>>>>>>        Get psSchemaInstanceNSPre to sPre
80689>>>>>>>>>        Get psSchemaInstanceNSUri to sNs
80690>>>>>>>>>        Send AddAttributeNS of hoNode sNs (sPre + ":nil") "true"
80691>>>>>>>>>   End_Procedure
80692>>>>>>>>>
80692>>>>>>>>>
80692>>>>>>>>>    // XML Node to Value Tree
80692>>>>>>>>>    //
80692>>>>>>>>>    // Create XML based on contents of ValueTree data.
80692>>>>>>>>>    // (this doesn't support SoapEncArray yet
80692>>>>>>>>>    //
80692>>>>>>>>>    // iError is passed by reference. If it is non-zero, we must exit
80692>>>>>>>>>    Function XMLToValueTree tSoapParamDef SoapParamDef Handle hoNode Integer ByRef iError Returns tValueTreeEx
80694>>>>>>>>>        Handle     hoChildNode hoDataNode
80694>>>>>>>>>        Integer    iChildren i iItems eArrayType iMatch iType
80694>>>>>>>>>        String     sValue sRef sNil sNs sBaseName sRefToken sNSUri
80694>>>>>>>>>        Boolean    bNodeIsHRef bRpc bIsAll bSimpleContent bChoice bMatch bNil
80694>>>>>>>>>        tSoapParamDef  ChildSoapParamDef
80694>>>>>>>>>        tSoapParamDef  ChildSoapParamDef
80694>>>>>>>>>        tSoapParamDef[] SoapParamDefs
80694>>>>>>>>>        tSoapParamDef[] SoapParamDefs
80695>>>>>>>>>        tValueTreeEx ValueTree ChildValueTree ArrayChildValueTree EmptyValueTree
80695>>>>>>>>>        tValueTreeEx ValueTree ChildValueTree ArrayChildValueTree EmptyValueTree
80695>>>>>>>>>        Integer iNullMember iValueNum
80695>>>>>>>>>
80695>>>>>>>>>        Move (peSoapStyle(Self)=ssRpc) to bRpc
80696>>>>>>>>>
80696>>>>>>>>>        // AnyType or XmlElement should never be passed as a member, this is an error
80696>>>>>>>>>        If (SoapParamDef.eType=xsAnyType or SoapParamDef.eType=xsXmlElement) Begin
80698>>>>>>>>>            Move wssInvalidDataForType to iError // programming error. these types should never be in structs
80699>>>>>>>>>            Function_Return ValueTree
80700>>>>>>>>>        End
80700>>>>>>>>>>
80700>>>>>>>>>        
80700>>>>>>>>>        // AnyTypeStr or XmlElementStr are seralized XML variant Bstrings and can be passed as a member
80700>>>>>>>>>        // also check for xsbase64Binary
80700>>>>>>>>>        If (SoapParamDef.eType=xsAnyTypeStr or SoapParamDef.eType=xsXmlElementStr or SoapParamDef.eType=xsBase64Binary) Begin
80702>>>>>>>>>            Get XMLVariantBStrToValueTree SoapParamDef hoNode (&iError) to  ValueTree 
80703>>>>>>>>>            Function_Return ValueTree
80704>>>>>>>>>        End
80704>>>>>>>>>>
80704>>>>>>>>>
80704>>>>>>>>>        // if the elemement node is href, we will replace the node with the proper ID node and
80704>>>>>>>>>        // proceed on from that node.
80704>>>>>>>>>        Get psRefToken to sRefToken
80705>>>>>>>>>        Get AttributeValue of hoNode sRefToken to sRef
80706>>>>>>>>>        Move (sRef<>"") to bNodeIsHRef
80707>>>>>>>>>        If bNodeIsHRef Begin
80709>>>>>>>>>            Get ResolveHRef hoNode sRef to hoDataNode
80710>>>>>>>>>            If (hoDataNode=0) Begin
80712>>>>>>>>>                Move wssCouldNotResolveHRef to iError
80713>>>>>>>>>                Function_Return ValueTree // error could not resolve href node
80714>>>>>>>>>            End
80714>>>>>>>>>>
80714>>>>>>>>>        End
80714>>>>>>>>>>
80714>>>>>>>>>        Else Begin
80715>>>>>>>>>            Move hoNode to hoDataNode
80716>>>>>>>>>        End
80716>>>>>>>>>>
80716>>>>>>>>>
80716>>>>>>>>>        // support for nillable nodes. If we get a xsi:nil="true", assume empty node
80716>>>>>>>>>        If (not(SoapParamDef.bAttribute)) Begin
80718>>>>>>>>>            Get psSchemaInstanceNSUri to sNSUri
80719>>>>>>>>>            Get AttributeValueNS of hoDataNode sNSUri "nil" to sNil
80720>>>>>>>>>            Move (sNil="true" or sNil="1") to bNil
80721>>>>>>>>>        End
80721>>>>>>>>>>
80721>>>>>>>>>
80721>>>>>>>>>
80721>>>>>>>>>        // if an attribute, this will be an attribute in the parent xml node. Get the
80721>>>>>>>>>        // value. If not found use the default. Update the value tree
80721>>>>>>>>>
80721>>>>>>>>>        // attribute
80721>>>>>>>>>        
80721>>>>>>>>>        If (SoapParamDef.bAttribute) Begin
80723>>>>>>>>>            // add an attribute
80723>>>>>>>>>            Get AttributeValueNodeNS of hoDataNode SoapParamDef.sNamespace SoapParamDef.sName to hoChildNode
80724>>>>>>>>>            If hoChildNode Begin
80726>>>>>>>>>                Get Value of hoChildNode to sValue
80727>>>>>>>>>                Send Destroy of hoChildNode
80728>>>>>>>>>            End
80728>>>>>>>>>>
80728>>>>>>>>>            Else Begin
80729>>>>>>>>>                // if not found we can just use the default as defined in the schema
80729>>>>>>>>>                Move SoapParamDef.sDefaultAttr to sValue
80730>>>>>>>>>            End
80730>>>>>>>>>>
80730>>>>>>>>>            Move sValue to ValueTree.sValue
80731>>>>>>>>>        End
80731>>>>>>>>>>
80731>>>>>>>>>
80731>>>>>>>>>        // simple data type
80731>>>>>>>>>        
80731>>>>>>>>>        Else If (SoapParamDef.hoStruct=0) Begin
80734>>>>>>>>>            If bNil Begin
80736>>>>>>>>>               Get CreateNullValueTree SoapParamDef to ValueTree 
80737>>>>>>>>>            End
80737>>>>>>>>>>
80737>>>>>>>>>            Else Begin
80738>>>>>>>>>                // simple datatype. Just set the xml value in the value node
80738>>>>>>>>>                Get XMLToSimpleValueTree SoapParamDef hoDataNode to ValueTree
80739>>>>>>>>>            End
80739>>>>>>>>>>
80739>>>>>>>>>        End
80739>>>>>>>>>>
80739>>>>>>>>>        Else Begin
80740>>>>>>>>>            
80740>>>>>>>>>            Get pbSimpleContent of SoapParamDef.hoStruct to bSimpleContent
80741>>>>>>>>>            Get pbChoice of SoapParamDef.hoStruct to bChoice
80742>>>>>>>>>            
80742>>>>>>>>>            If bChoice Begin // choice is handled in its own method. This is an error
80744>>>>>>>>>                Error DFERR_PROGRAM "XMLToValueTree called in wrong state (choice)"
80745>>>>>>>>>>
80745>>>>>>>>>                Move wssInvalidDataForType to iError // this is a programming error
80746>>>>>>>>>            End
80746>>>>>>>>>>
80746>>>>>>>>>
80746>>>>>>>>>            Else If bSimpleContent Begin
80749>>>>>>>>>                
80749>>>>>>>>>                // if simpleContent, this is node represents a single element and attributes
80749>>>>>>>>>                // for the element. These all belong in a child node. There will be no children.                
80749>>>>>>>>>                // if a struct with simple content, this is special. The valuetree child structure must be one element value followed by attributes
80749>>>>>>>>>                // we want the element node added here and all of the remaining children to be attributes of this element
80749>>>>>>>>>                //
80749>>>>>>>>>                // so xml is 
80749>>>>>>>>>                //
80749>>>>>>>>>                //    <m:FooEle1>Value1<mFooEle1/>
80749>>>>>>>>>                //    <m:FooEle2 Fooattr1="attr1" Fooattr2="attr2">Value2<mFooEle2/> <---stuct becomes element w/ attrs
80749>>>>>>>>>                //    <m:FooEle3>Value3<mFooEle3/>
80749>>>>>>>>>                //
80749>>>>>>>>>                // the value tree will be:
80749>>>>>>>>>                //
80749>>>>>>>>>                // ValueTree[x].Children 
80749>>>>>>>>>                //   ValueTree[0].sValue = Value1
80749>>>>>>>>>                //   ValueTree[1].Children             <--- this is the simplecontent node struct
80749>>>>>>>>>                //        ValueTree[0].sValue = Value2 <---first node must be element
80749>>>>>>>>>                //        ValueTree[1].sValue = attr1  <---remaining nodes are attributes
80749>>>>>>>>>                //        ValueTree[2].sValue = attr2
80749>>>>>>>>>                //   ValueTree[2].sValue = Value3
80749>>>>>>>>>                //
80749>>>>>>>>>                // If this is a nullable simple member then there will be an extra member for the null flag. This is
80749>>>>>>>>>                // applied at this level and not the actual value level.
80749>>>>>>>>>                //
80749>>>>>>>>>                //   ValueTree[1].Children             <--- this is the simplecontent node struct
80749>>>>>>>>>                //        ValueTree[0].sValue = IsNull <---first node will be the null flah
80749>>>>>>>>>                //        ValueTree[1].sValue = Value2 <--- and the next  node must be element
80749>>>>>>>>>                //        ValueTree[2].sValue = attr1  <---remaining nodes are attributes
80749>>>>>>>>>                //        ValueTree[3].sValue = attr2
80749>>>>>>>>>                //
80749>>>>>>>>>
80749>>>>>>>>>                // if nil, set the null flag in the valuetree but still add all of the
80749>>>>>>>>>                // attributes out assuming the nil only applies to the element 
80749>>>>>>>>>                If bNil Begin
80751>>>>>>>>>                   Get CreateNullValueTree SoapParamDef to ValueTree 
80752>>>>>>>>>                End
80752>>>>>>>>>>
80752>>>>>>>>>
80752>>>>>>>>>                Get piNullMember of SoapParamDef.hoStruct to iNullMember // -1 is none
80753>>>>>>>>>                Get pSoapParamDefs   of SoapParamDef.hoStruct to SoapParamDefs // get struct object params
80754>>>>>>>>>                Move (SizeofArray(SoapParamDefs)) to iChildren
80755>>>>>>>>>                If (iChildren > If(iNullMember>=0, 1, 0) ) Begin                    
80757>>>>>>>>>                    // if this has a null member and it's 0 next item (1) is the data
80757>>>>>>>>>                    // the element goes in iValueNum
80757>>>>>>>>>                    Move (If(iNullMember=0, 1, 0)) to iValueNum
80758>>>>>>>>>                   
80758>>>>>>>>>                    If bNil Begin
80760>>>>>>>>>                        // if nill we don't need to mark the null flag as that is done at struct level one up.
80760>>>>>>>>>                        // we do need to add an empty value. If the value is a "tN" nullable simple struct we 
80760>>>>>>>>>                        // set null member to false (yes that's right) because it serves no purpose 
80760>>>>>>>>>                        If (SoapParamDefs[iValueNum].bSimpleNullable) Begin
80762>>>>>>>>>                            Move EmptyValueTree to ChildValueTree
80763>>>>>>>>>                            Move "" to ChildValueTree.children[C_SimpleDataMember].sValue
80764>>>>>>>>>                            Move "false" to ChildValueTree.children[C_SimpleNullMember].sValue
80765>>>>>>>>>                        End
80765>>>>>>>>>>
80765>>>>>>>>>                        Else Begin                           
80766>>>>>>>>>                            Move EmptyValueTree to ChildValueTree
80767>>>>>>>>>                        End 
80767>>>>>>>>>>
80767>>>>>>>>>                    End
80767>>>>>>>>>>
80767>>>>>>>>>                    Else Begin
80768>>>>>>>>>                        // simple datatype. Just set the xml value in the value node
80768>>>>>>>>>                        Get XMLToSimpleValueTree SoapParamDefs[iValueNum] hoDataNode to ChildValueTree
80769>>>>>>>>>                    End
80769>>>>>>>>>>
80769>>>>>>>>>                    // update the first value tree child node with the element
80769>>>>>>>>>                    Move ChildValueTree to ValueTree.Children[iValueNum]
80770>>>>>>>>>                    
80770>>>>>>>>>                    // update remaining sibling childnodes with attributes skipping the null member
80770>>>>>>>>>                    For i from (iValueNum+1) to (iChildren-1)
80776>>>>>>>>>>
80776>>>>>>>>>                        If (iNullMember<>i) Begin
80778>>>>>>>>>                            Move EmptyValueTree to ChildValueTree
80779>>>>>>>>>                            Move SoapParamDefs[i]  to ChildSoapParamDef
80780>>>>>>>>>                            Get XMLToValueTree ChildSoapParamDef hoDataNode (&iError) to ChildValueTree
80781>>>>>>>>>                            Move ChildValueTree to ValueTree.Children[i]
80782>>>>>>>>>                        End
80782>>>>>>>>>>
80782>>>>>>>>>                    Loop
80783>>>>>>>>>>
80783>>>>>>>>>                End
80783>>>>>>>>>>
80783>>>>>>>>>                Else Begin
80784>>>>>>>>>                    // this is actually an invalid defintion and should never happen
80784>>>>>>>>>                    Move wssInvalidDataForType to iError
80785>>>>>>>>>                End
80785>>>>>>>>>>
80785>>>>>>>>>            End
80785>>>>>>>>>>
80785>>>>>>>>>            Else Begin
80786>>>>>>>>>            
80786>>>>>>>>>                // Complex. Either an Array or a Struct
80786>>>>>>>>>
80786>>>>>>>>>                If bNil Begin
80788>>>>>>>>>                   Get CreateNullValueTree SoapParamDef to ChildValueTree 
80789>>>>>>>>>                End
80789>>>>>>>>>>
80789>>>>>>>>>                Else Begin
80790>>>>>>>>>        
80790>>>>>>>>>                    Get pSoapParamDefs   of SoapParamDef.hoStruct to SoapParamDefs // get struct object params
80791>>>>>>>>>                    Get peArrayType      of SoapParamDef.hoStruct to eArrayType
80792>>>>>>>>>                    Get pbSchemaAllGroup of SoapParamDef.hoStruct to bIsAll        // true if the schema defines struct elements via <all>
80793>>>>>>>>>        
80793>>>>>>>>>                    // if arrayType is C_atArray or C_atSoapEncArray then we know that we only have a single element and that this
80793>>>>>>>>>                    // describes the array. We also don't want to treat this as a Struct with an array member in the value tree. That would
80793>>>>>>>>>                    // create two levels and we only want one. At the moment both array types can be treated the same. Soap-enc array will get tricky if
80793>>>>>>>>>                    // we decide to support multi-dim soap enc ([,]) instead of jagged arrays ([][]) - we don't do that yet.
80793>>>>>>>>>        
80793>>>>>>>>>                    Move (SizeofArray(SoapParamDefs)) to iChildren
80794>>>>>>>>>        
80794>>>>>>>>>                    If not (bIsAll) Begin
80796>>>>>>>>>                        Get FirstNonCommentChild hoDataNode to hoChildNode
80797>>>>>>>>>                    End
80797>>>>>>>>>>
80797>>>>>>>>>    
80797>>>>>>>>>                    Get piNullMember of SoapParamDef.hoStruct to iNullMember
80798>>>>>>>>>    
80798>>>>>>>>>                    For i from 0 to (iChildren-1)
80804>>>>>>>>>>
80804>>>>>>>>>                        
80804>>>>>>>>>                        Move EmptyValueTree to ChildValueTree
80805>>>>>>>>>                        
80805>>>>>>>>>                        If (iNullMember<>i) Begin
80807>>>>>>>>>                        
80807>>>>>>>>>                            Move SoapParamDefs[i]  to ChildSoapParamDef
80808>>>>>>>>>        
80808>>>>>>>>>                            If (ChildSoapParamDef.iMax>1 or ChildSoapParamDef.iMax=C_Unbounded) Begin
80810>>>>>>>>>            
80810>>>>>>>>>                                // if an array we go in one more level of the value tree and handle all array items for the one childSoapParamDef
80810>>>>>>>>>                                // there are two types of arrays at this point. A struct that is really an array (C_atArray or C_atSoapEncArray) or a struct member
80810>>>>>>>>>                                // that that is an array (because the element is unbounded). If C_atArray/C_atSoapEncArray we don't need the extra valueTree level
80810>>>>>>>>>                                // (because it is already there). We make adjustments here so that the valueTree is the same with all array styles
80810>>>>>>>>>                                Move 0 to iItems
80811>>>>>>>>>                                
80811>>>>>>>>>                                // handling for array of choices.
80811>>>>>>>>>                                If (ChildSoapParamDef.hoStruct and (pbChoice(ChildSoapParamDef.hoStruct) )) Begin
80813>>>>>>>>>                                    // we need to keep looking at child nodes to see if they are one of the valid choices. If they are
80813>>>>>>>>>                                    // we will add another choice array. 
80813>>>>>>>>>                                    Repeat 
80813>>>>>>>>>>
80813>>>>>>>>>                                        // Note that this can be called with no childnode at all, which is legal when there is no more struct members.
80813>>>>>>>>>                                        // hoChildNode will return pointing to the next non-choice node.
80813>>>>>>>>>                                        // bMatch will be True if a choice element was processed. This is how we know when we are done. 
80813>>>>>>>>>                                        // Note that an empty array of choices is always allowed.
80813>>>>>>>>>                                        Get XMLChoiceToValueTree ChildSoapParamDef (&hoChildNode) (&iError) (&bMatch) to ArrayChildValueTree
80814>>>>>>>>>                                        // only add an array choice item if there is an actual match
80814>>>>>>>>>                                        If (iError=0 and bMatch) Begin
80816>>>>>>>>>                                            If (eArrayType=C_atNone) Begin
80818>>>>>>>>>                                                // if not defined as an array (but it is) we bump in one more level.
80818>>>>>>>>>                                                Move ArrayChildValueTree to ChildValueTree.Children[iItems]
80819>>>>>>>>>                                            End
80819>>>>>>>>>>
80819>>>>>>>>>                                            Else Begin
80820>>>>>>>>>                                                // if one of the atArray types, update ValueTree directly (the bump in level has already happened)
80820>>>>>>>>>                                                // I don't think this is possible
80820>>>>>>>>>                                                Move ArrayChildValueTree to ValueTree.Children[iItems]
80821>>>>>>>>>                                            End
80821>>>>>>>>>>
80821>>>>>>>>>                
80821>>>>>>>>>                                            Increment iItems
80822>>>>>>>>>                                            
80822>>>>>>>>>                                            // Note: hoChildNode will end up pointing the next node to be processed. No need for NextNonCommentNode
80822>>>>>>>>>                                                
80822>>>>>>>>>                                        End
80822>>>>>>>>>>
80822>>>>>>>>>                                    Until (iError or hoChildNode=0 or not(bMatch))
80824>>>>>>>>>                                End
80824>>>>>>>>>>
80824>>>>>>>>>                                // a non-choice array
80824>>>>>>>>>                                Else Begin
80825>>>>>>>>>            
80825>>>>>>>>>                                    // if Rpc it's a soap enc array -  we allow anything through (and we will assume the node is an element).
80825>>>>>>>>>                                    While (iError=0 and hoChildNode and (bRpc or IsElementNS(hoChildNode, ChildSoapParamDef.sNamespace, ChildSoapParamDef.sName)))
80829>>>>>>>>>                                        Get XMLToValueTree ChildSoapParamDef hoChildNode (&iError) to ArrayChildValueTree
80830>>>>>>>>>                                        If (iError=0) Begin
80832>>>>>>>>>                                            If (eArrayType=C_atNone) Begin
80834>>>>>>>>>                                                // if not defined as an array (but it is) we bump in one more level.
80834>>>>>>>>>                                                Move ArrayChildValueTree to ChildValueTree.Children[iItems]
80835>>>>>>>>>                                            End
80835>>>>>>>>>>
80835>>>>>>>>>                                            Else Begin
80836>>>>>>>>>                                                // if one of the atArray types, update ValueTree directly (the bump in level has already happened)
80836>>>>>>>>>                                                Move ArrayChildValueTree to ValueTree.Children[iItems]
80837>>>>>>>>>                                            End
80837>>>>>>>>>>
80837>>>>>>>>>                
80837>>>>>>>>>                                            Increment iItems
80838>>>>>>>>>                                            Get NextNonCommentNode hoChildNode to hoChildNode
80839>>>>>>>>>                                        End
80839>>>>>>>>>>
80839>>>>>>>>>                                    End
80840>>>>>>>>>>
80840>>>>>>>>>                                End
80840>>>>>>>>>>
80840>>>>>>>>>                            End
80840>>>>>>>>>>
80840>>>>>>>>>                            
80840>>>>>>>>>                            // a struct - either all or sequence
80840>>>>>>>>>                            
80840>>>>>>>>>                            Else Begin
80841>>>>>>>>>            
80841>>>>>>>>>                                // If a struct with <all> schema. We must search for nodes in any order.
80841>>>>>>>>>                                If (bIsAll) Begin
80843>>>>>>>>>                                    Get ChildElementNS of hoDataNode (If(bRpc,"", ChildSoapParamDef.sNamespace)) (ChildSoapParamDef.sName) to hoChildNode
80844>>>>>>>>>                                    If hoChildNode Begin
80846>>>>>>>>>                                        Get XMLToValueTree ChildSoapParamDef hoChildNode (&iError) to ChildValueTree
80847>>>>>>>>>                                        Send Destroy of hoChildNode
80848>>>>>>>>>                                        Move 0 to hoChildNode
80849>>>>>>>>>                                    End
80849>>>>>>>>>>
80849>>>>>>>>>                                    // if not match and min is 0, assume this is a min zero case and create empty value
80849>>>>>>>>>                                    Else If (ChildSoapParamDef.iMin=0) Begin
80852>>>>>>>>>                                       // a iMin=0 with no items. We may want to mark this as null
80852>>>>>>>>>                                       Get CreateNullValueTree ChildSoapParamDef to ChildValueTree
80853>>>>>>>>>                                    End
80853>>>>>>>>>>
80853>>>>>>>>>                                    Else Begin
80854>>>>>>>>>                                        // data does not match what we are expecting
80854>>>>>>>>>                                        Move wssInvalidDataForType to iError
80855>>>>>>>>>                                    End
80855>>>>>>>>>>
80855>>>>>>>>>                                End
80855>>>>>>>>>>
80855>>>>>>>>>                                // If a <sequence> struct see if it matches what we are expecting in the order we are exepcting.
80855>>>>>>>>>                                // If not, and it's either a min 0 or an error
80855>>>>>>>>>                                Else Begin
80856>>>>>>>>>                                    If (ChildSoapParamDef.bAttribute) Begin
80858>>>>>>>>>                                        Get XMLToValueTree ChildSoapParamDef hoDataNode (&iError) to ChildValueTree
80859>>>>>>>>>                                    End
80859>>>>>>>>>>
80859>>>>>>>>>                                    Else If (ChildSoapParamDef.hoStruct and (pbChoice(ChildSoapParamDef.hoStruct) )) Begin
80862>>>>>>>>>                                        // Note that this can be called with no childnode at all, which is legal when there is no choice and it is at the end.
80862>>>>>>>>>                                        // hoChildNode will end up pointing the next node to be processed. No need for NextNonCommentNode
80862>>>>>>>>>                                        // We don't do anything with bMatch, which is needed for array of choices which is handled above
80862>>>>>>>>>                                        Get XMLChoiceToValueTree ChildSoapParamDef (&hoChildNode) (&iError)  (&bMatch) to ChildValueTree
80863>>>>>>>>>                                    End
80863>>>>>>>>>>
80863>>>>>>>>>// 18.1 - this was wrong and I am not sure why I was testing for simple-content and ignoring the node name when detecting
80863>>>>>>>>>// this. This would cause minOccurs=0 nodes to fail and for things to get out of synch. This should have been an issue since
80863>>>>>>>>>// simple content (simple element type with attributes) was introduced in 15.1. 
80863>>>>>>>>>//                                    Else If (hoChildNode and ;
80863>>>>>>>>>//                                              (IsElementNS(hoChildNode, If(bRpc,"", ChildSoapParamDef.sNamespace), ChildSoapParamDef.sName)) or ;
80863>>>>>>>>>//                                               (ChildSoapParamDef.hoStruct and pbSimpleContent(ChildSoapParamDef.hoStruct)) )  Begin
80863>>>>>>>>>                                    Else If (hoChildNode and ;                                              (IsElementNS(hoChildNode, If(bRpc,"", ChildSoapParamDef.sNamespace), ChildSoapParamDef.sName)) )  Begin
80866>>>>>>>>>                                        Get XMLToValueTree ChildSoapParamDef hoChildNode (&iError) to ChildValueTree
80867>>>>>>>>>                                        If (iError=0) Begin
80869>>>>>>>>>                                            Get NextNonCommentNode hoChildNode to hoChildNode
80870>>>>>>>>>                                        End
80870>>>>>>>>>>
80870>>>>>>>>>                                    End
80870>>>>>>>>>>
80870>>>>>>>>>                                    Else Begin
80871>>>>>>>>>                                        If (ChildSoapParamDef.iMin=0) Begin
80873>>>>>>>>>                                           // a iMin=0 with no items. We may want to mark this as null
80873>>>>>>>>>                                           Get CreateNullValueTree ChildSoapParamDef to ChildValueTree
80874>>>>>>>>>                                        End
80874>>>>>>>>>>
80874>>>>>>>>>                                        Else Begin
80875>>>>>>>>>                                            // data does not match what we are expecting
80875>>>>>>>>>                                            Move wssInvalidDataForType to iError
80876>>>>>>>>>                                        End
80876>>>>>>>>>>
80876>>>>>>>>>                                    End
80876>>>>>>>>>>
80876>>>>>>>>>                                End
80876>>>>>>>>>>
80876>>>>>>>>>                            End
80876>>>>>>>>>>
80876>>>>>>>>>                        End
80876>>>>>>>>>>
80876>>>>>>>>>        
80876>>>>>>>>>                        // if an array type, valueTree.Children is already updated
80876>>>>>>>>>                        If (iError=0 and eArrayType=C_atNone) Begin
80878>>>>>>>>>                            Move ChildValueTree to ValueTree.Children[i]
80879>>>>>>>>>                        End
80879>>>>>>>>>>
80879>>>>>>>>>        
80879>>>>>>>>>                        If (iError<>0) Move iChildren to i // if an error drop out of for loop
80882>>>>>>>>>                    Loop
80883>>>>>>>>>>
80883>>>>>>>>>        
80883>>>>>>>>>                    If hoChildNode Begin
80885>>>>>>>>>                        Send Destroy of hoChildNode
80886>>>>>>>>>                    End
80886>>>>>>>>>>
80886>>>>>>>>>                End
80886>>>>>>>>>>
80886>>>>>>>>>            End
80886>>>>>>>>>>
80886>>>>>>>>>        End
80886>>>>>>>>>>
80886>>>>>>>>>        // if href node, we've created an additional node which must be removed
80886>>>>>>>>>        If bNodeIsHRef Begin
80888>>>>>>>>>            Send Destroy of hoDataNode
80889>>>>>>>>>        End
80889>>>>>>>>>>
80889>>>>>>>>>
80889>>>>>>>>>        Function_Return ValueTree
80890>>>>>>>>>    End_Function
80891>>>>>>>>>    
80891>>>>>>>>>
80891>>>>>>>>>    // this is called when the choice item is a <sequence> rather than an <element>
80891>>>>>>>>>    Function XMLChoiceSequenceToValueTree tSoapParamDef SoapParamDef Handle ByRef hoChildNode Integer ByRef iError Returns tValueTreeEx
80893>>>>>>>>>        Integer iChildren i iItems
80893>>>>>>>>>        Boolean bMatch
80893>>>>>>>>>        tValueTreeEx ChildValueTree ValueTree EmptyValueTree ArrayChildValueTree
80893>>>>>>>>>        tValueTreeEx ChildValueTree ValueTree EmptyValueTree ArrayChildValueTree
80893>>>>>>>>>        tSoapParamDef ChildSoapParamDef
80893>>>>>>>>>        tSoapParamDef ChildSoapParamDef
80893>>>>>>>>>        tSoapParamDef[] SoapParamDefs 
80893>>>>>>>>>        tSoapParamDef[] SoapParamDefs 
80894>>>>>>>>>        
80894>>>>>>>>>        // let's make sure this is the proper soapparam def for this. if not, programming error
80894>>>>>>>>>        If (not(pbChoiceSequenceStruct(SoapParamDef.hoStruct))) Begin
80896>>>>>>>>>            Error DFERR_PROGRAM "Assert: SoapParamDef is not a valid sequence struct"           
80897>>>>>>>>>>
80897>>>>>>>>>        End
80897>>>>>>>>>>
80897>>>>>>>>>        
80897>>>>>>>>>        // SoapParamDef represent a <choice><sequence> struct and hoChildNode is the first node
80897>>>>>>>>>        // in the sequence. We parse this as if it is a normal complexType sequence struct with the
80897>>>>>>>>>        // main difference being we must return pointing to the next child node.
80897>>>>>>>>>        
80897>>>>>>>>>        Get pSoapParamDefs   of SoapParamDef.hoStruct to SoapParamDefs // get struct params
80898>>>>>>>>>        Move (SizeofArray(SoapParamDefs)) to iChildren
80899>>>>>>>>>        For i from 0 to (iChildren-1)
80905>>>>>>>>>>
80905>>>>>>>>>            
80905>>>>>>>>>            Move EmptyValueTree to ChildValueTree
80906>>>>>>>>>            
80906>>>>>>>>>            Move SoapParamDefs[i]  to ChildSoapParamDef
80907>>>>>>>>>    
80907>>>>>>>>>            If (ChildSoapParamDef.iMax>1 or ChildSoapParamDef.iMax=C_Unbounded) Begin
80909>>>>>>>>>    
80909>>>>>>>>>                // if an array we go in one more level of the value tree and handle all array items for the one childSoapParamDef
80909>>>>>>>>>                // there are two types of arrays at this point. This occurs when a struct member minoccurs>1
80909>>>>>>>>>                Move 0 to iItems
80910>>>>>>>>>                
80910>>>>>>>>>                // handling for array of choices.
80910>>>>>>>>>                If (ChildSoapParamDef.hoStruct and (pbChoice(ChildSoapParamDef.hoStruct) )) Begin
80912>>>>>>>>>                    // we need to keep looking at child nodes to see if they are one of the valid choices. If they are
80912>>>>>>>>>                    // we will add another choice array. 
80912>>>>>>>>>                    Repeat 
80912>>>>>>>>>>
80912>>>>>>>>>                        // Note that this can be called with no childnode at all, which is legal when there is no more struct members.
80912>>>>>>>>>                        // hoChildNode will return pointing to the next non-choice node.
80912>>>>>>>>>                        // bMatch will be True if a choice element was processed. This is how we know when we are done. 
80912>>>>>>>>>                        // Note that an empty array of choices is always allowed.
80912>>>>>>>>>                        Get XMLChoiceToValueTree ChildSoapParamDef (&hoChildNode) (&iError) (&bMatch) to ArrayChildValueTree
80913>>>>>>>>>                        // only add an array choice item if there is an actual match
80913>>>>>>>>>                        If (iError=0 and bMatch) Begin
80915>>>>>>>>>                            Move ArrayChildValueTree to ChildValueTree.Children[iItems]
80916>>>>>>>>>                            Increment iItems
80917>>>>>>>>>                            // Note: hoChildNode will end up pointing the next node to be processed. No need for NextNonCommentNode
80917>>>>>>>>>                        End
80917>>>>>>>>>>
80917>>>>>>>>>                    Until (iError or hoChildNode=0 or not(bMatch))
80919>>>>>>>>>                End
80919>>>>>>>>>>
80919>>>>>>>>>                // a non-choice array
80919>>>>>>>>>                Else Begin
80920>>>>>>>>>                    While (iError=0 and hoChildNode and (IsElementNS(hoChildNode, ChildSoapParamDef.sNamespace, ChildSoapParamDef.sName)))
80924>>>>>>>>>                        Get XMLToValueTree ChildSoapParamDef hoChildNode (&iError) to ArrayChildValueTree
80925>>>>>>>>>                        If (iError=0) Begin
80927>>>>>>>>>                            // if not defined as an array (but it is) we bump in one more level.
80927>>>>>>>>>                            Move ArrayChildValueTree to ChildValueTree.Children[iItems]
80928>>>>>>>>>                            Increment iItems
80929>>>>>>>>>                            Get NextNonCommentNode hoChildNode to hoChildNode
80930>>>>>>>>>                        End
80930>>>>>>>>>>
80930>>>>>>>>>                    End
80931>>>>>>>>>>
80931>>>>>>>>>                End
80931>>>>>>>>>>
80931>>>>>>>>>            End
80931>>>>>>>>>>
80931>>>>>>>>>            // non-array item
80931>>>>>>>>>            Else Begin
80932>>>>>>>>>                // a choice (nested with a choice)
80932>>>>>>>>>                If (ChildSoapParamDef.hoStruct and (pbChoice(ChildSoapParamDef.hoStruct) )) Begin
80934>>>>>>>>>                    // Note that this can be called with no childnode at all, which is legal when there is no choice and it is at the end.
80934>>>>>>>>>                    // hoChildNode will end up pointing the next node to be processed. No need for NextNonCommentNode
80934>>>>>>>>>                    // We don't do anything with bMatch, which is needed for array of choices which is handled above
80934>>>>>>>>>                    Get XMLChoiceToValueTree ChildSoapParamDef (&hoChildNode) (&iError)  (&bMatch) to ChildValueTree
80935>>>>>>>>>                End
80935>>>>>>>>>>
80935>>>>>>>>>                // a matching element
80935>>>>>>>>>// 18.1 - See similar code in XmlToValueTree for comment
80935>>>>>>>>>//                Else If (hoChildNode and ;
80935>>>>>>>>>//                          (IsElementNS(hoChildNode, ChildSoapParamDef.sNamespace, ChildSoapParamDef.sName)) or ;
80935>>>>>>>>>//                           (ChildSoapParamDef.hoStruct and pbSimpleContent(ChildSoapParamDef.hoStruct)) )  Begin
80935>>>>>>>>>                Else If (hoChildNode and ;                          (IsElementNS(hoChildNode, ChildSoapParamDef.sNamespace, ChildSoapParamDef.sName)) )  Begin
80938>>>>>>>>>                    Get XMLToValueTree ChildSoapParamDef hoChildNode (&iError) to ChildValueTree
80939>>>>>>>>>                    If (iError=0) Begin
80941>>>>>>>>>                        Get NextNonCommentNode hoChildNode to hoChildNode
80942>>>>>>>>>                    End
80942>>>>>>>>>>
80942>>>>>>>>>                End
80942>>>>>>>>>>
80942>>>>>>>>>                // no match. If min occurs=0 that's ok keep lookinh, else an error
80942>>>>>>>>>                Else Begin
80943>>>>>>>>>                    If (ChildSoapParamDef.iMin=0) Begin
80945>>>>>>>>>                       // a iMin=0 with no items. We may want to mark this as null
80945>>>>>>>>>                       Get CreateNullValueTree ChildSoapParamDef to ChildValueTree
80946>>>>>>>>>                    End
80946>>>>>>>>>>
80946>>>>>>>>>                    Else Begin
80947>>>>>>>>>                        // data does not match what we are expecting
80947>>>>>>>>>                        Move wssInvalidDataForType to iError
80948>>>>>>>>>                    End
80948>>>>>>>>>>
80948>>>>>>>>>                End
80948>>>>>>>>>>
80948>>>>>>>>>            End
80948>>>>>>>>>>
80948>>>>>>>>>    
80948>>>>>>>>>            If (iError=0) Begin
80950>>>>>>>>>                Move ChildValueTree to ValueTree.Children[i]
80951>>>>>>>>>            End
80951>>>>>>>>>>
80951>>>>>>>>>    
80951>>>>>>>>>            If (iError<>0) Move iChildren to i // if an error drop out of for loop
80954>>>>>>>>>        Loop
80955>>>>>>>>>>
80955>>>>>>>>>        
80955>>>>>>>>>        Function_Return ValueTree
80956>>>>>>>>>    
80956>>>>>>>>>    End_Function
80957>>>>>>>>>    
80957>>>>>>>>>    
80957>>>>>>>>>    // this is called to handle a <choice> xml value to the value tree. Passing an empty Node is allowed as this might be a minOccurs choice.
80957>>>>>>>>>    // This will change hoNode to point to the next node to be used for processing. This is needed because we may process multiple nodes here (arrays).
80957>>>>>>>>>    // The bMatch parameter indicates if a one or more matches was found (multiple possible with arrays).
80957>>>>>>>>>    Function XMLChoiceToValueTree tSoapParamDef SoapParamDef Handle ByRef hoNode Integer ByRef iError Boolean ByRef bMatch Returns tValueTreeEx
80959>>>>>>>>>        Handle     hoChildNode hoDataNode
80959>>>>>>>>>        Integer    iChildren iChoiceIndex iMatch iType iArrayItems
80959>>>>>>>>>        String     sValue sNs sBaseName
80959>>>>>>>>>        Boolean    bRpc bChoice 
80959>>>>>>>>>        tSoapParamDef  ChildSoapParamDef
80959>>>>>>>>>        tSoapParamDef  ChildSoapParamDef
80959>>>>>>>>>        tSoapParamDef[] SoapParamDefs
80959>>>>>>>>>        tSoapParamDef[] SoapParamDefs
80960>>>>>>>>>        tValueTreeEx ValueTree ChildValueTree EmptyValueTree ArrayChildValueTree 
80960>>>>>>>>>        tValueTreeEx ValueTree ChildValueTree EmptyValueTree ArrayChildValueTree 
80960>>>>>>>>>        Boolean bChoiceSequenceStruct bTest
80960>>>>>>>>>        tSoapParamDef[] ChildSoapParamDefs
80960>>>>>>>>>        tSoapParamDef[] ChildSoapParamDefs
80961>>>>>>>>>        Integer iChildDefs iChildDef
80961>>>>>>>>>        
80961>>>>>>>>>        Move False to bMatch // this will be set true if we find a choice match
80962>>>>>>>>>
80962>>>>>>>>>        Move (peSoapStyle(Self)=ssRpc) to bRpc
80963>>>>>>>>>
80963>>>>>>>>>        // test this is called properly 
80963>>>>>>>>>        
80963>>>>>>>>>        Get pbChoice of SoapParamDef.hoStruct to bChoice
80964>>>>>>>>>        Get pSoapParamDefs  of SoapParamDef.hoStruct to SoapParamDefs // get struct object params
80965>>>>>>>>>        Move (SizeofArray(SoapParamDefs)) to iChildren
80966>>>>>>>>>        If (not(bChoice) or (iChildren=0)) Begin
80968>>>>>>>>>            Error DFERR_PROGRAM "XMLChoiceToValueTree called in wrong state"
80969>>>>>>>>>>
80969>>>>>>>>>            Move wssInvalidDataForType to iError
80970>>>>>>>>>            Function_Return ValueTree
80971>>>>>>>>>        End
80971>>>>>>>>>>
80971>>>>>>>>>        If hoNode Begin
80973>>>>>>>>>            Get piNodeType of hoNode to iType
80974>>>>>>>>>            If (iType<>NODE_ELEMENT) Begin
80976>>>>>>>>>                Error DFERR_PROGRAM "XMLChoiceToValueTree called in wrong state"
80977>>>>>>>>>>
80977>>>>>>>>>                Move wssInvalidDataForType to iError
80978>>>>>>>>>                Function_Return ValueTree
80979>>>>>>>>>            End
80979>>>>>>>>>>
80979>>>>>>>>>        End
80979>>>>>>>>>>
80979>>>>>>>>>        
80979>>>>>>>>>        // if choice, this is node represents a choice constant member followed by a member for each choice
80979>>>>>>>>>        //
80979>>>>>>>>>        // so xml is 
80979>>>>>>>>>        //
80979>>>>>>>>>        //    <m:FooEle1>Value1<mFooEle1/>
80979>>>>>>>>>        //    <m:FooEle2Choice2>Value2<m:FooEle2Choice2/>
80979>>>>>>>>>        //    <m:FooEle3>Value3<mFooEle3/>
80979>>>>>>>>>        //
80979>>>>>>>>>        // the value tree will be:
80979>>>>>>>>>        //
80979>>>>>>>>>        // ValueTree[x].Children 
80979>>>>>>>>>        //   ValueTree[0].sValue = Value1
80979>>>>>>>>>        //   ValueTree[1].Children       
80979>>>>>>>>>        //        ValueTree[0].eChoice = 1 <---- indicates the second choice
80979>>>>>>>>>        //        ValueTree[1]             <-- empty
80979>>>>>>>>>        //        ValueTree[2].sValue = Value2
80979>>>>>>>>>        //   ValueTree[2].sValue = Value3
80979>>>>>>>>>        //
80979>>>>>>>>>        // Even if there is no choice (minOccurs=0) we must full the valuetree with empty values. In that case eChoice will be -1
80979>>>>>>>>>        //
80979>>>>>>>>>        // If the choice elemnt is an array, you might have something like this:
80979>>>>>>>>>        //
80979>>>>>>>>>        //    <m:FooEle1>Value1<mFooEle1/>
80979>>>>>>>>>        //    <m:FooEle2Choice2>Value2.0<m:FooEle2Choice2/>
80979>>>>>>>>>        //    <m:FooEle2Choice2>Value2.1<m:FooEle2Choice2/>
80979>>>>>>>>>        //    <m:FooEle2Choice2>Value2.2<m:FooEle2Choice2/>
80979>>>>>>>>>        //    <m:FooEle3>Value3<mFooEle3/>
80979>>>>>>>>>        //
80979>>>>>>>>>        // the value tree will be:
80979>>>>>>>>>        //
80979>>>>>>>>>        // ValueTree[x].Children 
80979>>>>>>>>>        //   ValueTree[0].sValue = Value1
80979>>>>>>>>>        //   ValueTree[1].Children       
80979>>>>>>>>>        //        ValueTree[0].eChoice = 1 <---- indicates the second choice
80979>>>>>>>>>        //        ValueTree[1]             <-- empty
80979>>>>>>>>>        //        ValueTree[2].Children
80979>>>>>>>>>        //            ValueTree[0].sValue = Value2.0
80979>>>>>>>>>        //            ValueTree[1].sValue = Value2.1
80979>>>>>>>>>        //            ValueTree[2].sValue = Value2.2
80979>>>>>>>>>        //   ValueTree[2].sValue = Value3
80979>>>>>>>>>        //
80979>>>>>>>>>        // when this function is called, hoNode will point to the first choice e.g., <m:FooEle2Choice2>Value2<m:FooEle2Choice2/>
80979>>>>>>>>>        // when done it will point to the next element following the choice e.g.,    <m:FooEle3>Value3<mFooEle3/>  
80979>>>>>>>>>
80979>>>>>>>>>        If hoNode Begin
80981>>>>>>>>>            // if we have a node, see if this node matches any of the choices
80981>>>>>>>>>            Get psNamespaceURI of hoNode to sNs
80982>>>>>>>>>            If bRpc Begin
80984>>>>>>>>>                Move '' to sNs
80985>>>>>>>>>            End
80985>>>>>>>>>>
80985>>>>>>>>>            Get psBaseName of hoNode to sBaseName
80986>>>>>>>>>            Move 0 to iChoiceIndex
80987>>>>>>>>>            While (not(bMatch) and (iChoiceIndex < iChildren-1) )
80991>>>>>>>>>                Increment iChoiceIndex // test from 1 (skipping the first paramdef which is eChoice)
80992>>>>>>>>>
80992>>>>>>>>>                
80992>>>>>>>>>                Move False to bChoiceSequenceStruct
80993>>>>>>>>>                If (SoapParamDefs[iChoiceIndex].hoStruct) Begin
80995>>>>>>>>>                    Get pbChoiceSequenceStruct of SoapParamDefs[iChoiceIndex].hoStruct to bChoiceSequenceStruct
80996>>>>>>>>>                End
80996>>>>>>>>>>
80996>>>>>>>>>                
80996>>>>>>>>>                If bChoiceSequenceStruct Begin
80998>>>>>>>>>                   // if a <choice><sequence> item it is a more complicated because we need to search one level in
80998>>>>>>>>>                   // and we need to handle minOccurs=0 where an element might be skipped.
80998>>>>>>>>>                   // Go in one level as these are the <element> items we must test
80998>>>>>>>>>                   Get pSoapParamDefs of SoapParamDefs[iChoiceIndex].hoStruct to ChildSoapParamDefs
80999>>>>>>>>>                   Move (SizeOfArray(ChildSoapParamDefs)) to iChildDefs
81000>>>>>>>>>                   Move 0 to iChildDef
81001>>>>>>>>>                   Move True to bTest
81002>>>>>>>>>                   While (iChildDef<iChildDefs and bTest)
81006>>>>>>>>>                       Move (sNs=ChildSoapParamDefs[iChildDef].sNamespace and sBaseName=ChildSoapParamDefs[iChildDef].sName) to bMatch
81007>>>>>>>>>                       // if we have a match we are done. If no match and it is minOccurs=0, keep looking
81007>>>>>>>>>                       If (bMatch or ChildSoapParamDefs[iChildDef].iMin=1) Begin
81009>>>>>>>>>                           Move False to bTest
81010>>>>>>>>>                       End
81010>>>>>>>>>>
81010>>>>>>>>>                       Increment iChildDef
81011>>>>>>>>>                   Loop
81012>>>>>>>>>>
81012>>>>>>>>>                End
81012>>>>>>>>>>
81012>>>>>>>>>                Else Begin
81013>>>>>>>>>                    // this is the simple test case of a <choice><element> item
81013>>>>>>>>>                    Move (sNs=SoapParamDefs[iChoiceIndex].sNamespace and sBaseName=SoapParamDefs[iChoiceIndex].sName) to bMatch
81014>>>>>>>>>                End
81014>>>>>>>>>>
81014>>>>>>>>>            Loop
81015>>>>>>>>>>
81015>>>>>>>>>            Move (If(bMatch,iChoiceIndex-1,C_ChoiceStructNone)) to iMatch // no match is possible. Nothing was passed
81016>>>>>>>>>        End 
81016>>>>>>>>>>
81016>>>>>>>>>        Else Begin
81017>>>>>>>>>            // if no node, no match. Although the schema may not allow this, we will allow it as we can handle it.
81017>>>>>>>>>            Move False to bMatch
81018>>>>>>>>>            Move C_ChoiceStructNone to iMatch
81019>>>>>>>>>        End
81019>>>>>>>>>>
81019>>>>>>>>>            
81019>>>>>>>>>        
81019>>>>>>>>>        // update all value tree child values
81019>>>>>>>>>        // at this point we have iMatch and bChoiceSequenceStruct to work with
81019>>>>>>>>>
81019>>>>>>>>>        // the choice goes in 0, if no match it is -1
81019>>>>>>>>>        Move EmptyValueTree to ChildValueTree
81020>>>>>>>>>        Move iMatch to ChildValueTree.sValue
81021>>>>>>>>>        // update the first value tree child node with the element
81021>>>>>>>>>        Move ChildValueTree to ValueTree.Children[0]
81022>>>>>>>>>        
81022>>>>>>>>>        For iChoiceIndex from 1 to (iChildren-1)
81028>>>>>>>>>>
81028>>>>>>>>>            Move EmptyValueTree to ChildValueTree
81029>>>>>>>>>            
81029>>>>>>>>>            If ((iMatch+1=iChoiceIndex) and hoNode) Begin
81031>>>>>>>>>                Move SoapParamDefs[iChoiceIndex]  to ChildSoapParamDef
81032>>>>>>>>>                
81032>>>>>>>>>                // choice is a sequence of elements - requires special handling
81032>>>>>>>>>                // note in the above array case, the array cannpt be a bChoiceSequenceStruct
81032>>>>>>>>>                If bChoiceSequenceStruct Begin
81034>>>>>>>>>                    // note: hoNode must end up pointing to the next node 
81034>>>>>>>>>                    Get XMLChoiceSequenceToValueTree ChildSoapParamDef (&hoNode) (&iError) to ChildValueTree
81035>>>>>>>>>                End
81035>>>>>>>>>>
81035>>>>>>>>>                // if this choice is an array, process this node and all succeeding nodes that are of the same
81035>>>>>>>>>                // element as an array. ChildValueTree will be an array node
81035>>>>>>>>>                Else If (ChildSoapParamDef.iMax>1 or ChildSoapParamDef.iMax=C_Unbounded) Begin
81038>>>>>>>>>                    Move 0 to iArrayItems
81039>>>>>>>>>                    While (iError=0 and hoNode and (IsElementNS(hoNode, ChildSoapParamDef.sNamespace, ChildSoapParamDef.sName)))
81043>>>>>>>>>                        Get XMLToValueTree ChildSoapParamDef hoNode (&iError) to ArrayChildValueTree
81044>>>>>>>>>                        If (iError=0) Begin
81046>>>>>>>>>                            Move ArrayChildValueTree to ChildValueTree.Children[iArrayItems]
81047>>>>>>>>>                            Increment iArrayItems
81048>>>>>>>>>                            Get NextNonCommentNode hoNode to hoNode
81049>>>>>>>>>                        End
81049>>>>>>>>>>
81049>>>>>>>>>                    End
81050>>>>>>>>>>
81050>>>>>>>>>                End
81050>>>>>>>>>>
81050>>>>>>>>>                // choice is a non-array element. process the one item
81050>>>>>>>>>                Else Begin
81051>>>>>>>>>                    Get XMLToValueTree ChildSoapParamDef hoNode (&iError) to ChildValueTree
81052>>>>>>>>>                    Get NextNonCommentNode hoNode to hoNode // we must leave this with the next node! 
81053>>>>>>>>>                End
81053>>>>>>>>>>
81053>>>>>>>>>            End
81053>>>>>>>>>>
81053>>>>>>>>>            
81053>>>>>>>>>            Move ChildValueTree to ValueTree.Children[iChoiceIndex]
81054>>>>>>>>>        Loop
81055>>>>>>>>>>
81055>>>>>>>>>        // at this point:
81055>>>>>>>>>        //    hoNode (which is returned ByRef) points to the node following the last processed choice
81055>>>>>>>>>        //    iError may contain an error code
81055>>>>>>>>>        //    bMatch is true if a valid choice was found and processed
81055>>>>>>>>>        Function_Return ValueTree // and ValueTree contains the complete data from this one choice
81056>>>>>>>>>    End_Function
81057>>>>>>>>>    
81057>>>>>>>>>
81057>>>>>>>>>
81057>>>>>>>>>    // These obsolete messages are the messages used by the vdf10 class to handle defining parameters and setting values. These are no
81057>>>>>>>>>    // longer used in VDF11 and when a class is generated (or regenerated) they will go away. These interfaces are provided here to allow
81057>>>>>>>>>    // old VDF10 clients to work with this class. They only work with vdf10 style simple data (no structs/arrays). These messages simply
81057>>>>>>>>>    // redirect to the newer interface. Note that you can not mix old and new interfaces within a single class.
81057>>>>>>>>>    Procedure DefineParameter Integer iParameterNumber Integer eType String sName String sSchemaType
81059>>>>>>>>>        tSoapParameter[] spParameters
81059>>>>>>>>>        tSoapParameter[] spParameters
81060>>>>>>>>>        Get pspParameters to spParameters
81061>>>>>>>>>        Get DefineParameter eType 1 1 sName (psRequestNSURI(Self)) to spParameters[iParameterNumber].SoapParamDef
81062>>>>>>>>>        Set pspParameters to spParameters
81063>>>>>>>>>    End_Procedure
81064>>>>>>>>>
81064>>>>>>>>>    Procedure DefineReturn Integer eType String sname String sSchemaType
81066>>>>>>>>>        tSoapParameter[]   spReturnParameters
81066>>>>>>>>>        tSoapParameter[]   spReturnParameters
81067>>>>>>>>>        Get pspReturnParameters to spReturnParameters
81068>>>>>>>>>        Get DefineParameter eType 1 1 sName (psRequestNSURI(Self)) to spReturnParameters[0].SoapParamDef
81069>>>>>>>>>        Set pspReturnParameters to spReturnParameters
81070>>>>>>>>>    End_Procedure
81071>>>>>>>>>
81071>>>>>>>>>    Procedure AddParameter Integer iParameterNumber String sValue // sValue can by any type
81073>>>>>>>>>        tSoapParameter[] spParameters
81073>>>>>>>>>        tSoapParameter[] spParameters
81074>>>>>>>>>        Integer eType
81074>>>>>>>>>        Get pspParameters to spParameters
81075>>>>>>>>>        Move spParameters[iParameterNumber].SoapParamDef.eType to eType
81076>>>>>>>>>        If (eType<>xsAnyType and eType<>xsXmlElement) Begin
81078>>>>>>>>>            ConvertToXml eType sValue to sValue
81079>>>>>>>>>        End
81079>>>>>>>>>>
81079>>>>>>>>>        Move sValue to spParameters[iParameterNumber].ValueTree.sValue
81080>>>>>>>>>        Set pspParameters to spParameters
81081>>>>>>>>>    End_Procedure
81082>>>>>>>>>
81082>>>>>>>>>    Function ReturnValue Returns String // return can be any value based on type
81084>>>>>>>>>         tSoapParameter[]   spReturnParameters
81084>>>>>>>>>         tSoapParameter[]   spReturnParameters
81085>>>>>>>>>         String sValue
81085>>>>>>>>>         Integer eType iSize
81085>>>>>>>>>         Get pspReturnParameters   to spReturnParameters
81086>>>>>>>>>         If (SizeOfArray(spReturnParameters)>0) Begin
81088>>>>>>>>>             Move spReturnParameters[0].SoapParamDef.eType to eType
81089>>>>>>>>>             Move spReturnParameters[0].ValueTree.sValue to sValue
81090>>>>>>>>>             If (eType<>xsAnyType and eType<>xsXmlElement) Begin
81092>>>>>>>>>                 ConvertFromXml eType sValue to sValue
81093>>>>>>>>>             End
81093>>>>>>>>>>
81093>>>>>>>>>         End
81093>>>>>>>>>>
81093>>>>>>>>>         Function_Return sValue
81094>>>>>>>>>    End_Function
81095>>>>>>>>>
81095>>>>>>>>>    // useful in testing
81095>>>>>>>>>    Procedure ShowValueTree tValueTreeEx V Integer iLevel
81097>>>>>>>>>        Integer iLev i iC
81097>>>>>>>>>        If (num_arguments<=1) Move 0 to iLev
81100>>>>>>>>>        Else Move iLevel to iLev
81102>>>>>>>>>        Showln (String(iLev) + ":" +  Repeat(" ",iLev*2)+"["+V.sValue+"]")
81104>>>>>>>>>        //writeln (string(iLev) + ":" +  repeat(" ",iLev*2)+V.sValue)
81104>>>>>>>>>        Move (SizeOfArray(V.Children)) to iC
81105>>>>>>>>>        Increment iLev
81106>>>>>>>>>        For i from 0 to (iC-1)
81112>>>>>>>>>>
81112>>>>>>>>>            Send ShowValueTree v.children[i] iLev
81113>>>>>>>>>        Loop
81114>>>>>>>>>>
81114>>>>>>>>>    End_Procedure
81115>>>>>>>>>    
81115>>>>>>>>>  
81115>>>>>>>>>    // do a XML node to variant string conversion. Note this returns a Unicode string
81115>>>>>>>>>    Function XMLNodetoXmlVariantBStr Handle hoNode Integer ByRef iError Returns Variant
81117>>>>>>>>>        Variant vXML
81117>>>>>>>>>        Get pvXML of hoNode to vXML
81118>>>>>>>>>        Function_Return vXML
81119>>>>>>>>>    End_Function
81120>>>>>>>>>
81120>>>>>>>>>    // this adds an xsAnyTypeStr or xsXmlElementStr, which is an XML node serialized as a variant BString, to the valuetree.
81120>>>>>>>>>    // If xsAnyTypeStr, the value should be the entire serialized XML node (wrapper and data) and it is up to the developer to get this right.
81120>>>>>>>>>    // If xsXmlElementStr, we will provide the wrapper and the data can be a single XML element or an array of XML elements.
81120>>>>>>>>>    // if xsBase64Binary, we will just provide the data node
81120>>>>>>>>>
81120>>>>>>>>>    Function XMLVariantBStrToValueTree tSoapParamDef SoapParamDef Handle hoNode Integer ByRef iError Returns tValueTreeEx
81122>>>>>>>>>        Handle hoChildNode
81122>>>>>>>>>        tValueTreeEx ValueTree
81122>>>>>>>>>        tValueTreeEx ValueTree
81122>>>>>>>>>        String sXML
81122>>>>>>>>>        Variant vXML
81122>>>>>>>>>        Integer iCount
81122>>>>>>>>>
81122>>>>>>>>>        // if any-type we use the entire parameter including the wrapper. This is the "give me the whole thing mode"
81122>>>>>>>>>        If (SoapParamDef.eType=xsAnyTypeStr) Begin
81124>>>>>>>>>            Get XMLNodetoXmlVariantBStr hoNode (&iError) to  vXML
81125>>>>>>>>>            Move vXML to ValueTree.sValue // return ob is an handle to a desktop XML object
81126>>>>>>>>>        End
81126>>>>>>>>>>
81126>>>>>>>>>        Else If (SoapParamDef.eType=xsXmlElementStr)Begin // if xsXmlElementStr
81129>>>>>>>>>            Get FirstNonCommentChild hoNode to hoChildNode
81130>>>>>>>>>            If hoChildNode Begin
81132>>>>>>>>>                // can be a single node or an array of nodes
81132>>>>>>>>>                If (SoapParamDef.iMax=1) Begin
81134>>>>>>>>>                    // return as a single element
81134>>>>>>>>>                    Get XMLNodetoXmlVariantBStr hoChildNode (&iError) to  vXML
81135>>>>>>>>>                    Move vXML to ValueTree.sValue // return ob is an handle to a desktop XML object
81136>>>>>>>>>                    Send Destroy of hoChildNode
81137>>>>>>>>>                End
81137>>>>>>>>>>
81137>>>>>>>>>                Else Begin
81138>>>>>>>>>                    // return as an array of elements
81138>>>>>>>>>                    While hoChildNode
81142>>>>>>>>>                        Get XMLNodetoXmlVariantBStr hoChildNode (&iError) to  vXML
81143>>>>>>>>>                        Move vXML to ValueTree.children[iCount].sValue
81144>>>>>>>>>                        If (iError=0) Begin
81146>>>>>>>>>                            Increment iCount
81147>>>>>>>>>                            Get NextNonCommentNode hoChildNode to hoChildNode
81148>>>>>>>>>                        End
81148>>>>>>>>>>
81148>>>>>>>>>                        Else Begin
81149>>>>>>>>>                            Send Destroy of hoChildNode
81150>>>>>>>>>                            Move 0 to hoChildNode                           
81151>>>>>>>>>                        End
81151>>>>>>>>>>
81151>>>>>>>>>                    Loop
81152>>>>>>>>>>
81152>>>>>>>>>                End
81152>>>>>>>>>>
81152>>>>>>>>>            End
81152>>>>>>>>>>
81152>>>>>>>>>        End
81152>>>>>>>>>>
81152>>>>>>>>>        Else If (SoapParamDef.eType=xsBase64Binary) Begin
81155>>>>>>>>>            Get FirstNonCommentChild hoNode to hoChildNode // this is the base64 encoded text value
81156>>>>>>>>>            If hoChildNode Begin
81158>>>>>>>>>                Get pvNodeValue of hoChildNode to vXML
81159>>>>>>>>>                Move vXML to ValueTree.sValue
81160>>>>>>>>>                Send Destroy of hoChildNode
81161>>>>>>>>>            End
81161>>>>>>>>>>
81161>>>>>>>>>        End
81161>>>>>>>>>>
81161>>>>>>>>>        Else Begin
81162>>>>>>>>>            Error DFERR_PROGRAM "Invalid datatype for XMLVariantBStrToValueTree"
81163>>>>>>>>>>
81163>>>>>>>>>        End
81163>>>>>>>>>>
81163>>>>>>>>>        Function_Return ValueTree
81164>>>>>>>>>    End_Function
81165>>>>>>>>>
81165>>>>>>>>>    // Adds a serialized XML string from teh value tree to the XML param node. This should only be called with the 
81165>>>>>>>>>    // datatype is xsAnyTypeStr or xsXmlElementStr. Mostly xsAnyTypeStr is passed which means that the entire parameter -
81165>>>>>>>>>    // element definition (i.e., wrapper) and data, is passed. This passed xsAnyType parameter must be a single XML mode.
81165>>>>>>>>>    // If xsXmlElementStr is passed then the XML data is added to a wrapper which is created here. The xsXmlElementStr can be a single
81165>>>>>>>>>    // node (maxOccurs=1) or an array of elements (maxOccurs>1).
81165>>>>>>>>>     
81165>>>>>>>>>    Function ValueTreeXmlStrToXml tSoapParamDef SoapParamDef tValueTreeEx ValueTree Handle hoParam Returns Boolean
81167>>>>>>>>>
81167>>>>>>>>>        Handle hoParamChildNode hoDataRoot hoData hoNode
81167>>>>>>>>>        Boolean bRpc bOk
81167>>>>>>>>>        Integer i
81167>>>>>>>>>        
81167>>>>>>>>>
81167>>>>>>>>>        Move (peSoapStyle(Self)=ssRpc) to bRpc
81168>>>>>>>>>
81168>>>>>>>>>        // if anyType, there should be a single node which we add, as is, to the document. With AnyType it doesn't
81168>>>>>>>>>        // matter what the SoapParamDef name and namespace are as they are not used.
81168>>>>>>>>>        // take the xml document we have and add it to the param
81168>>>>>>>>>        
81168>>>>>>>>>        If (SoapParamDef.eType=xsAnyTypeStr) Begin
81170>>>>>>>>>            
81170>>>>>>>>>            If (SizeOfArray(ValueTree.children)<>0) Begin
81172>>>>>>>>>                Error DFERR_PROGRAM ("Could not convert multi element xsAnyTypeStr ValueTree data to maxOccurs=1 XML node")
81173>>>>>>>>>>
81173>>>>>>>>>                Function_Return False
81174>>>>>>>>>            End
81174>>>>>>>>>>
81174>>>>>>>>>            
81174>>>>>>>>>            If (ValueTree.sValue="") Begin
81176>>>>>>>>>                Function_Return True    
81177>>>>>>>>>            End
81177>>>>>>>>>>
81177>>>>>>>>>            
81177>>>>>>>>>            Get Create (RefClass(cXMLDOMDocument)) to hoData
81178>>>>>>>>>            Get LoadXMLFromVariant of hoData ValueTree.sValue to bOk
81179>>>>>>>>>            If Not bOk Begin
81181>>>>>>>>>                Error DFERR_PROGRAM ("Could not convert string to XML node (" - Left(ValueTree.sValue,1000) - ")")
81182>>>>>>>>>>
81182>>>>>>>>>                Send Destroy of hoData
81183>>>>>>>>>                Function_Return False
81184>>>>>>>>>            End
81184>>>>>>>>>>
81184>>>>>>>>>            
81184>>>>>>>>>            Get DocumentElement of hoData to hoDataRoot
81185>>>>>>>>>            // if any, pass as entire param plus wrapper. The wrapper MUST be correct.
81185>>>>>>>>>            Get CloneNode  of hoDataRoot True to hoParamChildNode
81186>>>>>>>>>            Get AppendNode of hoParam hoParamChildNode to hoParamChildNode
81187>>>>>>>>>            Send destroy of hoParamChildNode
81188>>>>>>>>>            Send destroy of hoDataRoot
81189>>>>>>>>>            Send Destroy of hoData
81190>>>>>>>>>        End
81190>>>>>>>>>>
81190>>>>>>>>>        
81190>>>>>>>>>        // if xmlElement, pass the entire document and we add the wrapper as defined in SoapParaDef
81190>>>>>>>>>        
81190>>>>>>>>>        Else If (SoapParamDef.eType=xsXmlElement) Begin
81193>>>>>>>>>            
81193>>>>>>>>>            // if a single element
81193>>>>>>>>>            If (SoapParamDef.iMax=1) Begin        
81195>>>>>>>>>                // test that it is a single node 
81195>>>>>>>>>                If (SizeOfArray(ValueTree.children)<>0) Begin
81197>>>>>>>>>                    Error DFERR_PROGRAM ("Could not convert multi element xsXmlElement ValueTree data to maxOccurs=1 XML node")
81198>>>>>>>>>>
81198>>>>>>>>>                    Function_Return False
81199>>>>>>>>>                End
81199>>>>>>>>>>
81199>>>>>>>>>                
81199>>>>>>>>>                If (ValueTree.sValue="") Begin
81201>>>>>>>>>                    Function_Return True    
81202>>>>>>>>>                End
81202>>>>>>>>>>
81202>>>>>>>>>                
81202>>>>>>>>>                Get Create (RefClass(cXMLDOMDocument)) to hoData
81203>>>>>>>>>                Get LoadXMLFromVariant of hoData ValueTree.sValue to bOk
81204>>>>>>>>>                If not bOk Begin
81206>>>>>>>>>                    Error DFERR_PROGRAM ("Could not convert string to XML node (" - Left(ValueTree.sValue,1000) - ")")
81207>>>>>>>>>>
81207>>>>>>>>>                    Send Destroy of hoData
81208>>>>>>>>>                    Function_Return False
81209>>>>>>>>>                End
81209>>>>>>>>>>
81209>>>>>>>>>                // add the wrapper for this param
81209>>>>>>>>>                Get AddElementNS of hoParam (If(bRpc,"",SoapParamDef.sNamespace)) SoapParamDef.sName '' to hoParamChildNode
81210>>>>>>>>>                // if xmlElement, pass the entire document as a child of the wrapper
81210>>>>>>>>>                Get DocumentElement of hoData to hoDataRoot
81211>>>>>>>>>                Get CloneNode of hoDataRoot True to hoNode
81212>>>>>>>>>                Get AppendNode of hoParamChildNode hoNode to hoNode
81213>>>>>>>>>                Send Destroy of hoNode
81214>>>>>>>>>                Send destroy of hoParamChildNode
81215>>>>>>>>>                Send destroy of hoDataRoot
81216>>>>>>>>>                Send Destroy of hoData
81217>>>>>>>>>            End
81217>>>>>>>>>>
81217>>>>>>>>>            // if an array of elements
81217>>>>>>>>>            Else Begin
81218>>>>>>>>>                
81218>>>>>>>>>                If (SizeOfArray(ValueTree.children)=0) Begin
81220>>>>>>>>>                    Function_Return True                    
81221>>>>>>>>>                End
81221>>>>>>>>>>
81221>>>>>>>>>                
81221>>>>>>>>>                Get AddElementNS of hoParam (If(bRpc,"",SoapParamDef.sNamespace)) SoapParamDef.sName '' to hoParamChildNode
81222>>>>>>>>>                Get Create (RefClass(cXMLDOMDocument)) to hoData
81223>>>>>>>>>                For i from 0 to (SizeOfArray(ValueTree.children)-1)
81229>>>>>>>>>>
81229>>>>>>>>>                    Get LoadXMLFromVariant of hoData ValueTree.children[i].sValue to bOk
81230>>>>>>>>>                    If not bOk Begin
81232>>>>>>>>>                        Error DFERR_PROGRAM ("Could not convert string to XML node (" - Left(ValueTree.children[i].sValue,1000) - ")")
81233>>>>>>>>>>
81233>>>>>>>>>                        Send Destroy of hoData
81234>>>>>>>>>                        Function_Return False
81235>>>>>>>>>                    End
81235>>>>>>>>>>
81235>>>>>>>>>                    Get DocumentElement of hoData to hoDataRoot
81236>>>>>>>>>                    Get CloneNode of hoDataRoot True to hoNode
81237>>>>>>>>>                    Get AppendNode of hoParamChildNode hoNode to hoNode
81238>>>>>>>>>                    Send Destroy of hoNode
81239>>>>>>>>>                Loop
81240>>>>>>>>>>
81240>>>>>>>>>                Send destroy of hoParamChildNode
81241>>>>>>>>>                Send destroy of hoDataRoot
81242>>>>>>>>>                Send Destroy of hoData
81243>>>>>>>>>            End
81243>>>>>>>>>>
81243>>>>>>>>>        End
81243>>>>>>>>>>
81243>>>>>>>>>        
81243>>>>>>>>>        // if base64, create the node and the data
81243>>>>>>>>>        
81243>>>>>>>>>        Else If (SoapParamDef.eType=xsBase64Binary) Begin
81246>>>>>>>>>            // if min=0 and there is no encoded data, we will not send this node. Null is evident
81246>>>>>>>>>            If (SoapParamDef.iMin<>0 or VariantStringLength(ValueTree.sValue)>0) Begin
81248>>>>>>>>>                Get AddElementNS of hoParam (If(bRpc,"",SoapParamDef.sNamespace)) SoapParamDef.sName '' to hoParamChildNode
81249>>>>>>>>>                If (VariantStringLength(ValueTree.sValue)>0) Begin
81251>>>>>>>>>                    Set psText of hoParamChildNode to '' // this forces a child node
81252>>>>>>>>>                    Get FirstChild of hoParamChildNode to hoNode
81253>>>>>>>>>                    Set pvNodeValue of hoNode to ValueTree.sValue
81254>>>>>>>>>                    Send Destroy of hoNode
81255>>>>>>>>>                    Send AddMimeMarkerAttributes hoParamChildNode SoapParamDef
81256>>>>>>>>>                End
81256>>>>>>>>>>
81256>>>>>>>>>                Send destroy of hoParamChildNode
81257>>>>>>>>>            End
81257>>>>>>>>>>
81257>>>>>>>>>        End
81257>>>>>>>>>>
81257>>>>>>>>>        Else Begin
81258>>>>>>>>>            Error DFERR_PROGRAM "Invalid datatype for ValueTreeXmlStrToXml"
81259>>>>>>>>>>
81259>>>>>>>>>        End
81259>>>>>>>>>>
81259>>>>>>>>>        Function_Return True
81260>>>>>>>>>    End_Function
81261>>>>>>>>>
81261>>>>>>>>>    // adds special attribute to mark this as an MTOM encodable XML. sMimeData will contain whatever
81261>>>>>>>>>    // information you want to go inside this attribute.
81261>>>>>>>>>    // keep private until supported    
81261>>>>>>>>>    Procedure AddMimeMarkerAttributes Handle hoElement tSoapParamDef SoapParamDef 
81263>>>>>>>>>        Integer eMtomXopRequest
81263>>>>>>>>>        String sMarker
81263>>>>>>>>>        // only do this if there is a sMimeData string and MTOM encoding is allowed
81263>>>>>>>>>        If (SoapParamDef.sMimeData<>"") Begin
81265>>>>>>>>>            Get peMtomXopRequest to eMtomXopRequest
81266>>>>>>>>>            If (eMtomXopRequest<>mxNever) Begin
81268>>>>>>>>>                Get psBase64MimeMarker to sMarker
81269>>>>>>>>>                Send AddAttribute of hoElement sMarker SoapParamDef.sMimeData
81270>>>>>>>>>                // indicates that we have at least one encodable element
81270>>>>>>>>>                Set pbRequestHasBase64Binary to True
81271>>>>>>>>>            End
81271>>>>>>>>>>
81271>>>>>>>>>        End
81271>>>>>>>>>>
81271>>>>>>>>>    End_Procedure
81272>>>>>>>>>    
81272>>>>>>>>>    // Can be called by the http transfer class to determine if it should do MTOM mime encoding
81272>>>>>>>>>    // We will do encoding if 1) it is required or 2) it is allowed and there is something to encode
81272>>>>>>>>>    // keep private until supported    
81272>>>>>>>>>    Function UseMTOMEncoding Returns Boolean
81274>>>>>>>>>        Integer eMtomXopRequest
81274>>>>>>>>>        Boolean bHasBase64
81274>>>>>>>>>        Get peMtomXopRequest to eMtomXopRequest
81275>>>>>>>>>        Case Begin
81275>>>>>>>>>            Case (eMtomXopRequest=mxAlways)
81277>>>>>>>>>                Function_Return True
81278>>>>>>>>>            Case (eMtomXopRequest=mxNever)
81281>>>>>>>>>                Function_Return False
81282>>>>>>>>>            Case Else
81282>>>>>>>>>                Get pbRequestHasBase64Binary to bHasBase64
81283>>>>>>>>>                Function_Return bHasBase64
81284>>>>>>>>>        Case End
81284>>>>>>>>>    End_Function
81285>>>>>>>>>
81285>>>>>>>>>End_Class
81286>>>>>>>>>
81286>>>>>>>
81286>>>>>>>
81286>>>>>>>// Structs used by web service
81286>>>>>>>
81286>>>>>>>Struct tWStDadosNfe
81286>>>>>>>    string     emitente
81286>>>>>>>    string     serie
81286>>>>>>>    string     modelo
81286>>>>>>>    decimal    num_nota_fiscal
81286>>>>>>>    string     tipo_documento
81286>>>>>>>    string     chave_nfe
81286>>>>>>>    string     convenio
81286>>>>>>>    string     data_emissao
81286>>>>>>>    string     produto
81286>>>>>>>    string     vencimento
81286>>>>>>>    decimal    valor
81286>>>>>>>    decimal    icms_uf_destino
81286>>>>>>>    decimal    fcp_uf_destino
81286>>>>>>>    string     cpf
81286>>>>>>>    string     cnpj
81286>>>>>>>    string     nome_destinatario
81286>>>>>>>    string     municipio_destinatario
81286>>>>>>>    string     cod_municipio_destinat
81286>>>>>>>    string     uf_destinatario
81286>>>>>>>    string     data_recepcao
81286>>>>>>>    decimal    icms_st
81286>>>>>>>End_Struct // tWStDadosNfe
81286>>>>>>>
81286>>>>>>>
81286>>>>>>>Struct tWStListaNfe
81286>>>>>>>    tWStDadosNfe[]    itens
81286>>>>>>>    tWStDadosNfe[]    itens
81286>>>>>>>End_Struct // tWStListaNfe
81286>>>>>>>
81286>>>>>>>
81286>>>>>>>Struct tWStReciboNota
81286>>>>>>>    string     emitente
81286>>>>>>>    integer    num_nota_fiscal
81286>>>>>>>    string     modelo
81286>>>>>>>    string     serie
81286>>>>>>>    string     emissao_nf
81286>>>>>>>    string     receita
81286>>>>>>>    string     status
81286>>>>>>>    string     recibo
81286>>>>>>>    string     data_recibo
81286>>>>>>>End_Struct // tWStReciboNota
81286>>>>>>>
81286>>>>>>>
81286>>>>>>>Struct tWStRetornoLote
81286>>>>>>>    integer             retorno
81286>>>>>>>    string              msg_retorno
81286>>>>>>>    integer             lote
81286>>>>>>>    tWStReciboNota[]    recibos
81286>>>>>>>    tWStReciboNota[]    recibos
81286>>>>>>>End_Struct // tWStRetornoLote
81286>>>>>>>
81286>>>>>>>
81286>>>>>>>Struct tWStPdfGuias
81286>>>>>>>    uchar[]    pdf
81286>>>>>>>    string     nome
81286>>>>>>>End_Struct // tWStPdfGuias
81286>>>>>>>
81286>>>>>>>
81286>>>>>>>Struct tWStRetornoLotePDF
81286>>>>>>>    integer           retorno
81286>>>>>>>    string            msg_retorno
81286>>>>>>>    integer           lote
81286>>>>>>>    tWStPdfGuias[]    pdf_guias
81286>>>>>>>    tWStPdfGuias[]    pdf_guias
81286>>>>>>>End_Struct // tWStRetornoLotePDF
81286>>>>>>>
81286>>>>>>>
81286>>>>>>>Struct tWStRecibos
81286>>>>>>>    string      emitente
81286>>>>>>>    string[]    recibo
81286>>>>>>>End_Struct // tWStRecibos
81286>>>>>>>
81286>>>>>>>
81286>>>>>>>Struct tWStGuias
81286>>>>>>>    string     emitente
81286>>>>>>>    string     serie
81286>>>>>>>    string     modelo
81286>>>>>>>    decimal    num_nota_fiscal
81286>>>>>>>    string     receita
81286>>>>>>>    string     detalhamento
81286>>>>>>>    string     tipo_documento
81286>>>>>>>    string     chave_nfe
81286>>>>>>>    string     convenio
81286>>>>>>>    string     data_emissao
81286>>>>>>>    string     status
81286>>>>>>>    string     recibo
81286>>>>>>>    string     data_recibo
81286>>>>>>>    string     produto
81286>>>>>>>    string     vencimento
81286>>>>>>>    decimal    valor
81286>>>>>>>    string     cpf
81286>>>>>>>    string     cnpj
81286>>>>>>>    string     nome_destinatario
81286>>>>>>>    string     municipio_destinatario
81286>>>>>>>    string     cod_municipio_destinat
81286>>>>>>>    string     uf_destinatario
81286>>>>>>>    string     mensagem
81286>>>>>>>    string     xml_guia
81286>>>>>>>    string     data_recepcao
81286>>>>>>>    decimal    valor_atualizado
81286>>>>>>>End_Struct // tWStGuias
81286>>>>>>>
81286>>>>>>>
81286>>>>>>>Struct tWStListaGuias
81286>>>>>>>    tWStGuias[]    guias
81286>>>>>>>    tWStGuias[]    guias
81286>>>>>>>    integer        retorno
81286>>>>>>>    string         msg_retorno
81286>>>>>>>End_Struct // tWStListaGuias
81286>>>>>>>
81286>>>>>>>
81286>>>>>>>Struct tWStAssinatura
81286>>>>>>>    string    Nome
81286>>>>>>>    string    Login
81286>>>>>>>    string    Senha
81286>>>>>>>    string    Razao
81286>>>>>>>    string    Fantasia
81286>>>>>>>    string    Telefone
81286>>>>>>>    string    Cep
81286>>>>>>>    string    Logradouro
81286>>>>>>>    string    Nro
81286>>>>>>>    string    Complemento
81286>>>>>>>    string    Bairro
81286>>>>>>>    string    Codigo_cidade
81286>>>>>>>    string    Codigo_uf
81286>>>>>>>    string    CNPJ
81286>>>>>>>End_Struct // tWStAssinatura
81286>>>>>>>
81286>>>>>>>
81286>>>>>>>Struct tWStRetornoAssinatura
81286>>>>>>>    string     Login
81286>>>>>>>    string     Razao
81286>>>>>>>    string     CNPJ
81286>>>>>>>    string     TokenAPI
81286>>>>>>>    integer    Retorno
81286>>>>>>>    string     Msg_retorno
81286>>>>>>>End_Struct // tWStRetornoAssinatura
81286>>>>>>>
81286>>>>>>>// 
81286>>>>>>>// Class:   cWSGeraGuiaGnre
81286>>>>>>>// 
81286>>>>>>>// Interface:
81286>>>>>>>// 
81286>>>>>>>// Function wsGeraGuia string llsEmpresa string llsUsuario string llsChaveApi tWStListaNfe llListaNfe Returns tWStRetornoLote
81286>>>>>>>// Function wsGeraGuiaPDF string llsEmpresa string llsUsuario string llsChaveApi tWStListaNfe llListaNfe Returns tWStRetornoLotePDF
81286>>>>>>>// Function wsBuscaGuiasPendentes string llsEmpresa string llsUsuario string llsChaveApi tWStRecibos llGuiasPendentes Returns tWStListaGuias
81286>>>>>>>// Function wsBuscaTodasGuiasPendentes string llsEmpresa string llsUsuario string llsChaveApi string llsDataInicio string llsDataFim Returns tWStListaGuias
81286>>>>>>>// Function wsBuscaTodasGuiasComErro string llsEmpresa string llsUsuario string llsChaveApi string llsDataInicio string llsDataFim Returns tWStListaGuias
81286>>>>>>>// Function wsBuscaGuia string llsEmpresa string llsUsuario string llsChaveApi tWStRetornoLote llLote Returns tWStListaGuias
81286>>>>>>>// Function wsBuscaGuiaPDF string llsEmpresa string llsUsuario string llsChaveApi tWStRetornoLote llLote Returns tWStRetornoLotePDF
81286>>>>>>>// Function wsAssinatura_gratis tWStAssinatura llAssinatura Returns tWStRetornoAssinatura
81286>>>>>>>// 
81286>>>>>>>// 
81286>>>>>>>
81286>>>>>>>Class cWSGeraGuiaGnre is a cClientWebService
81287>>>>>>>
81287>>>>>>>    Procedure Construct_object
81289>>>>>>>        Forward send Construct_object
81291>>>>>>>        Set psServiceLocation     to 'https://www.guiasgnre.com.br/WEBGNRE/GeraGuiaGnre.wso'
81292>>>>>>>        Set psWSDLLocation        to 'https://www.guiasgnre.com.br/WEBGNRE/GeraGuiaGnre.wso?WSDL'
81293>>>>>>>
81293>>>>>>>        Object oWStDadosNfe is a cSoapMetaStruct
81295>>>>>>>            Set psNameSpace to "http://guiasgnre/webgnre"
81296>>>>>>>            Set psDataType to "tDadosNfe"
81297>>>>>>>            Send defineParameter xsString 1 1 "emitente"
81298>>>>>>>            Send defineParameter xsString 1 1 "serie"
81299>>>>>>>            Send defineParameter xsString 1 1 "modelo"
81300>>>>>>>            Send defineParameter xsDecimal 1 1 "num_nota_fiscal"
81301>>>>>>>            Send defineParameter xsString 1 1 "tipo_documento"
81302>>>>>>>            Send defineParameter xsString 1 1 "chave_nfe"
81303>>>>>>>            Send defineParameter xsString 1 1 "convenio"
81304>>>>>>>            Send defineParameter xsString 1 1 "data_emissao"
81305>>>>>>>            Send defineParameter xsString 1 1 "produto"
81306>>>>>>>            Send defineParameter xsString 1 1 "vencimento"
81307>>>>>>>            Send defineParameter xsDecimal 1 1 "valor"
81308>>>>>>>            Send defineParameter xsDecimal 1 1 "icms_uf_destino"
81309>>>>>>>            Send defineParameter xsDecimal 1 1 "fcp_uf_destino"
81310>>>>>>>            Send defineParameter xsString 1 1 "cpf"
81311>>>>>>>            Send defineParameter xsString 1 1 "cnpj"
81312>>>>>>>            Send defineParameter xsString 1 1 "nome_destinatario"
81313>>>>>>>            Send defineParameter xsString 1 1 "municipio_destinatario"
81314>>>>>>>            Send defineParameter xsString 1 1 "cod_municipio_destinat"
81315>>>>>>>            Send defineParameter xsString 1 1 "uf_destinatario"
81316>>>>>>>            Send defineParameter xsString 1 1 "data_recepcao"
81317>>>>>>>            Send defineParameter xsDecimal 1 1 "icms_st"
81318>>>>>>>        End_Object //oWStDadosNfe
81319>>>>>>>
81319>>>>>>>        Object oWSArrayOftDadosNfe is a cSoapMetaStruct
81321>>>>>>>            Set psNameSpace to "http://guiasgnre/webgnre"
81322>>>>>>>            Set peArrayType to C_atArray
81323>>>>>>>            Set psDataType to "ArrayOftDadosNfe"
81324>>>>>>>            Set piDimensions to 1
81325>>>>>>>            Send defineStructParameter oWStDadosNfe 0 C_unbounded "tDadosNfe"
81326>>>>>>>        End_Object //oWSArrayOftDadosNfe
81327>>>>>>>
81327>>>>>>>        Object oWStListaNfe is a cSoapMetaStruct
81329>>>>>>>            Set psNameSpace to "http://guiasgnre/webgnre"
81330>>>>>>>            Set psDataType to "tListaNfe"
81331>>>>>>>            Send defineStructParameter oWSArrayOftDadosNfe 1 1 "itens"
81332>>>>>>>        End_Object //oWStListaNfe
81333>>>>>>>
81333>>>>>>>        Object oWStReciboNota is a cSoapMetaStruct
81335>>>>>>>            Set psNameSpace to "http://guiasgnre/webgnre"
81336>>>>>>>            Set psDataType to "tReciboNota"
81337>>>>>>>            Send defineParameter xsString 1 1 "emitente"
81338>>>>>>>            Send defineParameter xsInteger 1 1 "num_nota_fiscal"
81339>>>>>>>            Send defineParameter xsString 1 1 "modelo"
81340>>>>>>>            Send defineParameter xsString 1 1 "serie"
81341>>>>>>>            Send defineParameter xsString 1 1 "emissao_nf"
81342>>>>>>>            Send defineParameter xsString 1 1 "receita"
81343>>>>>>>            Send defineParameter xsString 1 1 "status"
81344>>>>>>>            Send defineParameter xsString 1 1 "recibo"
81345>>>>>>>            Send defineParameter xsString 1 1 "data_recibo"
81346>>>>>>>        End_Object //oWStReciboNota
81347>>>>>>>
81347>>>>>>>        Object oWSArrayOftReciboNota is a cSoapMetaStruct
81349>>>>>>>            Set psNameSpace to "http://guiasgnre/webgnre"
81350>>>>>>>            Set peArrayType to C_atArray
81351>>>>>>>            Set psDataType to "ArrayOftReciboNota"
81352>>>>>>>            Set piDimensions to 1
81353>>>>>>>            Send defineStructParameter oWStReciboNota 0 C_unbounded "tReciboNota"
81354>>>>>>>        End_Object //oWSArrayOftReciboNota
81355>>>>>>>
81355>>>>>>>        Object oWStRetornoLote is a cSoapMetaStruct
81357>>>>>>>            Set psNameSpace to "http://guiasgnre/webgnre"
81358>>>>>>>            Set psDataType to "tRetornoLote"
81359>>>>>>>            Send defineParameter xsInteger 1 1 "retorno"
81360>>>>>>>            Send defineParameter xsString 1 1 "msg_retorno"
81361>>>>>>>            Send defineParameter xsInteger 1 1 "lote"
81362>>>>>>>            Send defineStructParameter oWSArrayOftReciboNota 1 1 "recibos"
81363>>>>>>>        End_Object //oWStRetornoLote
81364>>>>>>>
81364>>>>>>>        Object oWSArrayOfUnsignedByte is a cSoapMetaStruct
81366>>>>>>>            Set psNameSpace to "http://guiasgnre/webgnre"
81367>>>>>>>            Set peArrayType to C_atArray
81368>>>>>>>            Set psDataType to "ArrayOfUnsignedByte"
81369>>>>>>>            Set piDimensions to 1
81370>>>>>>>            Send defineParameter xsUchar 0 C_unbounded "unsignedByte"
81371>>>>>>>        End_Object //oWSArrayOfUnsignedByte
81372>>>>>>>
81372>>>>>>>        Object oWStPdfGuias is a cSoapMetaStruct
81374>>>>>>>            Set psNameSpace to "http://guiasgnre/webgnre"
81375>>>>>>>            Set psDataType to "tPdfGuias"
81376>>>>>>>            Send defineStructParameter oWSArrayOfUnsignedByte 1 1 "pdf"
81377>>>>>>>            Send defineParameter xsString 1 1 "nome"
81378>>>>>>>        End_Object //oWStPdfGuias
81379>>>>>>>
81379>>>>>>>        Object oWSArrayOftPdfGuias is a cSoapMetaStruct
81381>>>>>>>            Set psNameSpace to "http://guiasgnre/webgnre"
81382>>>>>>>            Set peArrayType to C_atArray
81383>>>>>>>            Set psDataType to "ArrayOftPdfGuias"
81384>>>>>>>            Set piDimensions to 1
81385>>>>>>>            Send defineStructParameter oWStPdfGuias 0 C_unbounded "tPdfGuias"
81386>>>>>>>        End_Object //oWSArrayOftPdfGuias
81387>>>>>>>
81387>>>>>>>        Object oWStRetornoLotePDF is a cSoapMetaStruct
81389>>>>>>>            Set psNameSpace to "http://guiasgnre/webgnre"
81390>>>>>>>            Set psDataType to "tRetornoLotePDF"
81391>>>>>>>            Send defineParameter xsInteger 1 1 "retorno"
81392>>>>>>>            Send defineParameter xsString 1 1 "msg_retorno"
81393>>>>>>>            Send defineParameter xsInteger 1 1 "lote"
81394>>>>>>>            Send defineStructParameter oWSArrayOftPdfGuias 1 1 "pdf_guias"
81395>>>>>>>        End_Object //oWStRetornoLotePDF
81396>>>>>>>
81396>>>>>>>        Object oWSArrayOfString is a cSoapMetaStruct
81398>>>>>>>            Set psNameSpace to "http://guiasgnre/webgnre"
81399>>>>>>>            Set peArrayType to C_atArray
81400>>>>>>>            Set psDataType to "ArrayOfString"
81401>>>>>>>            Set piDimensions to 1
81402>>>>>>>            Send defineParameter xsString 0 C_unbounded "string"
81403>>>>>>>        End_Object //oWSArrayOfString
81404>>>>>>>
81404>>>>>>>        Object oWStRecibos is a cSoapMetaStruct
81406>>>>>>>            Set psNameSpace to "http://guiasgnre/webgnre"
81407>>>>>>>            Set psDataType to "tRecibos"
81408>>>>>>>            Send defineParameter xsString 1 1 "emitente"
81409>>>>>>>            Send defineStructParameter oWSArrayOfString 1 1 "recibo"
81410>>>>>>>        End_Object //oWStRecibos
81411>>>>>>>
81411>>>>>>>        Object oWStGuias is a cSoapMetaStruct
81413>>>>>>>            Set psNameSpace to "http://guiasgnre/webgnre"
81414>>>>>>>            Set psDataType to "tGuias"
81415>>>>>>>            Send defineParameter xsString 1 1 "emitente"
81416>>>>>>>            Send defineParameter xsString 1 1 "serie"
81417>>>>>>>            Send defineParameter xsString 1 1 "modelo"
81418>>>>>>>            Send defineParameter xsDecimal 1 1 "num_nota_fiscal"
81419>>>>>>>            Send defineParameter xsString 1 1 "receita"
81420>>>>>>>            Send defineParameter xsString 1 1 "detalhamento"
81421>>>>>>>            Send defineParameter xsString 1 1 "tipo_documento"
81422>>>>>>>            Send defineParameter xsString 1 1 "chave_nfe"
81423>>>>>>>            Send defineParameter xsString 1 1 "convenio"
81424>>>>>>>            Send defineParameter xsString 1 1 "data_emissao"
81425>>>>>>>            Send defineParameter xsString 1 1 "status"
81426>>>>>>>            Send defineParameter xsString 1 1 "recibo"
81427>>>>>>>            Send defineParameter xsString 1 1 "data_recibo"
81428>>>>>>>            Send defineParameter xsString 1 1 "produto"
81429>>>>>>>            Send defineParameter xsString 1 1 "vencimento"
81430>>>>>>>            Send defineParameter xsDecimal 1 1 "valor"
81431>>>>>>>            Send defineParameter xsString 1 1 "cpf"
81432>>>>>>>            Send defineParameter xsString 1 1 "cnpj"
81433>>>>>>>            Send defineParameter xsString 1 1 "nome_destinatario"
81434>>>>>>>            Send defineParameter xsString 1 1 "municipio_destinatario"
81435>>>>>>>            Send defineParameter xsString 1 1 "cod_municipio_destinat"
81436>>>>>>>            Send defineParameter xsString 1 1 "uf_destinatario"
81437>>>>>>>            Send defineParameter xsString 1 1 "mensagem"
81438>>>>>>>            Send defineParameter xsString 1 1 "xml_guia"
81439>>>>>>>            Send defineParameter xsString 1 1 "data_recepcao"
81440>>>>>>>            Send defineParameter xsDecimal 1 1 "valor_atualizado"
81441>>>>>>>        End_Object //oWStGuias
81442>>>>>>>
81442>>>>>>>        Object oWSArrayOftGuias is a cSoapMetaStruct
81444>>>>>>>            Set psNameSpace to "http://guiasgnre/webgnre"
81445>>>>>>>            Set peArrayType to C_atArray
81446>>>>>>>            Set psDataType to "ArrayOftGuias"
81447>>>>>>>            Set piDimensions to 1
81448>>>>>>>            Send defineStructParameter oWStGuias 0 C_unbounded "tGuias"
81449>>>>>>>        End_Object //oWSArrayOftGuias
81450>>>>>>>
81450>>>>>>>        Object oWStListaGuias is a cSoapMetaStruct
81452>>>>>>>            Set psNameSpace to "http://guiasgnre/webgnre"
81453>>>>>>>            Set psDataType to "tListaGuias"
81454>>>>>>>            Send defineStructParameter oWSArrayOftGuias 1 1 "guias"
81455>>>>>>>            Send defineParameter xsInteger 1 1 "retorno"
81456>>>>>>>            Send defineParameter xsString 1 1 "msg_retorno"
81457>>>>>>>        End_Object //oWStListaGuias
81458>>>>>>>
81458>>>>>>>        Object oWStAssinatura is a cSoapMetaStruct
81460>>>>>>>            Set psNameSpace to "http://guiasgnre/webgnre"
81461>>>>>>>            Set psDataType to "tAssinatura"
81462>>>>>>>            Send defineParameter xsString 1 1 "Nome"
81463>>>>>>>            Send defineParameter xsString 1 1 "Login"
81464>>>>>>>            Send defineParameter xsString 1 1 "Senha"
81465>>>>>>>            Send defineParameter xsString 1 1 "Razao"
81466>>>>>>>            Send defineParameter xsString 1 1 "Fantasia"
81467>>>>>>>            Send defineParameter xsString 1 1 "Telefone"
81468>>>>>>>            Send defineParameter xsString 1 1 "Cep"
81469>>>>>>>            Send defineParameter xsString 1 1 "Logradouro"
81470>>>>>>>            Send defineParameter xsString 1 1 "Nro"
81471>>>>>>>            Send defineParameter xsString 1 1 "Complemento"
81472>>>>>>>            Send defineParameter xsString 1 1 "Bairro"
81473>>>>>>>            Send defineParameter xsString 1 1 "Codigo_cidade"
81474>>>>>>>            Send defineParameter xsString 1 1 "Codigo_uf"
81475>>>>>>>            Send defineParameter xsString 1 1 "CNPJ"
81476>>>>>>>        End_Object //oWStAssinatura
81477>>>>>>>
81477>>>>>>>        Object oWStRetornoAssinatura is a cSoapMetaStruct
81479>>>>>>>            Set psNameSpace to "http://guiasgnre/webgnre"
81480>>>>>>>            Set psDataType to "tRetornoAssinatura"
81481>>>>>>>            Send defineParameter xsString 1 1 "Login"
81482>>>>>>>            Send defineParameter xsString 1 1 "Razao"
81483>>>>>>>            Send defineParameter xsString 1 1 "CNPJ"
81484>>>>>>>            Send defineParameter xsString 1 1 "TokenAPI"
81485>>>>>>>            Send defineParameter xsInteger 1 1 "Retorno"
81486>>>>>>>            Send defineParameter xsString 1 1 "Msg_retorno"
81487>>>>>>>        End_Object //oWStRetornoAssinatura
81488>>>>>>>
81488>>>>>>>    End_Procedure // Construct_object
81489>>>>>>>
81489>>>>>>>    // 
81489>>>>>>>    // Procedure wsGeraGuia
81489>>>>>>>    // 
81489>>>>>>>    // Fun‡Æo de Envio dos Dados da NFe para o webservice para gera‡Æo das guias. Esta
81489>>>>>>>    // fun‡Æo recebe uma ou mais notas e retorna uma lista com informa‡äes das guias
81489>>>>>>>    // das respectivas notas, para que sejam usadas e impressas em um gerador de
81489>>>>>>>    // relat¢rios de sua preferˆncia. Lista de c¢digos de retorno: 0 = Sucesso | 1 =
81489>>>>>>>    // NÆo autorizado. Verifique o CNPJ, Usu rio e Token. | 2 = Lote processado com
81489>>>>>>>    // pendˆncias. | 3 = Nenhuma guia liberada no momento.
81489>>>>>>>    // 
81489>>>>>>>    Function wsGeraGuia string llsEmpresa string llsUsuario string llsChaveApi tWStListaNfe llListaNfe Returns tWStRetornoLote
81491>>>>>>>        tWStRetornoLote llGeraGuiaResult
81491>>>>>>>        tWStRetornoLote llGeraGuiaResult
81491>>>>>>>        tSoapParameter[] spParameters
81491>>>>>>>        tSoapParameter[] spParameters
81492>>>>>>>        tSoapParameter[] spReturnParameters
81492>>>>>>>        tSoapParameter[] spReturnParameters
81493>>>>>>>        integer eStatus
81493>>>>>>>
81493>>>>>>>        Send Reset
81494>>>>>>>        Set psSOAPAction           to ""
81495>>>>>>>        Set peSoapStyle            to ssDocument
81496>>>>>>>
81496>>>>>>>        Set psRequestNSURI         to "http://guiasgnre/webgnre"
81497>>>>>>>        Set peSoapEncoding         to seLiteral
81498>>>>>>>        Set psMethodRequest        to "GeraGuia"
81499>>>>>>>        Set pbRequestBare          to false
81500>>>>>>>
81500>>>>>>>        Set psResponseNSURI        to "http://guiasgnre/webgnre"
81501>>>>>>>        Set peResponseSoapEncoding to seLiteral
81502>>>>>>>        Set psMethodResponse       to "GeraGuiaResponse"
81503>>>>>>>        Set pbResponseBare         to false
81504>>>>>>>
81504>>>>>>>        // Parameter 0
81504>>>>>>>        Get DefineParameter xsString 1 1 "sEmpresa" "http://guiasgnre/webgnre" to spParameters[0].SoapParamDef 
81505>>>>>>>        ValueTreeSerializeParameter llsEmpresa to spParameters[0].ValueTree
81506>>>>>>>
81506>>>>>>>        // Parameter 1
81506>>>>>>>        Get DefineParameter xsString 1 1 "sUsuario" "http://guiasgnre/webgnre" to spParameters[1].SoapParamDef 
81507>>>>>>>        ValueTreeSerializeParameter llsUsuario to spParameters[1].ValueTree
81508>>>>>>>
81508>>>>>>>        // Parameter 2
81508>>>>>>>        Get DefineParameter xsString 1 1 "sChaveApi" "http://guiasgnre/webgnre" to spParameters[2].SoapParamDef 
81509>>>>>>>        ValueTreeSerializeParameter llsChaveApi to spParameters[2].ValueTree
81510>>>>>>>
81510>>>>>>>        // Parameter 3
81510>>>>>>>        Get DefineStructParameter oWStListaNfe 1 1 "ListaNfe" "http://guiasgnre/webgnre" to spParameters[3].SoapParamDef 
81511>>>>>>>        ValueTreeSerializeParameter llListaNfe to spParameters[3].ValueTree
81512>>>>>>>
81512>>>>>>>        Set pspParameters to spParameters
81513>>>>>>>
81513>>>>>>>        // Return Parameter
81513>>>>>>>        Get DefineStructParameter oWStRetornoLote 1 1 "GeraGuiaResult" "http://guiasgnre/webgnre" to spReturnParameters[0].SoapParamDef
81514>>>>>>>        Set pspReturnParameters to spReturnParameters
81515>>>>>>>
81515>>>>>>>        Get DoInvokeService to eStatus
81516>>>>>>>        If (eStatus=wssOK) Begin
81518>>>>>>>            Get pspReturnParameters   to spReturnParameters
81519>>>>>>>            ValueTreeDeserializeParameter spReturnParameters[0].ValueTree to llGeraGuiaResult
81520>>>>>>>        end
81520>>>>>>>>
81520>>>>>>>        Else Begin
81521>>>>>>>            Send LastError
81522>>>>>>>        end
81522>>>>>>>>
81522>>>>>>>
81522>>>>>>>        Function_return llGeraGuiaResult
81523>>>>>>>    End_Function // wsGeraGuia
81524>>>>>>>
81524>>>>>>>    // 
81524>>>>>>>    // Procedure wsGeraGuiaPDF
81524>>>>>>>    // 
81524>>>>>>>    // Fun‡Æo de Envio dos Dados da NFe para o webservice para gera‡Æo das guias,
81524>>>>>>>    // por‚m j  retornando o PDF das guias pronto para ser salvo e/ou impresso ap¢s a
81524>>>>>>>    // recep‡Æo do arquivo. Lista de c¢digos de retorno: 0 = Sucesso | 1 = NÆo
81524>>>>>>>    // autorizado, Verifique o CNPJ, Usu rio e Token. | 2 = Lote processado com
81524>>>>>>>    // pendˆncias. | 3 = Nenhuma guia liberada no momento. | 4 = Falha ao buscar
81524>>>>>>>    // guias. | 5 = Falha ao gerar o PDF.
81524>>>>>>>    // 
81524>>>>>>>    Function wsGeraGuiaPDF string llsEmpresa string llsUsuario string llsChaveApi tWStListaNfe llListaNfe Returns tWStRetornoLotePDF
81526>>>>>>>        tWStRetornoLotePDF llGeraGuiaPDFResult
81526>>>>>>>        tWStRetornoLotePDF llGeraGuiaPDFResult
81526>>>>>>>        tSoapParameter[] spParameters
81526>>>>>>>        tSoapParameter[] spParameters
81527>>>>>>>        tSoapParameter[] spReturnParameters
81527>>>>>>>        tSoapParameter[] spReturnParameters
81528>>>>>>>        integer eStatus
81528>>>>>>>
81528>>>>>>>        Send Reset
81529>>>>>>>        Set psSOAPAction           to ""
81530>>>>>>>        Set peSoapStyle            to ssDocument
81531>>>>>>>
81531>>>>>>>        Set psRequestNSURI         to "http://guiasgnre/webgnre"
81532>>>>>>>        Set peSoapEncoding         to seLiteral
81533>>>>>>>        Set psMethodRequest        to "GeraGuiaPDF"
81534>>>>>>>        Set pbRequestBare          to false
81535>>>>>>>
81535>>>>>>>        Set psResponseNSURI        to "http://guiasgnre/webgnre"
81536>>>>>>>        Set peResponseSoapEncoding to seLiteral
81537>>>>>>>        Set psMethodResponse       to "GeraGuiaPDFResponse"
81538>>>>>>>        Set pbResponseBare         to false
81539>>>>>>>
81539>>>>>>>        // Parameter 0
81539>>>>>>>        Get DefineParameter xsString 1 1 "sEmpresa" "http://guiasgnre/webgnre" to spParameters[0].SoapParamDef 
81540>>>>>>>        ValueTreeSerializeParameter llsEmpresa to spParameters[0].ValueTree
81541>>>>>>>
81541>>>>>>>        // Parameter 1
81541>>>>>>>        Get DefineParameter xsString 1 1 "sUsuario" "http://guiasgnre/webgnre" to spParameters[1].SoapParamDef 
81542>>>>>>>        ValueTreeSerializeParameter llsUsuario to spParameters[1].ValueTree
81543>>>>>>>
81543>>>>>>>        // Parameter 2
81543>>>>>>>        Get DefineParameter xsString 1 1 "sChaveApi" "http://guiasgnre/webgnre" to spParameters[2].SoapParamDef 
81544>>>>>>>        ValueTreeSerializeParameter llsChaveApi to spParameters[2].ValueTree
81545>>>>>>>
81545>>>>>>>        // Parameter 3
81545>>>>>>>        Get DefineStructParameter oWStListaNfe 1 1 "ListaNfe" "http://guiasgnre/webgnre" to spParameters[3].SoapParamDef 
81546>>>>>>>        ValueTreeSerializeParameter llListaNfe to spParameters[3].ValueTree
81547>>>>>>>
81547>>>>>>>        Set pspParameters to spParameters
81548>>>>>>>
81548>>>>>>>        // Return Parameter
81548>>>>>>>        Get DefineStructParameter oWStRetornoLotePDF 1 1 "GeraGuiaPDFResult" "http://guiasgnre/webgnre" to spReturnParameters[0].SoapParamDef
81549>>>>>>>        Set pspReturnParameters to spReturnParameters
81550>>>>>>>
81550>>>>>>>        Get DoInvokeService to eStatus
81551>>>>>>>        If (eStatus=wssOK) Begin
81553>>>>>>>            Get pspReturnParameters   to spReturnParameters
81554>>>>>>>            ValueTreeDeserializeParameter spReturnParameters[0].ValueTree to llGeraGuiaPDFResult
81555>>>>>>>        end
81555>>>>>>>>
81555>>>>>>>        Else Begin
81556>>>>>>>            Send LastError
81557>>>>>>>        end
81557>>>>>>>>
81557>>>>>>>
81557>>>>>>>        Function_return llGeraGuiaPDFResult
81558>>>>>>>    End_Function // wsGeraGuiaPDF
81559>>>>>>>
81559>>>>>>>    // 
81559>>>>>>>    // Procedure wsBuscaGuiasPendentes
81559>>>>>>>    // 
81559>>>>>>>    // Busca Guias que ficaram pendentes, com status de 'Transmitida' ou 'Aguardando',
81559>>>>>>>    // e nÆo foram retornadas no momento do envio do lote das notas, pois estavam em
81559>>>>>>>    // processamento pela SEFAZ de destino. Esta fun‡Æo recebe um ou mais recibos das
81559>>>>>>>    // guias desejadas e retorna uma lista com informa‡äes das guias dos respectivos
81559>>>>>>>    // recibos, para que sejam usadas e impressas em um gerador de relat¢rios de sua
81559>>>>>>>    // preferˆncia. Lista de c¢digos de retorno: 0 = Sucesso | 1 = NÆo autorizado.
81559>>>>>>>    // Verifique o CNPJ, Usu rio e Token. | 2 = Lote processado com pendˆncias. | 3 =
81559>>>>>>>    // Nenhuma guia liberada no momento.
81559>>>>>>>    // 
81559>>>>>>>    Function wsBuscaGuiasPendentes string llsEmpresa string llsUsuario string llsChaveApi tWStRecibos llGuiasPendentes Returns tWStListaGuias
81561>>>>>>>        tWStListaGuias llBuscaGuiasPendentesResult
81561>>>>>>>        tWStListaGuias llBuscaGuiasPendentesResult
81561>>>>>>>        tSoapParameter[] spParameters
81561>>>>>>>        tSoapParameter[] spParameters
81562>>>>>>>        tSoapParameter[] spReturnParameters
81562>>>>>>>        tSoapParameter[] spReturnParameters
81563>>>>>>>        integer eStatus
81563>>>>>>>
81563>>>>>>>        Send Reset
81564>>>>>>>        Set psSOAPAction           to ""
81565>>>>>>>        Set peSoapStyle            to ssDocument
81566>>>>>>>
81566>>>>>>>        Set psRequestNSURI         to "http://guiasgnre/webgnre"
81567>>>>>>>        Set peSoapEncoding         to seLiteral
81568>>>>>>>        Set psMethodRequest        to "BuscaGuiasPendentes"
81569>>>>>>>        Set pbRequestBare          to false
81570>>>>>>>
81570>>>>>>>        Set psResponseNSURI        to "http://guiasgnre/webgnre"
81571>>>>>>>        Set peResponseSoapEncoding to seLiteral
81572>>>>>>>        Set psMethodResponse       to "BuscaGuiasPendentesResponse"
81573>>>>>>>        Set pbResponseBare         to false
81574>>>>>>>
81574>>>>>>>        // Parameter 0
81574>>>>>>>        Get DefineParameter xsString 1 1 "sEmpresa" "http://guiasgnre/webgnre" to spParameters[0].SoapParamDef 
81575>>>>>>>        ValueTreeSerializeParameter llsEmpresa to spParameters[0].ValueTree
81576>>>>>>>
81576>>>>>>>        // Parameter 1
81576>>>>>>>        Get DefineParameter xsString 1 1 "sUsuario" "http://guiasgnre/webgnre" to spParameters[1].SoapParamDef 
81577>>>>>>>        ValueTreeSerializeParameter llsUsuario to spParameters[1].ValueTree
81578>>>>>>>
81578>>>>>>>        // Parameter 2
81578>>>>>>>        Get DefineParameter xsString 1 1 "sChaveApi" "http://guiasgnre/webgnre" to spParameters[2].SoapParamDef 
81579>>>>>>>        ValueTreeSerializeParameter llsChaveApi to spParameters[2].ValueTree
81580>>>>>>>
81580>>>>>>>        // Parameter 3
81580>>>>>>>        Get DefineStructParameter oWStRecibos 1 1 "GuiasPendentes" "http://guiasgnre/webgnre" to spParameters[3].SoapParamDef 
81581>>>>>>>        ValueTreeSerializeParameter llGuiasPendentes to spParameters[3].ValueTree
81582>>>>>>>
81582>>>>>>>        Set pspParameters to spParameters
81583>>>>>>>
81583>>>>>>>        // Return Parameter
81583>>>>>>>        Get DefineStructParameter oWStListaGuias 1 1 "BuscaGuiasPendentesResult" "http://guiasgnre/webgnre" to spReturnParameters[0].SoapParamDef
81584>>>>>>>        Set pspReturnParameters to spReturnParameters
81585>>>>>>>
81585>>>>>>>        Get DoInvokeService to eStatus
81586>>>>>>>        If (eStatus=wssOK) Begin
81588>>>>>>>            Get pspReturnParameters   to spReturnParameters
81589>>>>>>>            ValueTreeDeserializeParameter spReturnParameters[0].ValueTree to llBuscaGuiasPendentesResult
81590>>>>>>>        end
81590>>>>>>>>
81590>>>>>>>        Else Begin
81591>>>>>>>            Send LastError
81592>>>>>>>        end
81592>>>>>>>>
81592>>>>>>>
81592>>>>>>>        Function_return llBuscaGuiasPendentesResult
81593>>>>>>>    End_Function // wsBuscaGuiasPendentes
81594>>>>>>>
81594>>>>>>>    // 
81594>>>>>>>    // Procedure wsBuscaTodasGuiasPendentes
81594>>>>>>>    // 
81594>>>>>>>    // Busca todas as guias que estÆo pendentes, com status 'Trasmitida' ou
81594>>>>>>>    // 'Aguardando', exceto aquelas com status 'Erro', e nÆo foram retornadas no
81594>>>>>>>    // momento do envio do lote das notas. Se informado data de inicio e fim da
81594>>>>>>>    // emissÆo da nota, filtra apenas guias nesse intervalo de tempo. Se informado
81594>>>>>>>    // apenas data de in¡cio, filtra todas a partir desta data. Se informado apenas
81594>>>>>>>    // data final, filtra todas as guias at‚ esta data. Se nÆo informar nenhuma data,
81594>>>>>>>    // retorna todas as guias com status 'Transmitida' ou 'Aguardando'. Lista de
81594>>>>>>>    // c¢digos de retorno: 0 = Sucesso | 1 = NÆo autorizado. Verifique o CNPJ, Usu rio
81594>>>>>>>    // e Token. | 2 = Lote processado com pendˆncias. | 3 = Nenhuma guia liberada no
81594>>>>>>>    // momento. | 6 = Data inicial inv lida. PadrÆo esperado: AAAA-MM-DD. | 7 = Data
81594>>>>>>>    // final inv lida. PadrÆo esperado: AAAA-MM-DD.
81594>>>>>>>    // 
81594>>>>>>>    Function wsBuscaTodasGuiasPendentes string llsEmpresa string llsUsuario string llsChaveApi string llsDataInicio string llsDataFim Returns tWStListaGuias
81596>>>>>>>        tWStListaGuias llBuscaTodasGuiasPendentesResult
81596>>>>>>>        tWStListaGuias llBuscaTodasGuiasPendentesResult
81596>>>>>>>        tSoapParameter[] spParameters
81596>>>>>>>        tSoapParameter[] spParameters
81597>>>>>>>        tSoapParameter[] spReturnParameters
81597>>>>>>>        tSoapParameter[] spReturnParameters
81598>>>>>>>        integer eStatus
81598>>>>>>>
81598>>>>>>>        Send Reset
81599>>>>>>>        Set psSOAPAction           to ""
81600>>>>>>>        Set peSoapStyle            to ssDocument
81601>>>>>>>
81601>>>>>>>        Set psRequestNSURI         to "http://guiasgnre/webgnre"
81602>>>>>>>        Set peSoapEncoding         to seLiteral
81603>>>>>>>        Set psMethodRequest        to "BuscaTodasGuiasPendentes"
81604>>>>>>>        Set pbRequestBare          to false
81605>>>>>>>
81605>>>>>>>        Set psResponseNSURI        to "http://guiasgnre/webgnre"
81606>>>>>>>        Set peResponseSoapEncoding to seLiteral
81607>>>>>>>        Set psMethodResponse       to "BuscaTodasGuiasPendentesResponse"
81608>>>>>>>        Set pbResponseBare         to false
81609>>>>>>>
81609>>>>>>>        // Parameter 0
81609>>>>>>>        Get DefineParameter xsString 1 1 "sEmpresa" "http://guiasgnre/webgnre" to spParameters[0].SoapParamDef 
81610>>>>>>>        ValueTreeSerializeParameter llsEmpresa to spParameters[0].ValueTree
81611>>>>>>>
81611>>>>>>>        // Parameter 1
81611>>>>>>>        Get DefineParameter xsString 1 1 "sUsuario" "http://guiasgnre/webgnre" to spParameters[1].SoapParamDef 
81612>>>>>>>        ValueTreeSerializeParameter llsUsuario to spParameters[1].ValueTree
81613>>>>>>>
81613>>>>>>>        // Parameter 2
81613>>>>>>>        Get DefineParameter xsString 1 1 "sChaveApi" "http://guiasgnre/webgnre" to spParameters[2].SoapParamDef 
81614>>>>>>>        ValueTreeSerializeParameter llsChaveApi to spParameters[2].ValueTree
81615>>>>>>>
81615>>>>>>>        // Parameter 3
81615>>>>>>>        Get DefineParameter xsString 1 1 "sDataInicio" "http://guiasgnre/webgnre" to spParameters[3].SoapParamDef 
81616>>>>>>>        ValueTreeSerializeParameter llsDataInicio to spParameters[3].ValueTree
81617>>>>>>>
81617>>>>>>>        // Parameter 4
81617>>>>>>>        Get DefineParameter xsString 1 1 "sDataFim" "http://guiasgnre/webgnre" to spParameters[4].SoapParamDef 
81618>>>>>>>        ValueTreeSerializeParameter llsDataFim to spParameters[4].ValueTree
81619>>>>>>>
81619>>>>>>>        Set pspParameters to spParameters
81620>>>>>>>
81620>>>>>>>        // Return Parameter
81620>>>>>>>        Get DefineStructParameter oWStListaGuias 1 1 "BuscaTodasGuiasPendentesResult" "http://guiasgnre/webgnre" to spReturnParameters[0].SoapParamDef
81621>>>>>>>        Set pspReturnParameters to spReturnParameters
81622>>>>>>>
81622>>>>>>>        Get DoInvokeService to eStatus
81623>>>>>>>        If (eStatus=wssOK) Begin
81625>>>>>>>            Get pspReturnParameters   to spReturnParameters
81626>>>>>>>            ValueTreeDeserializeParameter spReturnParameters[0].ValueTree to llBuscaTodasGuiasPendentesResult
81627>>>>>>>        end
81627>>>>>>>>
81627>>>>>>>        Else Begin
81628>>>>>>>            Send LastError
81629>>>>>>>        end
81629>>>>>>>>
81629>>>>>>>
81629>>>>>>>        Function_return llBuscaTodasGuiasPendentesResult
81630>>>>>>>    End_Function // wsBuscaTodasGuiasPendentes
81631>>>>>>>
81631>>>>>>>    // 
81631>>>>>>>    // Procedure wsBuscaTodasGuiasComErro
81631>>>>>>>    // 
81631>>>>>>>    // Busca todas as guias que estÆo com erro, com status 'Erro', exceto aquelas com
81631>>>>>>>    // status 'Transmitida' ou 'Aguardando', e nÆo foram retornadas no momento do
81631>>>>>>>    // envio do lote das notas. Se informado data de inicio e fim da emissÆo da nota,
81631>>>>>>>    // filtra apenas guias nesse intervalo de tempo. Se informado apenas data de
81631>>>>>>>    // in¡cio, filtra todas a partir desta data. Se informado apenas data final,
81631>>>>>>>    // filtra todas as guias at‚ esta data. Se nÆo informar nenhuma data, retorna
81631>>>>>>>    // todas as guias com status 'Transmitida' ou 'Aguardando'. Lista de c¢digos de
81631>>>>>>>    // retorno: 0 = Sucesso | 1 = NÆo autorizado. Verifique o CNPJ, Usu rio e Token. |
81631>>>>>>>    // 2 = Lote processado com pendˆncias. | 3 = Nenhuma guia liberada no momento. | 6
81631>>>>>>>    // = Data inicial inv lida. PadrÆo esperado: AAAA-MM-DD. | 7 = Data final
81631>>>>>>>    // inv lida. PadrÆo esperado: AAAA-MM-DD.
81631>>>>>>>    // 
81631>>>>>>>    Function wsBuscaTodasGuiasComErro string llsEmpresa string llsUsuario string llsChaveApi string llsDataInicio string llsDataFim Returns tWStListaGuias
81633>>>>>>>        tWStListaGuias llBuscaTodasGuiasComErroResult
81633>>>>>>>        tWStListaGuias llBuscaTodasGuiasComErroResult
81633>>>>>>>        tSoapParameter[] spParameters
81633>>>>>>>        tSoapParameter[] spParameters
81634>>>>>>>        tSoapParameter[] spReturnParameters
81634>>>>>>>        tSoapParameter[] spReturnParameters
81635>>>>>>>        integer eStatus
81635>>>>>>>
81635>>>>>>>        Send Reset
81636>>>>>>>        Set psSOAPAction           to ""
81637>>>>>>>        Set peSoapStyle            to ssDocument
81638>>>>>>>
81638>>>>>>>        Set psRequestNSURI         to "http://guiasgnre/webgnre"
81639>>>>>>>        Set peSoapEncoding         to seLiteral
81640>>>>>>>        Set psMethodRequest        to "BuscaTodasGuiasComErro"
81641>>>>>>>        Set pbRequestBare          to false
81642>>>>>>>
81642>>>>>>>        Set psResponseNSURI        to "http://guiasgnre/webgnre"
81643>>>>>>>        Set peResponseSoapEncoding to seLiteral
81644>>>>>>>        Set psMethodResponse       to "BuscaTodasGuiasComErroResponse"
81645>>>>>>>        Set pbResponseBare         to false
81646>>>>>>>
81646>>>>>>>        // Parameter 0
81646>>>>>>>        Get DefineParameter xsString 1 1 "sEmpresa" "http://guiasgnre/webgnre" to spParameters[0].SoapParamDef 
81647>>>>>>>        ValueTreeSerializeParameter llsEmpresa to spParameters[0].ValueTree
81648>>>>>>>
81648>>>>>>>        // Parameter 1
81648>>>>>>>        Get DefineParameter xsString 1 1 "sUsuario" "http://guiasgnre/webgnre" to spParameters[1].SoapParamDef 
81649>>>>>>>        ValueTreeSerializeParameter llsUsuario to spParameters[1].ValueTree
81650>>>>>>>
81650>>>>>>>        // Parameter 2
81650>>>>>>>        Get DefineParameter xsString 1 1 "sChaveApi" "http://guiasgnre/webgnre" to spParameters[2].SoapParamDef 
81651>>>>>>>        ValueTreeSerializeParameter llsChaveApi to spParameters[2].ValueTree
81652>>>>>>>
81652>>>>>>>        // Parameter 3
81652>>>>>>>        Get DefineParameter xsString 1 1 "sDataInicio" "http://guiasgnre/webgnre" to spParameters[3].SoapParamDef 
81653>>>>>>>        ValueTreeSerializeParameter llsDataInicio to spParameters[3].ValueTree
81654>>>>>>>
81654>>>>>>>        // Parameter 4
81654>>>>>>>        Get DefineParameter xsString 1 1 "sDataFim" "http://guiasgnre/webgnre" to spParameters[4].SoapParamDef 
81655>>>>>>>        ValueTreeSerializeParameter llsDataFim to spParameters[4].ValueTree
81656>>>>>>>
81656>>>>>>>        Set pspParameters to spParameters
81657>>>>>>>
81657>>>>>>>        // Return Parameter
81657>>>>>>>        Get DefineStructParameter oWStListaGuias 1 1 "BuscaTodasGuiasComErroResult" "http://guiasgnre/webgnre" to spReturnParameters[0].SoapParamDef
81658>>>>>>>        Set pspReturnParameters to spReturnParameters
81659>>>>>>>
81659>>>>>>>        Get DoInvokeService to eStatus
81660>>>>>>>        If (eStatus=wssOK) Begin
81662>>>>>>>            Get pspReturnParameters   to spReturnParameters
81663>>>>>>>            ValueTreeDeserializeParameter spReturnParameters[0].ValueTree to llBuscaTodasGuiasComErroResult
81664>>>>>>>        end
81664>>>>>>>>
81664>>>>>>>        Else Begin
81665>>>>>>>            Send LastError
81666>>>>>>>        end
81666>>>>>>>>
81666>>>>>>>
81666>>>>>>>        Function_return llBuscaTodasGuiasComErroResult
81667>>>>>>>    End_Function // wsBuscaTodasGuiasComErro
81668>>>>>>>
81668>>>>>>>    // 
81668>>>>>>>    // Procedure wsBuscaGuia
81668>>>>>>>    // 
81668>>>>>>>    // Busca Guia(s) espec¡fica(s) atrav‚s do CNPJ do emitente e do n£mero do recibo
81668>>>>>>>    // (que pode ser mais de um), independente do status da guia. Lista de Erros: 0 =
81668>>>>>>>    // Sucesso | 1 = NÆo autorizado, Verifique o CNPJ, Usu rio e Token. | 2 = Lote
81668>>>>>>>    // processado com pendˆncias. | 3 = Nenhuma guia liberada no momento.
81668>>>>>>>    // 
81668>>>>>>>    Function wsBuscaGuia string llsEmpresa string llsUsuario string llsChaveApi tWStRetornoLote llLote Returns tWStListaGuias
81670>>>>>>>        tWStListaGuias llBuscaGuiaResult
81670>>>>>>>        tWStListaGuias llBuscaGuiaResult
81670>>>>>>>        tSoapParameter[] spParameters
81670>>>>>>>        tSoapParameter[] spParameters
81671>>>>>>>        tSoapParameter[] spReturnParameters
81671>>>>>>>        tSoapParameter[] spReturnParameters
81672>>>>>>>        integer eStatus
81672>>>>>>>
81672>>>>>>>        Send Reset
81673>>>>>>>        Set psSOAPAction           to ""
81674>>>>>>>        Set peSoapStyle            to ssDocument
81675>>>>>>>
81675>>>>>>>        Set psRequestNSURI         to "http://guiasgnre/webgnre"
81676>>>>>>>        Set peSoapEncoding         to seLiteral
81677>>>>>>>        Set psMethodRequest        to "BuscaGuia"
81678>>>>>>>        Set pbRequestBare          to false
81679>>>>>>>
81679>>>>>>>        Set psResponseNSURI        to "http://guiasgnre/webgnre"
81680>>>>>>>        Set peResponseSoapEncoding to seLiteral
81681>>>>>>>        Set psMethodResponse       to "BuscaGuiaResponse"
81682>>>>>>>        Set pbResponseBare         to false
81683>>>>>>>
81683>>>>>>>        // Parameter 0
81683>>>>>>>        Get DefineParameter xsString 1 1 "sEmpresa" "http://guiasgnre/webgnre" to spParameters[0].SoapParamDef 
81684>>>>>>>        ValueTreeSerializeParameter llsEmpresa to spParameters[0].ValueTree
81685>>>>>>>
81685>>>>>>>        // Parameter 1
81685>>>>>>>        Get DefineParameter xsString 1 1 "sUsuario" "http://guiasgnre/webgnre" to spParameters[1].SoapParamDef 
81686>>>>>>>        ValueTreeSerializeParameter llsUsuario to spParameters[1].ValueTree
81687>>>>>>>
81687>>>>>>>        // Parameter 2
81687>>>>>>>        Get DefineParameter xsString 1 1 "sChaveApi" "http://guiasgnre/webgnre" to spParameters[2].SoapParamDef 
81688>>>>>>>        ValueTreeSerializeParameter llsChaveApi to spParameters[2].ValueTree
81689>>>>>>>
81689>>>>>>>        // Parameter 3
81689>>>>>>>        Get DefineStructParameter oWStRetornoLote 1 1 "Lote" "http://guiasgnre/webgnre" to spParameters[3].SoapParamDef 
81690>>>>>>>        ValueTreeSerializeParameter llLote to spParameters[3].ValueTree
81691>>>>>>>
81691>>>>>>>        Set pspParameters to spParameters
81692>>>>>>>
81692>>>>>>>        // Return Parameter
81692>>>>>>>        Get DefineStructParameter oWStListaGuias 1 1 "BuscaGuiaResult" "http://guiasgnre/webgnre" to spReturnParameters[0].SoapParamDef
81693>>>>>>>        Set pspReturnParameters to spReturnParameters
81694>>>>>>>
81694>>>>>>>        Get DoInvokeService to eStatus
81695>>>>>>>        If (eStatus=wssOK) Begin
81697>>>>>>>            Get pspReturnParameters   to spReturnParameters
81698>>>>>>>            ValueTreeDeserializeParameter spReturnParameters[0].ValueTree to llBuscaGuiaResult
81699>>>>>>>        end
81699>>>>>>>>
81699>>>>>>>        Else Begin
81700>>>>>>>            Send LastError
81701>>>>>>>        end
81701>>>>>>>>
81701>>>>>>>
81701>>>>>>>        Function_return llBuscaGuiaResult
81702>>>>>>>    End_Function // wsBuscaGuia
81703>>>>>>>
81703>>>>>>>    // 
81703>>>>>>>    // Procedure wsBuscaGuiaPDF
81703>>>>>>>    // 
81703>>>>>>>    // Busca Guia(s) espec¡fica(s) atrav‚s do CNPJ do emitente e do n£mero do recibo
81703>>>>>>>    // (que pode ser mais de um), independente do status da guia. Lista de c¢digos de
81703>>>>>>>    // retorno: 0 = Sucesso | 1 = NÆo autorizado, Verifique o CNPJ, Usu rio e Token. |
81703>>>>>>>    // 2 = Lote processado com pendˆncias. | 3 = Erro ao transmitir o lote de guias. |
81703>>>>>>>    // 4 = Falha ao buscar guias. | 5 = Falha ao gerar o PDF.
81703>>>>>>>    // 
81703>>>>>>>    Function wsBuscaGuiaPDF string llsEmpresa string llsUsuario string llsChaveApi tWStRetornoLote llLote Returns tWStRetornoLotePDF
81705>>>>>>>        tWStRetornoLotePDF llBuscaGuiaPDFResult
81705>>>>>>>        tWStRetornoLotePDF llBuscaGuiaPDFResult
81705>>>>>>>        tSoapParameter[] spParameters
81705>>>>>>>        tSoapParameter[] spParameters
81706>>>>>>>        tSoapParameter[] spReturnParameters
81706>>>>>>>        tSoapParameter[] spReturnParameters
81707>>>>>>>        integer eStatus
81707>>>>>>>
81707>>>>>>>        Send Reset
81708>>>>>>>        Set psSOAPAction           to ""
81709>>>>>>>        Set peSoapStyle            to ssDocument
81710>>>>>>>
81710>>>>>>>        Set psRequestNSURI         to "http://guiasgnre/webgnre"
81711>>>>>>>        Set peSoapEncoding         to seLiteral
81712>>>>>>>        Set psMethodRequest        to "BuscaGuiaPDF"
81713>>>>>>>        Set pbRequestBare          to false
81714>>>>>>>
81714>>>>>>>        Set psResponseNSURI        to "http://guiasgnre/webgnre"
81715>>>>>>>        Set peResponseSoapEncoding to seLiteral
81716>>>>>>>        Set psMethodResponse       to "BuscaGuiaPDFResponse"
81717>>>>>>>        Set pbResponseBare         to false
81718>>>>>>>
81718>>>>>>>        // Parameter 0
81718>>>>>>>        Get DefineParameter xsString 1 1 "sEmpresa" "http://guiasgnre/webgnre" to spParameters[0].SoapParamDef 
81719>>>>>>>        ValueTreeSerializeParameter llsEmpresa to spParameters[0].ValueTree
81720>>>>>>>
81720>>>>>>>        // Parameter 1
81720>>>>>>>        Get DefineParameter xsString 1 1 "sUsuario" "http://guiasgnre/webgnre" to spParameters[1].SoapParamDef 
81721>>>>>>>        ValueTreeSerializeParameter llsUsuario to spParameters[1].ValueTree
81722>>>>>>>
81722>>>>>>>        // Parameter 2
81722>>>>>>>        Get DefineParameter xsString 1 1 "sChaveApi" "http://guiasgnre/webgnre" to spParameters[2].SoapParamDef 
81723>>>>>>>        ValueTreeSerializeParameter llsChaveApi to spParameters[2].ValueTree
81724>>>>>>>
81724>>>>>>>        // Parameter 3
81724>>>>>>>        Get DefineStructParameter oWStRetornoLote 1 1 "Lote" "http://guiasgnre/webgnre" to spParameters[3].SoapParamDef 
81725>>>>>>>        ValueTreeSerializeParameter llLote to spParameters[3].ValueTree
81726>>>>>>>
81726>>>>>>>        Set pspParameters to spParameters
81727>>>>>>>
81727>>>>>>>        // Return Parameter
81727>>>>>>>        Get DefineStructParameter oWStRetornoLotePDF 1 1 "BuscaGuiaPDFResult" "http://guiasgnre/webgnre" to spReturnParameters[0].SoapParamDef
81728>>>>>>>        Set pspReturnParameters to spReturnParameters
81729>>>>>>>
81729>>>>>>>        Get DoInvokeService to eStatus
81730>>>>>>>        If (eStatus=wssOK) Begin
81732>>>>>>>            Get pspReturnParameters   to spReturnParameters
81733>>>>>>>            ValueTreeDeserializeParameter spReturnParameters[0].ValueTree to llBuscaGuiaPDFResult
81734>>>>>>>        end
81734>>>>>>>>
81734>>>>>>>        Else Begin
81735>>>>>>>            Send LastError
81736>>>>>>>        end
81736>>>>>>>>
81736>>>>>>>
81736>>>>>>>        Function_return llBuscaGuiaPDFResult
81737>>>>>>>    End_Function // wsBuscaGuiaPDF
81738>>>>>>>
81738>>>>>>>    // 
81738>>>>>>>    // Procedure wsAssinatura_gratis
81738>>>>>>>    // 
81738>>>>>>>    // Assinatura Gr tis ‚ utilizado para criar o cadastro do utilizador do servi‡o.
81738>>>>>>>    // Tabela de erros: 0 = Sucesso | 1 = Login nÆo ‚ um e-mail v lido. | 2 = Login em
81738>>>>>>>    // uso, tente outro. | 3 = Senha deve estar entre 6 e 10 d¡gitos. | 4 = RazÆo
81738>>>>>>>    // Social nÆo pode estar em branco. | 5 = Fantasia nÆo pode estar em branco. | 6 =
81738>>>>>>>    // Telefone deve estar entre 10 e 11 d¡gitos. | 7 = Cep deve conter 8 d¡gitos. | 8
81738>>>>>>>    // = Logradouro nÆo pode estar em branco. | 9 = Nro nÆo pode ficar em branco, caso
81738>>>>>>>    // nao tenha n£mero no endere‡o, preencher com S/N. | 10 = Bairro nÆo pode estar
81738>>>>>>>    // em branco. | 11 = C¢digo da UF ‚ inv lido. | 12 = C¢digo do Munic¡pio ‚
81738>>>>>>>    // inv lido. | 13 = Telefone cont‚m dig¡tos nÆo num‚ricos. | 14 = CEP cont‚m
81738>>>>>>>    // dig¡tos nÆo num‚ricos. | 15 = CNPJ ‚ inv lido. | 16 = CNPJ em uso por outra
81738>>>>>>>    // assinatura. | 17 = Nome do respons vel pela assinatura nÆo pode estar em
81738>>>>>>>    // branco. | 18 = Erro ao gravar a conta do usu rio. | 19 = Erro ao gravar os
81738>>>>>>>    // dados da empresa. | 20 = Erro ao criar a assinatura na forma de pagamento
81738>>>>>>>    // gr tis.
81738>>>>>>>    // 
81738>>>>>>>    Function wsAssinatura_gratis tWStAssinatura llAssinatura Returns tWStRetornoAssinatura
81740>>>>>>>        tWStRetornoAssinatura llAssinatura_gratisResult
81740>>>>>>>        tWStRetornoAssinatura llAssinatura_gratisResult
81740>>>>>>>        tSoapParameter[] spParameters
81740>>>>>>>        tSoapParameter[] spParameters
81741>>>>>>>        tSoapParameter[] spReturnParameters
81741>>>>>>>        tSoapParameter[] spReturnParameters
81742>>>>>>>        integer eStatus
81742>>>>>>>
81742>>>>>>>        Send Reset
81743>>>>>>>        Set psSOAPAction           to ""
81744>>>>>>>        Set peSoapStyle            to ssDocument
81745>>>>>>>
81745>>>>>>>        Set psRequestNSURI         to "http://guiasgnre/webgnre"
81746>>>>>>>        Set peSoapEncoding         to seLiteral
81747>>>>>>>        Set psMethodRequest        to "Assinatura_gratis"
81748>>>>>>>        Set pbRequestBare          to false
81749>>>>>>>
81749>>>>>>>        Set psResponseNSURI        to "http://guiasgnre/webgnre"
81750>>>>>>>        Set peResponseSoapEncoding to seLiteral
81751>>>>>>>        Set psMethodResponse       to "Assinatura_gratisResponse"
81752>>>>>>>        Set pbResponseBare         to false
81753>>>>>>>
81753>>>>>>>        // Parameter 0
81753>>>>>>>        Get DefineStructParameter oWStAssinatura 1 1 "Assinatura" "http://guiasgnre/webgnre" to spParameters[0].SoapParamDef 
81754>>>>>>>        ValueTreeSerializeParameter llAssinatura to spParameters[0].ValueTree
81755>>>>>>>
81755>>>>>>>        Set pspParameters to spParameters
81756>>>>>>>
81756>>>>>>>        // Return Parameter
81756>>>>>>>        Get DefineStructParameter oWStRetornoAssinatura 1 1 "Assinatura_gratisResult" "http://guiasgnre/webgnre" to spReturnParameters[0].SoapParamDef
81757>>>>>>>        Set pspReturnParameters to spReturnParameters
81758>>>>>>>
81758>>>>>>>        Get DoInvokeService to eStatus
81759>>>>>>>        If (eStatus=wssOK) Begin
81761>>>>>>>            Get pspReturnParameters   to spReturnParameters
81762>>>>>>>            ValueTreeDeserializeParameter spReturnParameters[0].ValueTree to llAssinatura_gratisResult
81763>>>>>>>        end
81763>>>>>>>>
81763>>>>>>>        Else Begin
81764>>>>>>>            Send LastError
81765>>>>>>>        end
81765>>>>>>>>
81765>>>>>>>
81765>>>>>>>        Function_return llAssinatura_gratisResult
81766>>>>>>>    End_Function // wsAssinatura_gratis
81767>>>>>>>
81767>>>>>>>End_Class // cWSGeraGuiaGnre
81768>>>>>>>
81768>>>>>
81768>>>>>
81768>>>>>Function GGGCriaAssinatura_Gratis  Global tWStAssinatura GGG_Assinatura Returns tWStRetornoAssinatura
81770>>>>>
81770>>>>>    Handle hgeraguiagnre  // handle do objeto
81770>>>>>    tWStRetornoAssinatura RetornoAssinatura
81770>>>>>    tWStRetornoAssinatura RetornoAssinatura
81770>>>>>    
81770>>>>>    Get create u_cWSGeraGuiaGnre to hgeraguiagnre
81771>>>>>    If not hgeraguiagnre ;    Begin
81773>>>>>        Send Info_Box 'Erro ao criar o objeto da classe cWSGeraGuiaGnre !'
81774>>>>>        Procedure_Return
81775>>>>>    End
81775>>>>>>
81775>>>>>    
81775>>>>>    Get wsAssinatura_gratis of hgeraguiagnre GGG_Assinatura to RetornoAssinatura
81776>>>>>        
81776>>>>>    Send Destroy_Object hgeraguiagnre
81777>>>>>    
81777>>>>>    Function_Return RetornoAssinatura
81778>>>>>End_Function
81779>>>
81779>>>Deferred_View Activate_oExemplo for ;Object oExemplo is a dbView
81804>>>
81804>>>    Set Border_Style to Border_Thick
81805>>>    // DataFlex 18.2 Client Size Adjuster, modified April 22, 2016: 10:50:12
81805>>>//    Set Size to 305 419
81805>>>    Set Size to 295 247
81806>>>    Set Location to 6 7
81807>>>    Set Label to "Exemplo da fun‡Æo GGGCriaAssinatura_Gratis"
81808>>>
81808>>>    Object oUsuario is a Form
81810>>>        Set Size to 13 200
81811>>>        Set Location to 14 9
81812>>>        Set Label to "Nome do Respons vel pela Assinatura:"
81813>>>        //Set peAnchors to anAll
81813>>>        Set FontWeight to 600
81814>>>        Set Label_Col_Offset to 0
81815>>>        Set Label_Justification_Mode to JMode_Top
81816>>>    End_Object
81817>>>
81817>>>    Object oLogin is a Form
81819>>>        Set Size to 13 200
81820>>>        Set Location to 38 9
81821>>>        Set Label to "Login (endere‡o de e-mail para acesso ao portal):"
81822>>>        //Set peAnchors to anAll
81822>>>        Set FontWeight to 600
81823>>>        Set Label_Col_Offset to 0
81824>>>        Set Label_Justification_Mode to JMode_Top
81825>>>    End_Object
81826>>>
81826>>>    Object oSenha is a Form
81828>>>        Set Size to 13 200
81829>>>        Set Location to 62 9
81830>>>        Set Label to "Senha para acesso ao portal:"
81831>>>        //Set peAnchors to anAll
81831>>>        Set FontWeight to 600    
81832>>>        Set Label_Col_Offset to 0
81833>>>        Set Label_Justification_Mode to JMode_Top
81834>>>    End_Object
81835>>>
81835>>>    Object oRazao is a Form
81837>>>        Set Size to 13 200
81838>>>        Set Location to 86 9
81839>>>        Set Label to "RazÆo Social da Empresa:"
81840>>>        //Set peAnchors to anAll
81840>>>        Set FontWeight to 600
81841>>>        Set Label_Col_Offset to 0
81842>>>        Set Label_Justification_Mode to JMode_Top
81843>>>    End_Object
81844>>>
81844>>>    Object oFantasia is a Form
81846>>>        Set Size to 13 200
81847>>>        Set Location to 110 9
81848>>>        Set Label to "Nome Fantasia:"
81849>>>        //Set peAnchors to anAll
81849>>>        Set FontWeight to 600
81850>>>        Set Label_Col_Offset to 0
81851>>>        Set Label_Justification_Mode to JMode_Top
81852>>>    End_Object
81853>>>
81853>>>    Object otelefone is a Form
81855>>>        Set Size to 13 91
81856>>>        Set Location to 134 9
81857>>>        Set Label to "Telefone de Contato da Empresa:"
81858>>>        //Set peAnchors to anAll
81858>>>        Set FontWeight to 600
81859>>>        Set Label_Col_Offset to 0
81860>>>        Set Label_Justification_Mode to JMode_Top
81861>>>    End_Object
81862>>>
81862>>>    Object oCEP is a Form
81864>>>        Set Size to 13 91
81865>>>        Set Location to 134 134
81866>>>        Set Label to "CEP da Empresa:"
81867>>>        //Set peAnchors to anAll
81867>>>        Set FontWeight to 600
81868>>>        Set Label_Col_Offset to 0
81869>>>        Set Label_Justification_Mode to JMode_Top
81870>>>    End_Object
81871>>>
81871>>>    Object oLogradouro is a Form
81873>>>        Set Size to 13 200
81874>>>        Set Location to 158 9
81875>>>        Set Label to "Logradouro da Empresa:"
81876>>>        //Set peAnchors to anAll
81876>>>        Set FontWeight to 600
81877>>>        Set Label_Col_Offset to 0
81878>>>        Set Label_Justification_Mode to JMode_Top
81879>>>    End_Object
81880>>>
81880>>>
81880>>>    Object oNumero is a Form
81882>>>        Set Size to 13 91
81883>>>        Set Location to 182 9
81884>>>        Set Label to "N£mero:"
81885>>>        //Set peAnchors to anAll
81885>>>        Set FontWeight to 600
81886>>>        Set Label_Col_Offset to 0
81887>>>        Set Label_Justification_Mode to JMode_Top
81888>>>    End_Object
81889>>>
81889>>>
81889>>>    Object oComplemento is a Form
81891>>>        Set Size to 13 91
81892>>>        Set Location to 182 134
81893>>>        Set Label to "Complemento:"
81894>>>        //Set peAnchors to anAll
81894>>>        Set FontWeight to 600
81895>>>        Set Label_Col_Offset to 0
81896>>>        Set Label_Justification_Mode to JMode_Top
81897>>>    End_Object
81898>>>
81898>>>    Object oBairro is a Form
81900>>>        Set Size to 13 200
81901>>>        Set Location to 206 9
81902>>>        Set Label to "Bairro:"
81903>>>        //Set peAnchors to anAll
81903>>>        Set FontWeight to 600
81904>>>        Set Label_Col_Offset to 0
81905>>>        Set Label_Justification_Mode to JMode_Top
81906>>>    End_Object
81907>>>
81907>>>    Object oUf is a Form
81909>>>        Set Size to 13 91
81910>>>        Set Location to 230 9
81911>>>        Set Label to "C¢digo IBGE ou Sigla da UF:"
81912>>>        //Set peAnchors to anAll
81912>>>        Set FontWeight to 600
81913>>>        Set Capslock_State to True
81914>>>        Set Label_Col_Offset to 0
81915>>>        Set Label_Justification_Mode to JMode_Top
81916>>>    End_Object
81917>>>
81917>>>    Object oCidade is a Form
81919>>>        Set Size to 13 91
81920>>>        Set Location to 230 134
81921>>>        Set Label to "C¢digo IBGE da Cidade:"
81922>>>        //Set peAnchors to anAll
81922>>>        Set FontWeight to 600
81923>>>        Set Label_Col_Offset to 0
81924>>>        Set Label_Justification_Mode to JMode_Top
81925>>>    End_Object
81926>>>
81926>>>    Object oCNPJ is a Form
81928>>>        Set Size to 13 91
81929>>>        Set Location to 254 9
81930>>>        Set Label to "CNPJ da Empresa:"
81931>>>        //Set peAnchors to anAll
81931>>>        Set FontWeight to 600    
81932>>>        Set Label_Col_Offset to 0
81933>>>        Set Label_Justification_Mode to JMode_Top
81934>>>    End_Object
81935>>>
81935>>>
81935>>>    Object oButton1 is a Button
81937>>>        Set Location to 254 134
81938>>>        Set Label to "Criar conta"
81939>>>    
81939>>>        // fires when the button is clicked
81939>>>        Procedure OnClick
81942>>>            tWStAssinatura Assinatura
81942>>>            tWStAssinatura Assinatura
81942>>>            tWStRetornoAssinatura RetornoAssinatura
81942>>>            tWStRetornoAssinatura RetornoAssinatura
81942>>>            
81942>>>            Get value of oLogin         to Assinatura.Login
81943>>>            Get value of oSenha         to Assinatura.Senha
81944>>>            Get value of oRazao         to Assinatura.Razao
81945>>>            Get value of ofantasia      to Assinatura.Fantasia
81946>>>            Get value of otelefone      to Assinatura.Telefone
81947>>>            Get value of oCep           to Assinatura.Cep
81948>>>            Get value of oLogradouro    to Assinatura.Logradouro
81949>>>            Get value of oNumero        to Assinatura.Nro
81950>>>            Get value of oComplemento   to Assinatura.Complemento
81951>>>            Get value of oBairro        to Assinatura.Bairro
81952>>>            Get value of oCidade        to Assinatura.Codigo_Cidade
81953>>>            Get value of oUf            to Assinatura.Codigo_UF
81954>>>            Get value of oCNPJ          to Assinatura.CNPJ
81955>>>            Get value of oUsuario       to Assinatura.Nome
81956>>>            
81956>>>            Get GGGCriaAssinatura_Gratis Assinatura to RetornoAssinatura
81957>>>            
81957>>>            If (RetornoAssinatura.Retorno > 0);            Begin
81959>>>                Send Info_Box ("C¢digo do erro: " + (RetornoAssinatura.Retorno) + "\nDescri‡Æo: " + (RetornoAssinatura.Msg_retorno)) "Falha na cria‡Æo da conta"
81960>>>            End
81960>>>>
81960>>>            Else Begin
81961>>>                // grave o sToken ou guarde para utilizar com as outras fun‡äes.
81961>>>                // Se precisar consultar o token gerado entre em https://www.guiasgnre.com.br/webgnre
81961>>>                Send Info_Box ("Seu Token de acesso a API: " + (RetornoAssinatura.TokenAPI)) 'Assinatura criada com sucesso.' 
81962>>>                Set Value of oToken to (RetornoAssinatura.TokenAPI)
81963>>>            End
81963>>>>
81963>>>                        
81963>>>        End_Procedure
81964>>>    
81964>>>    End_Object
81965>>>
81965>>>    Object oToken is a Form
81967>>>        Set Size to 13 231
81968>>>        Set Location to 278 9
81969>>>        Set Label to "Token API:"
81970>>>        Set Label_Col_Offset to 0
81971>>>        Set Label_Justification_Mode to JMode_Top
81972>>>    End_Object
81973>>>
81973>>>
81973>>>Cd_End_Object
81975>>>>
81975>>>
81975>        Use Views\exemplo2.vw
Including file: Views\exemplo2.vw    (C:\DataFlex Projects\GNRELibrary\AppSrc\Views\exemplo2.vw)
81975>>>Use Windows.pkg
81975>>>Use DFClient.pkg
81975>>>Use File_dlg.pkg
81975>>>Use Pacotes\GGGLerXmls.pkg
Including file: Pacotes\GGGLerXmls.pkg    (C:\DataFlex Projects\GNRELibrary\AppSrc\Pacotes\GGGLerXmls.pkg)
81975>>>>>//----------------------------------------------------------------------------------------------
81975>>>>>// Autor ....: Alexandro Maule - Harsy Sistemas
81975>>>>>// Criado em : 25/04/2016
81975>>>>>// VersÆo 0.0.1
81975>>>>>//----------------------------------------------------------------------------------------------
81975>>>>>// Parametros:
81975>>>>>// 1 - Array com a lista dos xmls a serem carregados.
81975>>>>>// 2 - CNPJ do emitente.
81975>>>>>//----------------------------------------------------------------------------------------------
81975>>>>>// Retorno:
81975>>>>>// Retorna uma array com os dados das NFe's a serem gerados.
81975>>>>>//----------------------------------------------------------------------------------------------
81975>>>>>// Observa‡äes:
81975>>>>>// As xmls das NFe's que nÆo estiverem autorizadas, serÆo descartadas sem nenhum aviso de erro.
81975>>>>>//----------------------------------------------------------------------------------------------
81975>>>>>
81975>>>>>Use Pacotes\cWSGeraGuiaGnre.pkg
81975>>>>>Use Flexml.pkg
81975>>>>>
81975>>>>>Function GGGLerXmls Global String[] saListaXmls String sCNPJ Returns tWStListaNfe
81977>>>>>    tWStListaNfe NFEs       // Dados para retorno
81977>>>>>    tWStListaNfe NFEs       // Dados para retorno
81977>>>>>    Integer iContador       // Auxiliar para loop
81977>>>>>    Integer iQtd_nfes       // Auxiliar para posicionar
81977>>>>>    Handle  hoXml           // Objeto xml
81977>>>>>    Handle  hoNFe           // Receber  o Id do elemento NFe
81977>>>>>    Handle  hoprotNFe       // Receber  o Id do elemento protNFe
81977>>>>>    Handle  hoinfProt       // Receber  o Id do elemento infProt
81977>>>>>    Handle  hoRoot          // Receber  o Id do elemento root
81977>>>>>    Handle  hoInfNFe        // Receber  o Id do elemento infNFe
81977>>>>>    Handle  hoTotal         // Receber  o Id do elemento total
81977>>>>>    Handle  hoICMSTot       // Receber  o Id do elemento ICMStot
81977>>>>>    Handle  hoDest          // Receber  o Id do elemento Dest
81977>>>>>    Handle  hoEnderDest     // Receber  o Id do elemento EnderDest
81977>>>>>    Handle  hoide           // Receber  o Id do elemento ide
81977>>>>>    Handle  hoAux           // Handle tempor rio
81977>>>>>    Boolean bOk             
81977>>>>>    String  sAux            // Nome do xml
81977>>>>>    String  sValor          // Recebe valores USA e converte para BR
81977>>>>>    
81977>>>>>    Boolean existe_arquivo
81977>>>>>    
81977>>>>>    For iContador from 0 to ((SizeOfArray(saListaXmls)) - 1)
81983>>>>>>
81983>>>>>        File_Exist saListaXmls[iContador] existe_arquivo
81984>>>>>        If existe_arquivo ;        Begin
81986>>>>>            Move saListaXmls[iContador] to sAux
81987>>>>>            Get Create U_cXMLDOMDocument to hoXml
81988>>>>>            If not hoXml Function_Return NFEs                        
81991>>>>>
81991>>>>>//            Set pbPreserveWhiteSpace of hoXML to False
81991>>>>>            Set psDocumentName of hoXML to sAux
81992>>>>>            Get LoadXMLDocument of hoXML to bOk
81993>>>>>
81993>>>>>            If bok;            Begin            
81995>>>>>            // Obtendo elemento root 
81995>>>>>                Get DocumentElement of hoXML to hoRoot
81996>>>>>                Get ChildElementNS of hoRoot "http://www.portalfiscal.inf.br/nfe" "NFe" to hoNFe
81997>>>>>                Get ChildElementNS of hoRoot "http://www.portalfiscal.inf.br/nfe" "protNFe" to hoprotNFe
81998>>>>>                If (hoNFe and hoprotNFe) ;                Begin
82000>>>>>                    Get ChildElementNS of hoNFe "http://www.portalfiscal.inf.br/nfe" "infNFe" to hoInfNFe
82001>>>>>                    If hoInfNFe ;                    Begin
82003>>>>>                        Get ChildElementNS of hoInfNFe "http://www.portalfiscal.inf.br/nfe" "dest" to hoDest
82004>>>>>                        If hoDest ;                        Begin
82006>>>>>                            Get ChildElementNS of hoDest "http://www.portalfiscal.inf.br/nfe" "CNPJ" to hoAux
82007>>>>>                            If hoAux ;                            Begin
82009>>>>>                                Get psText of hoaux to NFEs.itens[iQtd_nfes].cnpj
82010>>>>>                                Send Destroy of hoAux
82011>>>>>                            End
82011>>>>>>
82011>>>>>                            Else ;                            Begin
82012>>>>>                                Get ChildElementNS of hoDest "http://www.portalfiscal.inf.br/nfe" "CPF" to hoAux
82013>>>>>                                Get psText of hoaux to NFEs.itens[iQtd_nfes].cpf
82014>>>>>                                Send Destroy of hoAux
82015>>>>>                            End
82015>>>>>>
82015>>>>>                            
82015>>>>>                            Move 0 to hoAux
82016>>>>>                            Get ChildElementNS of hoDest "http://www.portalfiscal.inf.br/nfe" "xNome" to hoAux
82017>>>>>                            Get psText of hoaux to NFEs.itens[iQtd_nfes].nome_destinatario
82018>>>>>                            Send Destroy of hoAux
82019>>>>>
82019>>>>>                            
82019>>>>>                            Get ChildElementNS of hoDest "http://www.portalfiscal.inf.br/nfe" "enderDest" to hoEnderDest
82020>>>>>                            
82020>>>>>                            If hoEnderDest ;                            Begin
82022>>>>>                                Get ChildElementNS of hoEnderDest "http://www.portalfiscal.inf.br/nfe" "cMun" to hoAux
82023>>>>>                                Get psText of hoaux to NFEs.itens[iQtd_nfes].cod_municipio_destinat
82024>>>>>                                Send Destroy of hoAux
82025>>>>>                                
82025>>>>>                                Get ChildElementNS of hoEnderDest "http://www.portalfiscal.inf.br/nfe" "UF" to hoAux
82026>>>>>                                Get psText of hoaux to NFEs.itens[iQtd_nfes].uf_destinatario
82027>>>>>                                Send Destroy of hoAux
82028>>>>>                                Send Destroy of hoEnderDest
82029>>>>>
82029>>>>>                            End
82029>>>>>>
82029>>>>>
82029>>>>>                            Get ChildElementNS of hoprotNFe "http://www.portalfiscal.inf.br/nfe" "infProt" to hoinfProt
82030>>>>>                            If hoinfProt ;                            Begin
82032>>>>>                                Get ChildElementNS of hoinfProt "http://www.portalfiscal.inf.br/nfe" "chNFe" to hoAux
82033>>>>>                                Get psText of hoaux to NFEs.itens[iQtd_nfes].chave_nfe
82034>>>>>                                Send Destroy of hoAux
82035>>>>>                                Send Destroy of hoinfProt
82036>>>>>                            End
82036>>>>>>
82036>>>>>                            
82036>>>>>                            Get ChildElementNS of hoInfNFe "http://www.portalfiscal.inf.br/nfe" "ide" to hoide
82037>>>>>
82037>>>>>                            Get ChildElementNS of hoide "http://www.portalfiscal.inf.br/nfe" "nNF" to hoAux
82038>>>>>                            Get psText of hoaux to NFEs.itens[iQtd_nfes].num_nota_fiscal
82039>>>>>                            Send Destroy of hoAux
82040>>>>>
82040>>>>>                            Get ChildElementNS of hoide "http://www.portalfiscal.inf.br/nfe" "dhEmi" to hoAux
82041>>>>>                            Get psText of hoaux to NFEs.itens[iQtd_nfes].data_emissao
82042>>>>>                            Send Destroy of hoAux
82043>>>>>
82043>>>>>                            Get ChildElementNS of hoide "http://www.portalfiscal.inf.br/nfe" "mod" to hoAux
82044>>>>>                            Get psText of hoaux to NFEs.itens[iQtd_nfes].modelo
82045>>>>>                            Send Destroy of hoAux
82046>>>>>
82046>>>>>                            Get ChildElementNS of hoide "http://www.portalfiscal.inf.br/nfe" "serie" to hoAux
82047>>>>>                            Get psText of hoaux to NFEs.itens[iQtd_nfes].serie
82048>>>>>                            If ((Length(Trim(NFEs.itens[iQtd_nfes].serie))) < 3) Move (Insert('0',NFEs.itens[iQtd_nfes].serie,1)) to NFEs.itens[iQtd_nfes].serie
82051>>>>>                            If ((Length(Trim(NFEs.itens[iQtd_nfes].serie))) < 3) Move (Insert('0',NFEs.itens[iQtd_nfes].serie,1)) to NFEs.itens[iQtd_nfes].serie
82054>>>>>                            Send Destroy of hoAux
82055>>>>>                            Send Destroy of hoide
82056>>>>>
82056>>>>>                            Move 10 to NFEs.itens[iQtd_nfes].tipo_documento // atualmente ‚ fixo, indica nota fiscal
82057>>>>>
82057>>>>>                            Get ChildElementNS of hoInfNFe "http://www.portalfiscal.inf.br/nfe" "total" to hoTotal
82058>>>>>                            Get ChildElementNS of hoTotal "http://www.portalfiscal.inf.br/nfe" "ICMSTot" to hoICMSTot
82059>>>>>
82059>>>>>                            Get ChildElementNS of hoICMSTot "http://www.portalfiscal.inf.br/nfe" "vICMSUFDest" to hoAux
82060>>>>>                            If hoAux ;                            Begin
82062>>>>>                                Get psText of hoaux to sValor
82063>>>>>                                Move (Replace('.',sValor,',')) to NFEs.itens[iQtd_nfes].icms_uf_destino
82064>>>>>                                Send Destroy of hoAux
82065>>>>>                            End
82065>>>>>>
82065>>>>>
82065>>>>>                            Get ChildElementNS of hoICMSTot "http://www.portalfiscal.inf.br/nfe" "vFCPUFDest" to hoAux
82066>>>>>                            If hoAux ;                            Begin
82068>>>>>                                Get psText of hoaux to sValor
82069>>>>>                                Move (Replace('.',sValor,',')) to NFEs.itens[iQtd_nfes].fcp_uf_destino
82070>>>>>                                Send Destroy of hoAux
82071>>>>>                            End
82071>>>>>>
82071>>>>>
82071>>>>>                            Get ChildElementNS of hoICMSTot "http://www.portalfiscal.inf.br/nfe" "vST" to hoAux
82072>>>>>                            If hoAux ;                            Begin
82074>>>>>                                Get psText of hoaux to sValor
82075>>>>>                                Move (Replace('.',sValor,',')) to NFEs.itens[iQtd_nfes].icms_st
82076>>>>>                                Send Destroy of hoAux
82077>>>>>                            End
82077>>>>>>
82077>>>>>                            Move NFEs.itens[iQtd_nfes].data_emissao to NFEs.itens[iQtd_nfes].vencimento
82078>>>>>                            Move sCNPJ to NFEs.itens[iQtd_nfes].emitente
82079>>>>>                            
82079>>>>>                            Increment iQtd_nfes
82080>>>>>
82080>>>>>                            Send Destroy of hoICMSTot
82081>>>>>                            Send Destroy of hoTotal
82082>>>>>                            Send Destroy of hoDest
82083>>>>>                            Send destroy of hoInfNFe
82084>>>>>                            Send destroy of hoprotNFe
82085>>>>>                            Send destroy of hoRoot
82086>>>>>                            Send destroy of hoNFe
82087>>>>>                        End
82087>>>>>>
82087>>>>>                    End
82087>>>>>>
82087>>>>>                End
82087>>>>>>
82087>>>>>            End
82087>>>>>>
82087>>>>>            Send Destroy of hoXml
82088>>>>>        End
82088>>>>>>
82088>>>>>    Loop
82089>>>>>>
82089>>>>>
82089>>>>>    Function_Return NFEs
82090>>>>>
82090>>>>>End_Function
82091>>>Use Pacotes\GGGwsGeraGuia.pkg
Including file: Pacotes\GGGwsGeraGuia.pkg    (C:\DataFlex Projects\GNRELibrary\AppSrc\Pacotes\GGGwsGeraGuia.pkg)
82091>>>>>//----------------------------------------------------------------------------------------------
82091>>>>>// Pacote com fun‡äes para gera‡Æo de guias atrav‚s do webservice do portal www.guiasgnre.com.br
82091>>>>>//----------------------------------------------------------------------------------------------
82091>>>>>//
82091>>>>>//----------------------------------------------------------------------------------------------
82091>>>>>// Autor .....: Alexandro Maule - Harsy Sistemas
82091>>>>>// Criado em..: 25/04/2016
82091>>>>>// VersÆo.....: 1.0.0
82091>>>>>// Hist¢rico de Altera‡äes: 
82091>>>>>// - 26/05/2016 - Adriano Rodrigues - Reformula‡Æo de toda a fun‡Æo devido mudan‡as 
82091>>>>>// no webservice.
82091>>>>>//
82091>>>>>//----------------------------------------------------------------------------------------------
82091>>>>>// Parƒmetros
82091>>>>>// 1 - String sCNPJ: CNPJ do usu rio.
82091>>>>>// 2 - String sLogin: Login do usu rio.
82091>>>>>// 3 - String sToken: Token / chave_api.
82091>>>>>// 4 - tWStListaNfe llListaNfe: Estrutura com os dados da NFe.
82091>>>>>//----------------------------------------------------------------------------------------------
82091>>>>>// Retorno: 
82091>>>>>// -tWStRetornoLote: Retorna o lote com os recibos e status das guias geradas e mensagem de erro.
82091>>>>>// -tWStRetornoLotePDF: Retorna o lote com os recibos e status das guias geradas e mensagem de 
82091>>>>>// erro, e o PDF das guias.
82091>>>>>//----------------------------------------------------------------------------------------------
82091>>>>>// Lista de c¢digos de retorno: 
82091>>>>>// 0 = Sucesso
82091>>>>>// 1 = NÆo autorizado. Verifique o CNPJ, Usu rio e Token.
82091>>>>>// 2 = Lote processado com pendˆncias.
82091>>>>>// 3 = Nenhuma guia liberada no momento.
82091>>>>>// 4 = Falha ao buscar guias. 
82091>>>>>// 5 = Falha ao gerar o PDF.
82091>>>>>// 6 = Data inicial inv lida. PadrÆo esperado: AAAA-MM-DD. 
82091>>>>>// 7 = Data final inv lida. PadrÆo esperado: AAAA-MM-DD.
82091>>>>>//----------------------------------------------------------------------------------------------
82091>>>>>
82091>>>>>Use Pacotes\cWSGeraGuiaGnre.pkg
82091>>>>>
82091>>>>>
82091>>>>>// Fun‡Æo de Envio dos Dados da NFe para o webservice para gera‡Æo das guias. Esta
82091>>>>>// fun‡Æo recebe uma ou mais notas e retorna uma lista com informa‡äes das guias
82091>>>>>// das respectivas notas, para que sejam usadas e impressas em um gerador de
82091>>>>>// relat¢rios de sua preferˆncia, ou salvas em disco, etc.
82091>>>>>Function GGGGeraGuia Global String sCNPJ String sLogin String sToken tWStListaNfe llListaNfe Returns tWStRetornoLote
82093>>>>>    
82093>>>>>    Handle hGeraGuiaGnre                // Handle do objeto.
82093>>>>>    tWStRetornoLote  RetornoLote        // Lote com o retorno das guias geradas, com os recibos e status das guias.
82093>>>>>    tWStRetornoLote  RetornoLote        // Lote com o retorno das guias geradas, com os recibos e status das guias.
82093>>>>>        
82093>>>>>    Get Create u_cWSGeraGuiaGnre to hGeraGuiaGnre
82094>>>>>    If not hGeraGuiaGnre ;    Begin
82096>>>>>        Send Info_Box 'Erro ao criar o objeto da classe cWSGeraGuiaGnre!'
82097>>>>>        Procedure_Return
82098>>>>>    End
82098>>>>>>
82098>>>>>
82098>>>>>    Get wsGeraGuia of hGeraGuiaGnre sCNPJ sLogin sToken llListaNfe to RetornoLote
82099>>>>>    
82099>>>>>    Send Destroy of hGeraGuiaGnre
82100>>>>>    
82100>>>>>    Function_Return RetornoLote
82101>>>>>End_Function
82102>>>>>
82102>>>>>
82102>>>>>// Fun‡Æo de Envio dos Dados da NFe para o webservice para gera‡Æo das guias,
82102>>>>>// por‚m j  retornando o PDF das guias pronto para ser salvo e/ou impresso ap¢s a
82102>>>>>// recep‡Æo do arquivo.
82102>>>>>Function GGGGeraGuiaPDF Global String sCNPJ String sLogin String sToken tWStListaNfe llListaNfe Returns tWStRetornoLotePDF
82104>>>>>    
82104>>>>>    Handle hGeraGuiaGnre                // Handle do objeto.
82104>>>>>    tWStRetornoLotePDF RetornoLotePDF   // Lote com o retorno das guias geradas, com os recibos e status das guias.
82104>>>>>    tWStRetornoLotePDF RetornoLotePDF   // Lote com o retorno das guias geradas, com os recibos e status das guias.
82104>>>>>    
82104>>>>>    Get Create u_cWSGeraGuiaGnre to hGeraGuiaGnre
82105>>>>>    If not hGeraGuiaGnre ;    Begin
82107>>>>>        Send Info_Box 'Erro ao criar o objeto da classe cWSGeraGuiaGnre!'
82108>>>>>        Procedure_Return
82109>>>>>    End
82109>>>>>>
82109>>>>>    
82109>>>>>    Get wsGeraGuiaPDF of hGeraGuiaGnre sCNPJ sLogin sToken llListaNfe to RetornoLotePDF
82110>>>>>    
82110>>>>>    Send Destroy of hGeraGuiaGnre
82111>>>>>    
82111>>>>>    Function_Return RetornoLotePDF
82112>>>>>End_Function
82113>>>Use Pacotes\GGGwsBuscaGuia.pkg
Including file: Pacotes\GGGwsBuscaGuia.pkg    (C:\DataFlex Projects\GNRELibrary\AppSrc\Pacotes\GGGwsBuscaGuia.pkg)
82113>>>>>//----------------------------------------------------------------------------------------------
82113>>>>>// Pacote com fun‡äes para busca de guias atrav‚s do webservice do portal www.guiasgnre.com.br
82113>>>>>//----------------------------------------------------------------------------------------------
82113>>>>>//
82113>>>>>//----------------------------------------------------------------------------------------------
82113>>>>>// Autor .....: Adriano Rodrigues - Harsy Sistemas
82113>>>>>// Criado em..: 26/05/2016
82113>>>>>// VersÆo.....: 1.0.0
82113>>>>>// Hist¢rico de Altera‡äes: 
82113>>>>>// 
82113>>>>>
82113>>>>>//----------------------------------------------------------------------------------------------
82113>>>>>// Parƒmetros usados nas fun‡äes:
82113>>>>>// 1 - String sCNPJ: CNPJ do usu rio.
82113>>>>>// 2 - String sLogin: Login do usu rio.
82113>>>>>// 3 - String sToken: Token / chave_api.
82113>>>>>// 4 - tWStRetornoLote: Lote com os recibos e status das guias geradas para efeutar a busca no 
82113>>>>>// portal.
82113>>>>>// 5 - tWStRecibos: Lista de recibos das guias pendentes, a serem consultadas.
82113>>>>>//----------------------------------------------------------------------------------------------
82113>>>>>// Retornos das fun‡äes: 
82113>>>>>// -tWStListaGuias: Retorna o lote com as guias, contendo seus recibos, status e demais 
82113>>>>>// informa‡äes das guias geradas e mensagem de erro.
82113>>>>>// -tWStRetornoLotePDF: Retorna o lote com as guias em PDF, prontas para serem impressas.
82113>>>>>//----------------------------------------------------------------------------------------------
82113>>>>>// Lista de c¢digos de retorno: 
82113>>>>>// 0 = Sucesso
82113>>>>>// 1 = NÆo autorizado. Verifique o CNPJ, Usu rio e Token.
82113>>>>>// 2 = Lote processado com pendˆncias.
82113>>>>>// 3 = Nenhuma guia liberada no momento.
82113>>>>>// 4 = Falha ao buscar guias. 
82113>>>>>// 5 = Falha ao gerar o PDF.
82113>>>>>// 6 = Data inicial inv lida. PadrÆo esperado: AAAA-MM-DD. 
82113>>>>>// 7 = Data final inv lida. PadrÆo esperado: AAAA-MM-DD.
82113>>>>>//----------------------------------------------------------------------------------------------
82113>>>>>
82113>>>>>Use Pacotes\cWSGeraGuiaGnre.pkg
82113>>>>>
82113>>>>>
82113>>>>>// Busca Guia(s) espec¡fica(s) atrav‚s do CNPJ do emitente e do n£mero do recibo
82113>>>>>// (que pode ser mais de um), independente do status da guia.
82113>>>>>Function GGGBuscaGuia Global String sCNPJ String sLogin String sToken tWStRetornoLote llRetornoLote Returns tWStListaGuias
82115>>>>>    
82115>>>>>    Handle hGeraGuiaGnre                // Handle do objeto.
82115>>>>>    tWStListaGuias ListaGuias           // Lote com o retorno das guias geradas, com os recibos, status e demais informa‡äes das guias.
82115>>>>>    tWStListaGuias ListaGuias           // Lote com o retorno das guias geradas, com os recibos, status e demais informa‡äes das guias.
82115>>>>>    
82115>>>>>    Get Create u_cWSGeraGuiaGnre to hGeraGuiaGnre
82116>>>>>    If not hGeraGuiaGnre ;    Begin
82118>>>>>        Send Info_Box 'Erro ao criar o objeto da classe cWSGeraGuiaGnre!'
82119>>>>>        Procedure_Return
82120>>>>>    End
82120>>>>>>
82120>>>>>    
82120>>>>>    Get wsBuscaGuia of hGeraGuiaGnre sCNPJ sLogin sToken llRetornoLote to ListaGuias
82121>>>>>    
82121>>>>>    Send Destroy of hGeraGuiaGnre
82122>>>>>    
82122>>>>>    Function_Return ListaGuias
82123>>>>>End_Function
82124>>>>>
82124>>>>>
82124>>>>>// Busca Guias que ficaram pendentes, com status de 'Transmitida' ou 'Aguardando',
82124>>>>>// e nÆo foram retornadas no momento do envio do lote das notas, pois estavam em
82124>>>>>// processamento pela SEFAZ de destino. Esta fun‡Æo recebe um ou mais recibos das
82124>>>>>// guias desejadas e retorna uma lista com informa‡äes das guias dos respectivos
82124>>>>>// recibos, para que sejam usadas e impressas em um gerador de relat¢rios de sua
82124>>>>>// preferˆncia, salvas em banco de dados, etc.
82124>>>>>Function GGGBuscaGuiasPendentes Global String sCNPJ String sLogin String sToken tWStRecibos llGuiasPendentes Returns tWStListaGuias
82126>>>>>    
82126>>>>>    Handle hGeraGuiaGnre                // Handle do objeto.
82126>>>>>    tWStListaGuias ListaGuias           // Lote com o retorno das guias geradas, com os recibos, status e demais informa‡äes das guias.
82126>>>>>    tWStListaGuias ListaGuias           // Lote com o retorno das guias geradas, com os recibos, status e demais informa‡äes das guias.
82126>>>>>        
82126>>>>>    Get Create u_cWSGeraGuiaGnre to hGeraGuiaGnre
82127>>>>>    If not hGeraGuiaGnre ;    Begin
82129>>>>>        Send Info_Box 'Erro ao criar o objeto da classe cWSGeraGuiaGnre!'
82130>>>>>        Procedure_Return
82131>>>>>    End
82131>>>>>>
82131>>>>>    
82131>>>>>    Get wsBuscaGuiasPendentes of hGeraGuiaGnre sCNPJ sLogin sToken llGuiasPendentes to ListaGuias
82132>>>>>    
82132>>>>>    Send Destroy of hGeraGuiaGnre
82133>>>>>    Function_Return ListaGuias
82134>>>>>End_Function
82135>>>>>
82135>>>>>
82135>>>>>// Busca todas as guias que estÆo pendentes, com status 'Trasmitida' ou
82135>>>>>// 'Aguardando', exceto aquelas com status 'Erro', e nÆo foram retornadas no
82135>>>>>// momento do envio do lote das notas. Se informado data de inicio e fim da
82135>>>>>// emissÆo da nota, filtra apenas guias nesse intervalo de tempo. Se informado
82135>>>>>// apenas data de in¡cio, filtra todas a partir desta data. Se informado apenas
82135>>>>>// data final, filtra todas as guias at‚ esta data. Se nÆo informar nenhuma data,
82135>>>>>// retorna todas as guias com status 'Transmitida' ou 'Aguardando'.
82135>>>>>Function GGGBuscaTodasGuiasPendentes String sCNPJ String sLogin String sToken String sDataInicio String sDataFim Returns tWStListaGuias
82138>>>>>    
82138>>>>>    Handle hGeraGuiaGnre                // Handle do objeto.
82138>>>>>    tWStListaGuias ListaGuias           // Lote com o retorno das guias geradas, com os recibos, status e demais informa‡äes das guias.
82138>>>>>    tWStListaGuias ListaGuias           // Lote com o retorno das guias geradas, com os recibos, status e demais informa‡äes das guias.
82138>>>>>        
82138>>>>>    Get Create u_cWSGeraGuiaGnre to hGeraGuiaGnre
82139>>>>>    If not hGeraGuiaGnre ;    Begin
82141>>>>>        Send Info_Box 'Erro ao criar o objeto da classe cWSGeraGuiaGnre!'
82142>>>>>        Procedure_Return
82143>>>>>    End
82143>>>>>>
82143>>>>>    
82143>>>>>    Get wsBuscaTodasGuiasPendentes of hGeraGuiaGnre sCNPJ sLogin sToken sDataInicio sDataFim to ListaGuias
82144>>>>>    
82144>>>>>    Send Destroy of hGeraGuiaGnre
82145>>>>>    Function_Return ListaGuias
82146>>>>>End_Function
82147>>>>>
82147>>>>>
82147>>>>>// Busca todas as guias com erro em um intervalo de tempo passado como parƒmetro, e
82147>>>>>// tenta retransmit¡-las para a SEFAZ de destino e trazer o resultado desse reenvio. 
82147>>>>>// Se passado apenas a data inicial, ele buscar  as guias com erro a partir (e inclusive) 
82147>>>>>// desta data. Se passado apenas a data final, ele buscar  todas as guias com erro, desde
82147>>>>>// o primeiro registro da empresa no sistema, at‚ esta data informada. Se nenhuma data for 
82147>>>>>// informada, ele buscar  em todos os registros da empresa por guias com erro, o que pode 
82147>>>>>// demorar demais. Formato esperado da data: AAAA-MM-DD.
82147>>>>>Function GGGBuscaTodasGuiasComErro Global String sCNPJ String sLogin String sToken String sDataInicial String sDataFinal Returns tWStListaGuias
82149>>>>>    
82149>>>>>    Handle hGeraGuiaGnre                // Handle do objeto.
82149>>>>>    tWStListaGuias ListaGuias           // Lote com o retorno das guias geradas, com os recibos, status e demais informa‡äes das guias.
82149>>>>>    tWStListaGuias ListaGuias           // Lote com o retorno das guias geradas, com os recibos, status e demais informa‡äes das guias.
82149>>>>>        
82149>>>>>    Get Create u_cWSGeraGuiaGnre to hGeraGuiaGnre
82150>>>>>    If not hGeraGuiaGnre ;    Begin
82152>>>>>        Send Info_Box 'Erro ao criar o objeto da classe cWSGeraGuiaGnre!'
82153>>>>>        Procedure_Return
82154>>>>>    End
82154>>>>>>
82154>>>>>    
82154>>>>>    Get wsBuscaTodasGuiasComErro of hGeraGuiaGnre sCNPJ sLogin sToken sDataInicial sDataFinal to ListaGuias
82155>>>>>    
82155>>>>>    Send Destroy of hGeraGuiaGnre
82156>>>>>    Function_Return ListaGuias
82157>>>>>End_Function
82158>>>>>
82158>>>>>
82158>>>>>// Busca Guia(s) espec¡fica(s) atrav‚s do CNPJ do emitente e do n£mero do recibo
82158>>>>>// (que pode ser mais de um), independente do status da guia, retornando o PDF 
82158>>>>>// referente a esta(s) guia(s).
82158>>>>>Function GGGBuscaGuiaPDF String sCNPJ String sLogin String sToken tWStRetornoLote llLote Returns tWStRetornoLotePDF
82161>>>>>    
82161>>>>>    Handle hGeraGuiaGnre                // Handle do objeto.
82161>>>>>    tWStRetornoLotePDF RetornoLotePDF   // Lote com o retorno das guias geradas, em PDF.
82161>>>>>    tWStRetornoLotePDF RetornoLotePDF   // Lote com o retorno das guias geradas, em PDF.
82161>>>>>    
82161>>>>>    Get Create u_cWSGeraGuiaGnre to hGeraGuiaGnre
82162>>>>>    If not hGeraGuiaGnre ;    Begin
82164>>>>>        Send Info_Box 'Erro ao criar o objeto da classe cWSGeraGuiaGnre!'
82165>>>>>        Procedure_Return
82166>>>>>    End
82166>>>>>>
82166>>>>>    
82166>>>>>    Get wsBuscaGuiaPDF of hGeraGuiaGnre sCNPJ sLogin sToken llLote to RetornoLotePDF
82167>>>>>    
82167>>>>>    Send Destroy of hGeraGuiaGnre
82168>>>>>    Function_Return RetornoLotePDF
82169>>>>>End_Function
82170>>>
82170>>>Deferred_View Activate_oExemplo2 for ;Object oExemplo2 is a dbView
82195>>>    
82195>>>    Property tWStRetornoLote ptLoteGuias
82197>>>    
82197>>>    Set Border_Style to Border_Thick
82198>>>    Set Size to 300 399
82199>>>    Set Location to 6 6
82200>>>    Set Label to "GeraGuia"
82201>>>
82201>>>    Object oOpenDialog1 is a OpenDialog
82203>>>        Set Filter_String to 'NFe|*.xml'
82204>>>        Set MultiSelect_State to True
82205>>>    End_Object
82206>>>
82206>>>    Object oGrid1 is a Grid
82208>>>        Set Location to 7 8
82209>>>    
82209>>>        Set Size to 155 382
82210>>>    
82210>>>        Set Line_Width to 1 0
82211>>>        Set Header_Label 0 to "XMLs para processar"
82212>>>        Set Form_Width 0 to 373
82213>>>        Set Color to claqua    
82214>>>    End_Object
82215>>>
82215>>>    Object oButtonCarregaXml is a Button
82217>>>        Set Size to 14 151
82218>>>        Set Location to 165 8
82219>>>        Set Label to 'Pressione aqui para localizar e carregar as XMLs'
82220>>>    
82220>>>        // fires when the button is clicked
82220>>>        Procedure OnClick
82223>>>            Boolean bOpen bReadOnly
82223>>>            Integer iCount
82223>>>            String sFileTitle sFileName
82223>>>            String[] saSelectedFiles
82224>>>         
82224>>>            Get Show_Dialog of oOpenDialog1 to bOpen
82225>>>            If bOpen Begin
82227>>>                Get TickReadOnly_State of oOpenDialog1 to bReadOnly
82228>>>                Get File_Title of oOpenDialog1 to sFileTitle
82229>>>                Get Selected_Files of oOpenDialog1 to saSelectedFiles
82230>>>                
82230>>>                Send Delete_Data of oGrid1
82231>>>                
82231>>>                For iCount from 0 to ((SizeOfArray(saSelectedFiles)) - 1)
82237>>>>
82237>>>                    Send Add_Item of oGrid1 Msg_None saSelectedFiles[iCount]
82238>>>                Loop
82239>>>>
82239>>>            End
82239>>>>
82239>>>            Else Send Info_Box "Nenhum arquivo foi escolhido."
82241>>>        End_Procedure
82242>>>
82242>>>            
82242>>>    
82242>>>    End_Object
82243>>>
82243>>>    Object oLogin is a Form
82245>>>        Set Size to 13 196
82246>>>        Set Location to 183 71
82247>>>        Set Label to "Login:"
82248>>>        Set FontWeight to 600
82249>>>    End_Object
82250>>>
82250>>>    Object oCNPJ is a Form
82252>>>        Set Size to 13 93
82253>>>        Set Location to 198 71
82254>>>        Set Label to "CNPJ:"
82255>>>        Set FontWeight to 600
82256>>>    End_Object
82257>>>
82257>>>    Object oToken is a Form
82259>>>        Set Size to 13 196
82260>>>        Set Location to 213 71
82261>>>        Set Label to "Token/Chave Api:"
82262>>>        Set FontWeight to 600
82263>>>    End_Object
82264>>>
82264>>>    Object oGroupRetornoEstrutura is a Group
82266>>>        Set Size to 64 189
82267>>>        Set Location to 230 10
82268>>>        Set Label to "Retornos em estrutura de dados"
82269>>>
82269>>>        Object oButtonGeraGuia is a Button
82271>>>            Set Size to 14 83
82272>>>            Set Location to 10 8
82273>>>            Set Label to "Gerar Guias e exibir na tela"
82274>>>            
82274>>>            Procedure OnClick
82277>>>                Send GeraGuia                
82278>>>            End_Procedure
82279>>>            
82279>>>            Procedure GeraGuia
82282>>>                String[] saLista
82283>>>                Integer iLinhas iContador
82283>>>                tWStListaNfe    ListaNFe
82283>>>                tWStListaNfe    ListaNFe
82283>>>                tWStRetornoLote RetornoLote
82283>>>                tWStRetornoLote RetornoLote
82283>>>                tWStListaGuias  ListaGuias
82283>>>                tWStListaGuias  ListaGuias
82283>>>                
82283>>>                // Lista de c¢digos de retorno: 
82283>>>                // 0 = Sucesso
82283>>>                // 1 = NÆo autorizado. Verifique o CNPJ, Usu rio e Token.
82283>>>                // 2 = Lote processado com pendˆncias.
82283>>>                // 3 = Nenhuma guia liberada no momento.
82283>>>                // 4 = Falha ao buscar guias. 
82283>>>                // 5 = Falha ao gerar o PDF.
82283>>>                // 6 = Data inicial inv lida. PadrÆo esperado: AAAA-MM-DD. 
82283>>>                // 7 = Data final inv lida. PadrÆo esperado: AAAA-MM-DD.
82283>>>                
82283>>>                Send Cursor_Wait of Cursor_Control
82284>>>                
82284>>>                Send Beginning_of_Data of oGrid1
82285>>>                
82285>>>                Get Item_Count of oGrid1 to iLinhas
82286>>>                
82286>>>                For iContador from 0 to (iLinhas - 1)
82292>>>>
82292>>>                    Get Value of oGrid1 item iContador to saLista[iContador]
82293>>>                Loop
82294>>>>
82294>>>                
82294>>>                // Extrai as informa‡äes das xmls para a estrutura de lista de notas
82294>>>                Get GGGLerXmls saLista (Value(oCNPJ,0)) to ListaNFe
82295>>>                
82295>>>                // Consome o webservice e gera as guias no portal
82295>>>                Get GGGGeraGuia (Value(oCNPJ,0)) (Value(oLogin,0)) (Value(oToken,0)) ListaNFe to RetornoLote 
82296>>>                
82296>>>                // RetornoLote.retorno = 0 -> Sucesso.
82296>>>                If (RetornoLote.retorno > 0);                Begin
82298>>>                    Error DFERR_OPERATOR ("Pendˆncias na gera‡Æo das guias.\nC¢digo do retorno: " + (String(RetornoLote.retorno)) + " - Descri‡Æo: " + (RetornoLote.msg_retorno))
82299>>>>
82299>>>                End
82299>>>>
82299>>>                
82299>>>                // Consome o webservice e recebe de volta os dados das guias para serem utilizadas como quiser (grava‡Æo, exporta‡Æo, impressÆo em algum gerador de relat¢rio, etc.)
82299>>>                // O XML de retorno completo da guia est  no campo ListaGuias.guias[n].xml_guia
82299>>>                Get GGGBuscaGuia (Value(oCNPJ,0)) (Value(oLogin,0)) (Value(oToken,0)) RetornoLote to ListaGuias
82300>>>                
82300>>>                If (ListaGuias.retorno > 0);                Begin
82302>>>                    Error DFERR_OPERATOR ("Pendˆncias na busca das guias.\n\nC¢digo do retorno: " + (String(ListaGuias.retorno)) + "\nDescri‡Æo: " + (ListaGuias.msg_retorno))
82303>>>>
82303>>>                End
82303>>>>
82303>>>                
82303>>>                // Neste exemplo, vamos apenas mostrar na tela o retorno da estrutura de guias.
82303>>>                For iContador from 0 to ((SizeOfArray(ListaGuias.guias))-1)
82309>>>>
82309>>>                    Showln ("emitente:                " + (String(ListaGuias.guias[iContador].emitente)))
82311>>>                    Showln ("serie:                   " + (String(ListaGuias.guias[iContador].serie)))
82313>>>                    Showln ("modelo:                  " + (String(ListaGuias.guias[iContador].modelo)))
82315>>>                    Showln ("num_nota_fiscal:         " + (String(ListaGuias.guias[iContador].num_nota_fiscal)))
82317>>>                    Showln ("receita:                 " + (String(ListaGuias.guias[iContador].receita)))
82319>>>                    Showln ("detalhamento:            " + (String(ListaGuias.guias[iContador].detalhamento)))
82321>>>                    Showln ("tipo_Documento:          " + (String(ListaGuias.guias[iContador].tipo_Documento)))
82323>>>                    Showln ("chave_nfe:               " + (String(ListaGuias.guias[iContador].chave_nfe)))
82325>>>                    Showln ("convenio:                " + (String(ListaGuias.guias[iContador].convenio)))
82327>>>                    Showln ("data_emissao:            " + (String(ListaGuias.guias[iContador].data_emissao)))
82329>>>                    Showln ("status:                  " + (String(ListaGuias.guias[iContador].status)))
82331>>>                    Showln ("recibo:                  " + (String(ListaGuias.guias[iContador].recibo)))
82333>>>                    Showln ("data_recibo:             " + (String(ListaGuias.guias[iContador].data_recibo)))
82335>>>                    Showln ("produto:                 " + (String(ListaGuias.guias[iContador].produto)))
82337>>>                    Showln ("vencimento:              " + (String(ListaGuias.guias[iContador].vencimento)))
82339>>>                    Showln ("valor:                   " + (String(ListaGuias.guias[iContador].valor)))
82341>>>                    Showln ("cpf:                     " + (String(ListaGuias.guias[iContador].cpf)))
82343>>>                    Showln ("cnpj:                    " + (String(ListaGuias.guias[iContador].cnpj)))
82345>>>                    Showln ("nome_destinatario:       " + (String(ListaGuias.guias[iContador].nome_destinatario)))
82347>>>                    Showln ("municipio_destinatario:  " + (String(ListaGuias.guias[iContador].municipio_destinatario)))
82349>>>                    Showln ("cod_municipio_destinat:  " + (String(ListaGuias.guias[iContador].cod_municipio_destinat)))
82351>>>                    Showln ("uf_destinatario:         " + (String(ListaGuias.guias[iContador].uf_destinatario)))
82353>>>                    Showln ("mensagem:                " + (String(ListaGuias.guias[iContador].mensagem)))
82355>>>                    Showln ("xml_guia:                " + (String(ListaGuias.guias[iContador].xml_guia)))
82357>>>                    Showln ("data_recepcao:           " + (String(ListaGuias.guias[iContador].data_recepcao)))
82359>>>                    Showln ("valor_atualizado:        " + (String(ListaGuias.guias[iContador].valor_atualizado)))
82361>>>                    Showln ""
82363>>>                Loop
82364>>>>
82364>>>                
82364>>>                // Move RetornoLote para uma propriedade da view, apenas para ser usada ao clicar nos botäes 'Busca Guia',
82364>>>                // 'Pendentes', 'Todas Com Erro', 'Todas Pendentes', j  que ‚ preciso uma estrutura dessa para ser usada como parƒmetro, na busca de guias.
82364>>>                Set ptLoteGuias of oExemplo2 to RetornoLote
82365>>>                
82365>>>                Send Cursor_Ready of Cursor_Control
82366>>>            End_Procedure
82367>>>        
82367>>>        End_Object
82368>>>
82368>>>        Object oButtonBuscaGuia is a Button
82370>>>            Set Size to 14 84
82371>>>            Set Location to 10 97
82372>>>            Set Label to "Busca Guia"
82373>>>            
82373>>>            Procedure OnClick
82376>>>                Send BuscaGuia                        
82377>>>            End_Procedure
82378>>>            
82378>>>            Procedure BuscaGuia
82381>>>                Integer iIndex iContador iSize
82381>>>                tWStListaGuias ListaGuias
82381>>>                tWStListaGuias ListaGuias
82381>>>                tWStRetornoLote Lote
82381>>>                tWStRetornoLote Lote
82381>>>                
82381>>>                // Lista de c¢digos de retorno: 
82381>>>                // 0 = Sucesso
82381>>>                // 1 = NÆo autorizado. Verifique o CNPJ, Usu rio e Token.
82381>>>                // 2 = Lote processado com pendˆncias.
82381>>>                // 3 = Nenhuma guia liberada no momento.
82381>>>                // 4 = Falha ao buscar guias. 
82381>>>                // 5 = Falha ao gerar o PDF.
82381>>>                // 6 = Data inicial inv lida. PadrÆo esperado: AAAA-MM-DD. 
82381>>>                // 7 = Data final inv lida. PadrÆo esperado: AAAA-MM-DD.
82381>>>                
82381>>>                Send Cursor_Wait of Cursor_Control
82382>>>                
82382>>>                Get ptLoteGuias of oExemplo2 to Lote
82383>>>                
82383>>>                // Esta fun‡Æo, GGGBuscaGuia, exige uma estrutura de dados de retorno, com os recibos, etc, como parƒmetro.
82383>>>                // Como nÆo estamos guardando nada em banco, guardamos o retorno da chamada de GeraGuia, para ser carregada aqui 
82383>>>                // como exemplo.
82383>>>                Get GGGBuscaGuia (Value(oCNPJ,0)) (Value(oLogin,0)) (Value(oToken,0)) Lote to ListaGuias
82384>>>                
82384>>>                If (ListaGuias.retorno > 0);                Begin
82386>>>                    Error DFERR_OPERATOR ("Pendˆncias na busca das guias.\n\nC¢digo do retorno: " + (String(ListaGuias.retorno)) + "\nDescri‡Æo: " + (ListaGuias.msg_retorno))
82387>>>>
82387>>>                End
82387>>>>
82387>>>                
82387>>>                For iContador from 0 to ((SizeOfArray(ListaGuias.Guias))-1)
82393>>>>
82393>>>                    Showln ("emitente:                " + (String(ListaGuias.Guias[iContador].emitente)))
82395>>>                    Showln ("serie:                   " + (String(ListaGuias.Guias[iContador].serie)))
82397>>>                    Showln ("modelo:                  " + (String(ListaGuias.Guias[iContador].modelo)))
82399>>>                    Showln ("num_nota_fiscal:         " + (String(ListaGuias.Guias[iContador].num_nota_fiscal)))
82401>>>                    Showln ("receita:                 " + (String(ListaGuias.Guias[iContador].receita)))
82403>>>                    Showln ("detalhamento:            " + (String(ListaGuias.Guias[iContador].detalhamento)))
82405>>>                    Showln ("tipo_Documento:          " + (String(ListaGuias.Guias[iContador].tipo_Documento)))
82407>>>                    Showln ("chave_nfe:               " + (String(ListaGuias.Guias[iContador].chave_nfe)))
82409>>>                    Showln ("convenio:                " + (String(ListaGuias.Guias[iContador].convenio)))
82411>>>                    Showln ("data_emissao:            " + (String(ListaGuias.Guias[iContador].data_emissao)))
82413>>>                    Showln ("status:                  " + (String(ListaGuias.Guias[iContador].status)))
82415>>>                    Showln ("recibo:                  " + (String(ListaGuias.Guias[iContador].recibo)))
82417>>>                    Showln ("data_recibo:             " + (String(ListaGuias.Guias[iContador].data_recibo)))
82419>>>                    Showln ("produto:                 " + (String(ListaGuias.Guias[iContador].produto)))
82421>>>                    Showln ("vencimento:              " + (String(ListaGuias.Guias[iContador].vencimento)))
82423>>>                    Showln ("valor:                   " + (String(ListaGuias.Guias[iContador].valor)))
82425>>>                    Showln ("cpf:                     " + (String(ListaGuias.Guias[iContador].cpf)))
82427>>>                    Showln ("cnpj:                    " + (String(ListaGuias.Guias[iContador].cnpj)))
82429>>>                    Showln ("nome_destinatario:       " + (String(ListaGuias.Guias[iContador].nome_destinatario)))
82431>>>                    Showln ("municipio_destinatario:  " + (String(ListaGuias.Guias[iContador].municipio_destinatario)))
82433>>>                    Showln ("cod_municipio_destinat:  " + (String(ListaGuias.Guias[iContador].cod_municipio_destinat)))
82435>>>                    Showln ("uf_destinatario:         " + (String(ListaGuias.Guias[iContador].uf_destinatario)))
82437>>>                    Showln ("mensagem:                " + (String(ListaGuias.Guias[iContador].mensagem)))
82439>>>                    Showln ("xml_guia:                " + (String(ListaGuias.Guias[iContador].xml_guia)))
82441>>>                    Showln ("data_recepcao:           " + (String(ListaGuias.Guias[iContador].data_recepcao)))
82443>>>                    Showln ("valor_atualizado:        " + (String(ListaGuias.Guias[iContador].valor_atualizado)))
82445>>>                Loop
82446>>>>
82446>>>                
82446>>>                Send Cursor_Ready of Cursor_Control
82447>>>            End_Procedure
82448>>>        
82448>>>        End_Object
82449>>>        
82449>>>        Object oButtonPendentes is a Button
82451>>>            Set Size to 14 84
82452>>>            Set Location to 27 8
82453>>>            Set Label to "Pendentes"
82454>>>        
82454>>>            Procedure OnClick
82457>>>                    Send BuscaPendentes
82458>>>            End_Procedure
82459>>>            
82459>>>            Procedure BuscaPendentes
82462>>>                Integer iIndex iContador iSize
82462>>>                tWStListaGuias ListaGuias
82462>>>                tWStListaGuias ListaGuias
82462>>>                tWStRecibos GuiasPendentes
82462>>>                tWStRecibos GuiasPendentes
82462>>>                tWStRetornoLote Lote
82462>>>                tWStRetornoLote Lote
82462>>>                
82462>>>                // Lista de c¢digos de retorno: 
82462>>>                // 0 = Sucesso
82462>>>                // 1 = NÆo autorizado. Verifique o CNPJ, Usu rio e Token.
82462>>>                // 2 = Lote processado com pendˆncias.
82462>>>                // 3 = Nenhuma guia liberada no momento.
82462>>>                // 4 = Falha ao buscar guias. 
82462>>>                // 5 = Falha ao gerar o PDF.
82462>>>                // 6 = Data inicial inv lida. PadrÆo esperado: AAAA-MM-DD. 
82462>>>                // 7 = Data final inv lida. PadrÆo esperado: AAAA-MM-DD.
82462>>>                
82462>>>                Send Cursor_Wait of Cursor_Control
82463>>>                
82463>>>                // Esta fun‡Æo, GGGBuscaGuiasPendentes, exige uma estrutura de dados de guias pendentes, como parƒmetro.
82463>>>                // Como nÆo estamos guardando nada em banco, usaremos de novo o retorno da chamada de GeraGuia, 
82463>>>                // guardado na propriedade ptLoteGuias, para ser carregada aqui como exemplo.
82463>>>                // Para localizar estas guias pendentes dentro deste lote, vamos varre-lo eliminando as
82463>>>                // guias que j  estÆo autorizadas, e buscar apenas as que nÆo foram retornadas na busca anterior. 
82463>>>                Get ptLoteGuias of oExemplo2 to Lote
82464>>>                
82464>>>                Move (SizeOfArray(Lote.recibos)) to iSize
82465>>>                Decrement iSize
82466>>>                
82466>>>                For iContador from 0 to iSize
82472>>>>
82472>>>                    If (Lote.recibos[iIndex].status = "Autorizado") Begin
82474>>>                        Move (RemoveFromArray(Lote.recibos, iIndex)) to Lote.recibos
82475>>>                    End
82475>>>>
82475>>>                    Else Begin
82476>>>                        Move (Lote.recibos[iIndex].emitente) to GuiasPendentes.emitente
82477>>>                        Move (Lote.recibos[iIndex].recibo)   to GuiasPendentes.recibo[iIndex]
82478>>>                        Increment iIndex
82479>>>                    End
82479>>>>
82479>>>                Loop
82480>>>>
82480>>>                
82480>>>                Get GGGBuscaGuiasPendentes (Value(oCNPJ,0)) (Value(oLogin,0)) (Value(oToken,0)) GuiasPendentes to ListaGuias
82481>>>                
82481>>>                If (ListaGuias.retorno > 0);                Begin
82483>>>                    Error DFERR_OPERATOR ("Pendˆncias na busca das guias.\n\nC¢digo do retorno: " + (String(ListaGuias.retorno)) + "\nDescri‡Æo: " + (ListaGuias.msg_retorno))
82484>>>>
82484>>>                End
82484>>>>
82484>>>                
82484>>>                For iContador from 0 to ((SizeOfArray(ListaGuias.Guias))-1)
82490>>>>
82490>>>                    Showln (String(ListaGuias.Guias[iContador].Recibo)) ""
82493>>>                Loop
82494>>>>
82494>>>                
82494>>>                Send Cursor_Ready of Cursor_Control
82495>>>            End_Procedure
82496>>>        
82496>>>        End_Object
82497>>>        Object oButtonTodasErro is a Button
82499>>>            Set Size to 14 84
82500>>>            Set Location to 44 8
82501>>>            Set Label to "Todas Com Erro"
82502>>>        
82502>>>            Procedure OnClick
82505>>>                    Send BuscaTodasComErro
82506>>>            End_Procedure
82507>>>            
82507>>>            Procedure BuscaTodasComErro
82510>>>                Integer iRet iContador
82510>>>                String sDataFinal
82510>>>                tWStListaGuias ListaGuias
82510>>>                tWStListaGuias ListaGuias
82510>>>                
82510>>>                // Lista de c¢digos de retorno: 
82510>>>                // 0 = Sucesso
82510>>>                // 1 = NÆo autorizado. Verifique o CNPJ, Usu rio e Token.
82510>>>                // 2 = Lote processado com pendˆncias.
82510>>>                // 3 = Nenhuma guia liberada no momento.
82510>>>                // 4 = Falha ao buscar guias. 
82510>>>                // 5 = Falha ao gerar o PDF.
82510>>>                // 6 = Data inicial inv lida. PadrÆo esperado: AAAA-MM-DD. 
82510>>>                // 7 = Data final inv lida. PadrÆo esperado: AAAA-MM-DD.
82510>>>                
82510>>>                Send Cursor_Wait of Cursor_Control
82511>>>                
82511>>>                // A fun‡Æo GGGBuscaTodasGuiasComErro busca todas as guias com erro em um intervalo de tempo passado como parƒmetro, e
82511>>>                // tenta retransmit¡-las para a SEFAZ de destino e trazer o resultado desse reenvio. Se passado apenas a data inicial,
82511>>>                // ele buscar  as guias com erro a partir (e inclusive) desta data. Se passado apenas a data final, ele buscar  todas 
82511>>>                // as guias com erro, desde o primeiro registro da empresa no sistema, at‚ esta data informada. Se nenhuma data for 
82511>>>                // informada, ele buscar  em todos os registros da empresa por guias com erro, o que pode demorar demais.
82511>>>                // Formato esperado da data: AAAA-MM-DD
82511>>>                
82511>>>                Move ((String(DateGetYear(CurrentDateTime()))) + "-") to sDataFinal
82512>>>                Move (DateGetMonth(CurrentDateTime())) to iRet
82513>>>                Move (sDataFinal + (If((iRet<=9), ("0" + (String(iRet))), (String(iRet)))) + "-") to sDataFinal
82514>>>                Move (DateGetDay(CurrentDateTime())) to iRet
82515>>>                Move (sDataFinal + (If((iRet<=9), ("0" + (String(iRet))), (String(iRet))))) to sDataFinal
82516>>>                
82516>>>                Get GGGBuscaTodasGuiasComErro (Value(oCNPJ,0)) (Value(oLogin,0)) (Value(oToken,0)) "2016-01-01" sDataFinal to ListaGuias
82517>>>                
82517>>>                If (ListaGuias.retorno > 0);                Begin
82519>>>                    Error DFERR_OPERATOR ("Pendˆncias na busca das guias.\n\nC¢digo do retorno: " + (String(ListaGuias.retorno)) + "\nDescri‡Æo: " + (ListaGuias.msg_retorno))
82520>>>>
82520>>>                End
82520>>>>
82520>>>                
82520>>>                For iContador from 0 to ((SizeOfArray(ListaGuias.Guias))-1)
82526>>>>
82526>>>                    Showln (String(ListaGuias.Guias[iContador].Recibo)) ""
82529>>>                Loop
82530>>>>
82530>>>                
82530>>>                Send Cursor_Ready of Cursor_Control
82531>>>            End_Procedure
82532>>>        
82532>>>        End_Object
82533>>>        Object oButtonTodasPend is a Button
82535>>>            Set Size to 14 84
82536>>>            Set Location to 27 97
82537>>>            Set Label to "Todas Pendentes"
82538>>>        
82538>>>            // fires when the button is clicked
82538>>>            Procedure OnClick
82541>>>                Send BuscaTodasPendentes
82542>>>            End_Procedure
82543>>>            
82543>>>            Procedure BuscaTodasPendentes
82546>>>                Integer iRet iContador
82546>>>                String sDataFinal
82546>>>                tWStListaGuias ListaGuias
82546>>>                tWStListaGuias ListaGuias
82546>>>                
82546>>>                // Lista de c¢digos de retorno: 
82546>>>                // 0 = Sucesso
82546>>>                // 1 = NÆo autorizado. Verifique o CNPJ, Usu rio e Token.
82546>>>                // 2 = Lote processado com pendˆncias.
82546>>>                // 3 = Nenhuma guia liberada no momento.
82546>>>                // 4 = Falha ao buscar guias. 
82546>>>                // 5 = Falha ao gerar o PDF.
82546>>>                // 6 = Data inicial inv lida. PadrÆo esperado: AAAA-MM-DD. 
82546>>>                // 7 = Data final inv lida. PadrÆo esperado: AAAA-MM-DD.
82546>>>                
82546>>>                Send Cursor_Wait of Cursor_Control
82547>>>                            
82547>>>                // A fun‡Æo GGGBuscaTodasGuiasPendentes busca todas as guias que estavam em processamento e nÆo retornaram
82547>>>                // na busca anterior, em um intervalo de tempo passado como parƒmetro, e tenta retransmit¡-las para a SEFAZ
82547>>>                // de destino e trazer o resultado desse reenvio. Se passado apenas a data inicial, ele buscar  as guias com
82547>>>                // erro a partir (e inclusive) desta data. Se passado apenas a data final, ele buscar  todas as guias com 
82547>>>                // erro, desde o primeiro registro da empresa no sistema, at‚ esta data informada. Se nenhuma data for 
82547>>>                // informada, ele buscar  em todos os registros da empresa por guias com erro, o que pode demorar demais.
82547>>>                // Formato esperado da data: AAAA-MM-DD
82547>>>                
82547>>>                Move ((String(DateGetYear(CurrentDateTime()))) + "-") to sDataFinal
82548>>>                Move (DateGetMonth(CurrentDateTime())) to iRet
82549>>>                Move (sDataFinal + (If((iRet<=9), ("0" + (String(iRet))), (String(iRet)))) + "-") to sDataFinal
82550>>>                Move (DateGetDay(CurrentDateTime())) to iRet
82551>>>                Move (sDataFinal + (If((iRet<=9), ("0" + (String(iRet))), (String(iRet))))) to sDataFinal
82552>>>                
82552>>>                Get GGGBuscaTodasGuiasPendentes (Value(oCNPJ,0)) (Value(oLogin,0)) (Value(oToken,0)) "2016-01-01" sDataFinal to ListaGuias
82553>>>                
82553>>>                If (ListaGuias.retorno > 0);                Begin
82555>>>                    Error DFERR_OPERATOR ("Pendˆncias na busca das guias.\n\nC¢digo do retorno: " + (String(ListaGuias.retorno)) + "\nDescri‡Æo: " + (ListaGuias.msg_retorno))
82556>>>>
82556>>>                End
82556>>>>
82556>>>                
82556>>>                For iContador from 0 to ((SizeOfArray(ListaGuias.Guias))-1)
82562>>>>
82562>>>                    Showln (String(ListaGuias.Guias[iContador].Recibo)) ""
82565>>>                Loop
82566>>>>
82566>>>                
82566>>>                Send Cursor_Ready of Cursor_Control
82567>>>            End_Procedure
82568>>>        
82568>>>        End_Object
82569>>>    End_Object
82570>>>
82570>>>    Object oGroupRetornoPDF is a Group
82572>>>        Set Size to 32 189
82573>>>        Set Location to 230 202
82574>>>        Set Label to "Retornos em PDF"
82575>>>        Object oButtonGuiaPDF is a Button
82577>>>            Set Size to 14 84
82578>>>            Set Location to 10 8
82579>>>            Set Label to "Gera Guia PDF"
82580>>>        
82580>>>            Procedure OnClick
82583>>>                Send GeraGuiaPdf                        
82584>>>            End_Procedure
82585>>>            
82585>>>            Procedure GeraGuiaPdf
82588>>>                String[] saLista
82589>>>                String sArq
82589>>>                Integer iLinhas iContador iCanal
82589>>>                Boolean bExiste
82589>>>                tWStListaNfe    ListaNFe
82589>>>                tWStListaNfe    ListaNFe
82589>>>                tWStRetornoLotePDF PdfGuias
82589>>>                tWStRetornoLotePDF PdfGuias
82589>>>                
82589>>>                // Lista de c¢digos de retorno: 
82589>>>                // 0 = Sucesso
82589>>>                // 1 = NÆo autorizado. Verifique o CNPJ, Usu rio e Token.
82589>>>                // 2 = Lote processado com pendˆncias.
82589>>>                // 3 = Nenhuma guia liberada no momento.
82589>>>                // 4 = Falha ao buscar guias. 
82589>>>                // 5 = Falha ao gerar o PDF.
82589>>>                // 6 = Data inicial inv lida. PadrÆo esperado: AAAA-MM-DD. 
82589>>>                // 7 = Data final inv lida. PadrÆo esperado: AAAA-MM-DD.
82589>>>                
82589>>>                Send Cursor_Wait of Cursor_Control
82590>>>                
82590>>>                Send Beginning_of_Data of oGrid1
82591>>>                
82591>>>                Get Item_Count of oGrid1 to iLinhas
82592>>>                
82592>>>                For iContador from 0 to (iLinhas - 1)
82598>>>>
82598>>>                    Get Value of oGrid1 item iContador to saLista[iContador]
82599>>>                Loop
82600>>>>
82600>>>                
82600>>>                // Extrai as informa‡äes das xmls para a array
82600>>>                Get GGGLerXmls saLista (Value(oCNPJ,0)) to ListaNFe
82601>>>                                
82601>>>                // Consome o webservice e recebe de volta o PDF das guias prontas para serem gravadas em disco e impressas.                
82601>>>                Get GGGGeraGuiaPDF (Value(oCNPJ,0)) (Value(oLogin,0)) (Value(oToken,0)) ListaNFe to PdfGuias
82602>>>                
82602>>>                // RetornoLote.retorno = 0 -> Sucesso.
82602>>>                If (PdfGuias.retorno > 0);                Begin
82604>>>                    Error DFERR_OPERATOR ("Pendˆncias na gera‡Æo das guias.\nC¢digo do retorno: " + (String(PdfGuias.retorno)) + " - Descri‡Æo: " + (PdfGuias.msg_retorno))
82605>>>>
82605>>>                End
82605>>>>
82605>>>                
82605>>>                File_Exist "C:\Temp" bExiste
82606>>>                If (not(bExiste)) Make_Directory "C:\Temp"
82609>>>                
82609>>>                Move (String(CurrentDateTime())) to sArq
82610>>>                Move (Replaces(" ", sArq, "")) to sArq
82611>>>                Move (Replaces("/", sArq, "")) to sArq
82612>>>                Move (Replaces(":", sArq, "")) to sArq
82613>>>                Move (Replaces(",", sArq, "")) to sArq
82614>>>                Move ("C:\Temp\PDFGuias_" + sArq + ".pdf") to sArq
82615>>>                
82615>>>                Get Seq_New_Channel to iCanal
82616>>>                If (iCanal = DF_SEQ_CHANNEL_NOT_AVAILABLE) ;                Begin
82618>>>                    Error DFERR_OPERATION_NOT_ALLOWED ' Tente novamente !'
82619>>>>
82619>>>                    Procedure_Return
82620>>>                End
82620>>>>
82620>>>                
82620>>>                Move 0 to iContador
82621>>>                
82621>>>                If (SizeOfArray(PdfGuias.pdf_guias[0].pdf)) Begin   
82623>>>                    Direct_Output channel iCanal ('BINARY:EOF: -1:' + sArq)
82625>>>                    While (iContador < (SizeOfArray(PdfGuias.pdf_guias[0].pdf)))
82629>>>                        Write channel iCanal (Character(PdfGuias.pdf_guias[0].pdf[iContador]))
82631>>>                        Increment iContador
82632>>>                    Loop                
82633>>>>
82633>>>                    Close_Output channel iCanal
82635>>>                End
82635>>>>
82635>>>                
82635>>>                Send Cursor_Ready of Cursor_Control
82636>>>                
82636>>>                File_Exist sArq bExiste
82637>>>                If bExiste Send Info_Box ("Arquivo " + sArq + " salvo com sucesso.")
82640>>>            End_Procedure
82641>>>        End_Object
82642>>>
82642>>>        Object oButtonBuscaGuiaPDF is a Button
82644>>>            Set Size to 14 84
82645>>>            Set Location to 10 97
82646>>>            Set Label to "Busca Guia PDF"
82647>>>            
82647>>>            Procedure OnClick
82650>>>                Send BuscaGuiaPDF                    
82651>>>            End_Procedure
82652>>>            
82652>>>            Procedure BuscaGuiaPDF
82655>>>                String sArq
82655>>>                Integer iCanal i
82655>>>                Boolean bExiste
82655>>>                UChar[] PDF
82656>>>                tWStRetornoLotePDF LotePDF
82656>>>                tWStRetornoLotePDF LotePDF
82656>>>                tWStRetornoLote Lote
82656>>>                tWStRetornoLote Lote
82656>>>                
82656>>>                // Lista de c¢digos de retorno: 
82656>>>                // 0 = Sucesso
82656>>>                // 1 = NÆo autorizado. Verifique o CNPJ, Usu rio e Token.
82656>>>                // 2 = Lote processado com pendˆncias.
82656>>>                // 3 = Nenhuma guia liberada no momento.
82656>>>                // 4 = Falha ao buscar guias. 
82656>>>                // 5 = Falha ao gerar o PDF.
82656>>>                // 6 = Data inicial inv lida. PadrÆo esperado: AAAA-MM-DD. 
82656>>>                // 7 = Data final inv lida. PadrÆo esperado: AAAA-MM-DD.
82656>>>                
82656>>>                Send Cursor_Wait of Cursor_Control
82657>>>                                
82657>>>                // Esta fun‡Æo, GGGBuscaGuiaPDF, exige uma estrutura de dados de retorno, com os recibos, etc, como parƒmetro.
82657>>>                // Como nÆo estamos guardando nada em banco, guardamos o retorno da chamada de GeraGuia, para ser carregada aqui 
82657>>>                // como exemplo.
82657>>>                Get ptLoteGuias of oExemplo2 to Lote
82658>>>                
82658>>>                Get GGGBuscaGuiaPDF (Value(oCNPJ,0)) (Value(oLogin,0)) (Value(oToken,0)) Lote to LotePDF
82659>>>                
82659>>>                If (LotePDF.retorno > 0);                Begin
82661>>>                    Error DFERR_OPERATOR ("Pendˆncias na busca das guias.\n\nC¢digo do retorno: " + (String(LotePDF.retorno)) + "\nDescri‡Æo: " + (LotePDF.msg_retorno))
82662>>>>
82662>>>                End
82662>>>>
82662>>>                
82662>>>                File_Exist "C:\Temp" bExiste
82663>>>                If (not(bExiste)) Make_Directory "C:\Temp"
82666>>>                
82666>>>                Move (String(CurrentDateTime())) to sArq
82667>>>                Move (Replaces(" ", sArq, "")) to sArq
82668>>>                Move (Replaces("/", sArq, "")) to sArq
82669>>>                Move (Replaces(":", sArq, "")) to sArq
82670>>>                Move (Replaces(",", sArq, "")) to sArq
82671>>>                Move ("C:\Temp\PDFGuias_" + sArq + ".pdf") to sArq
82672>>>                
82672>>>                Get Seq_New_Channel to iCanal
82673>>>                If (iCanal = DF_SEQ_CHANNEL_NOT_AVAILABLE) ;                Begin
82675>>>                    Error DFERR_OPERATION_NOT_ALLOWED ' Tente novamente !'
82676>>>>
82676>>>                    Procedure_Return
82677>>>                End       
82677>>>>
82677>>>                
82677>>>                If (SizeOfArray(LotePDF.pdf_guias[0].pdf)) Begin                
82679>>>                    Direct_Output channel iCanal ('BINARY:EOF: -1:' + sArq)
82681>>>                    While (i < (SizeOfArray(LotePDF.pdf_guias[0].pdf)))
82685>>>                        Write channel iCanal (Character(LotePDF.pdf_guias[0].pdf[i]))
82687>>>                        Increment i
82688>>>                    Loop                
82689>>>>
82689>>>                    Close_Output channel iCanal
82691>>>                End
82691>>>>
82691>>>                
82691>>>                Send Cursor_Ready of Cursor_Control
82692>>>                                                
82692>>>                File_Exist sArq bExiste
82693>>>                If bExiste Send Info_Box ("Arquivo " + sArq + " salvo com sucesso.")
82696>>>            End_Procedure
82697>>>        
82697>>>        End_Object
82698>>>    End_Object
82699>>>
82699>>>Cd_End_Object
82701>>>>
82701>
82701>        Procedure Activate_About
82704>            Send DoAbout "Test Windows Project" "0.0.0" "" "" ""
82705>        End_Procedure
82706>
82706>    End_Object
82707>
82707>
82707>    // All of the code below are methods and augmentations which makes this work well as a test program. This:
82707>    // 1. Supports an auto-activate feature where all dialogs in the view and report menu are activated upon startup
82707>    // 2. forces the panel to resize if it is not large enough to accomodate all of the views.
82707>    // This code was placed directly in the testproject template and, therefore, directly in the .src file so
82707>    // a developer can easily modify this to fit their own needs. It is not expected that these techniques would
82707>    // get used in actual deployed projects.
82707>
82707>    // special test component code to activate all views and reports. For testing we assume
82707>    // that you want to see everything.
82707>
82707>    Procedure AutoActivate
82710>        handle hoMenu
82710>
82710>        // this activates all views from the view menu
82710>        Get phoViewMenu to hoMenu
82711>        If hoMenu begin
82713>           Broadcast Send Execute of hoMenu
82715>        End
82715>
82715>        // this activates all views from the report view menu
82715>        Get phoReportMenu to hoMenu
82716>        If hoMenu begin
82718>           Broadcast Send Execute of hoMenu
82720>        End
82720>    End_Procedure
82721>
82721>    // This checks all views within the client area to make sure that they fit within
82721>    // the client area. If not we will adjust the main panel so everything fits. This
82721>    // can only be done after the objects are all activated.
82721>
82721>    Procedure MakeGoodPanelSize
82724>        Handle hoView hoClient
82724>        Integer iSize iLoc iHeight iWidth iOldSize
82724>        Get Client_Id to hoClient
82725>        If hoClient begin
82727>            Get GuiSize of hoClient to iOldSize  // starting size of client area
82728>            Move (Hi(iOldSize)) to iHeight
82729>            Move (Low(iOldSize)) to iWidth
82730>            // for each mdi client see if it fits, keep track of largest size needed
82730>            Get Next_Mdi_Dialog of hoClient True to hoView // find first
82731>            While (hoView)
82735>                Get GuiSize of hoView to iSize    // size of view
82736>                Get GuiLocation of hoView to iLoc // location of view
82737>                Move (hi(iSize)+hi(iLoc)+10 max iHeight)  to iHeight // max height needed (+10 is for wiggle room)
82738>                Move (low(iSize)+low(iLoc)+10 max iWidth) to iWidth  // max width needed
82739>                Get Next_Mdi_Dialog of hoClient False to hoView // find next view
82740>            Loop
82741>            Move (iHeight-hi(iOldSize) max 0) to iHeight // get delta compared to old size. We want delta
82742>            Move (iWidth-low(iOldSize) max 0) to iWidth  // only if the new size is bigger (i.e., > 0)
82743>            If  (iHeight>0 or iWidth>0) begin
82745>                Get GuiSize to iOldSize // now add the delta to the panel size
82746>                Set GuiSize to (hi(iOldSize)+iHeight) (low(iOldSize)+iWidth)
82747>                Send Adjust_Logicals // adjust from gui to regular size
82748>            End
82748>        End
82748>    End_Procedure
82749>
82749>    // special test program  augmentation which opens all views and report views and
82749>    // makes sure that the size of the panel is big enough
82749>
82749>    Procedure End_Construct_Object
82752>        Boolean bAutoActivate
82752>        Get Auto_Activate_State to bAutoActivate
82753>        Forward send End_Construct_Object
82755>        If bAutoActivate begin
82757>            Send AutoActivate       // activate all views and report views
82758>            Send MakeGoodPanelSize  // make sure the panel is big enough for all of this
82759>        End
82759>    End_Procedure
82760>
82760>End_Object
82761>
82761>Start_UI
82762>
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 46570
Total Resources: 0
Total Commands : 82761
Total Windows  : 1
Total Pages    : 1
Static Data    : 538045
Message area   : 575169
Total Blocks   : 29810
